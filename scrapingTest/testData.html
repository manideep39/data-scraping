<!DOCTYPE html><html lang="en"><head><script defer src="./script.js">
        </script></head><body><h3><p>What is MongoDB?</p>
</h3><div><ul>
<li>MongoDB is a document-based database that is highly scalable, and offers better performance.</li>
</ul>
</div><hr><h3><p>Define a replica set?</p>
</h3><div><ul>
<li>The group of instances that host a similar data set is known as a replica set. Two nodes are present in a replica set, one is secondary and the other is primary, where data is replicated from the primary and sent to the secondary node.</li>
</ul>
<blockquote>
<p><em>If you want to enrich your career and become a professional in <strong>MongoDB</strong>, then visit <strong>Mindmajix</strong> - a global <strong>online training</strong> platform: <strong>"<a href="../../mongodb-training" title="MongoDB Training">MongoDB Training</a>"</strong> This course will help you to achieve excellence in this domain.</em></p>
</blockquote>
</div><hr><h3><p>What is the role of a profiler in MongoDB?</p>
</h3><div><ul>
<li>The role of a MongoDB profiler is to show the performance and analyze the characteristics of every operation of the database. By using the profiler, you will find all the queries which are slower than usual.</li>
</ul>
</div><hr><h3><p>What are the different types of NoSQL databases? Give some examples.</p>
</h3><div><ul>
<li>
<p>The NoSQL database is classified into four basic types. The following is the classification of NoSQL database:</p>
</li>
<li>
<p>Column store</p>
</li>
<li>
<p>Document store</p>
</li>
<li>
<p>Key-value store</p>
</li>
<li>
<p>Graph base</p>
</li>
</ul>
<p>The following are the few examples of NoSQL database</p>
<ul>
<li>MongoDB</li>
<li>Cassandra</li>
<li>CouchDB</li>
<li>HBASE</li>
</ul>
<p><strong>Related Blog: [<a href="../../mongodb-vs-dynamodb" title="MongoDB VS DynamoDB">MongoDB VS DynamoDB</a>]</strong></p>
</div><hr><h3><p>What are the key features of MongoDB?</p>
</h3><div><p>*&nbsp;The following are the core features of MongoDB:</p>
<ul>
<li>High performance</li>
<li>Automatic scaling</li>
<li>Rich query language</li>
<li>High availability</li>
</ul>
</div><hr><h3><p>What is the advantage of MongoDB?</p>
</h3><div><p>*&nbsp;The following are a few advantages of MongoDB database:</p>
<ul>
<li>SchemalesS</li>
<li>Easy to scale-out</li>
<li>No complex joins</li>
<li>Structure of a single object is clear</li>
</ul>
</div><hr><h3><p>Which programming languages can be used with MongoDB?</p>
</h3><div><p>*&nbsp;MongoDB accepts all the programming languages. The following is a list of a few languages:</p>
<ul>
<li>C</li>
<li>C++</li>
<li>C#</li>
<li>Java</li>
<li>Node.js</li>
<li>Perl</li>
<li>PHP</li>
<li>Python</li>
<li>Ruby</li>
<li>Scala</li>
<li>Go</li>
<li>Erlang.</li>
</ul>
<h4><a href="../../mongodb-create-database">How to create Database in MonogoDB?</a></h4>
</div><hr><h3><p>What is an embedded document?</p>
</h3><div><p>*&nbsp;Embedded documents specify the relationship between data that is written inside the body. The documents are received while the related data body is small.</p>
</div><hr><h3><p>Do a MongoDB database support foreign-key and primary-key relationship?</p>
</h3><div><ul>
<li>No, by default, MongoDB doesn't support foreign key or a primary key relationship.</li>
</ul>
</div><hr><h3><p>Define the storage engine in MongoDB with an example.</p>
</h3><div><p>*&nbsp;A storage engine is a part of the database and is used to manage data storage on the disk. For instance, if there are two storage engines, one engine might offer support for read-heavy workloads, and another storage engine might offer higher-throughput for writing operations.</p>
</div><hr><h3><p>How to move an old file into the moveChunk directory?</p>
</h3><div><p>*&nbsp;All the old files are converted into backup files and are moved into moveChunk directory at a time once the function is done.</p>
</div><hr><h3><p>How does MongoDB offer consistency?</p>
</h3><div><p>*&nbsp;To provide consistency, MongoDB makes use of reader-writer locks to allow readers to simultaneously access any collection like a database but it always offers private access to single writers.</p>
</div><hr><h3><p>What query is used in MongoDB to create and drop a collection?</p>
</h3><div><ul>
<li>
<p>The following are the queries used to create and drop a collection:</p>
<p>db.createCollection(name,options) // create a collection
db.collection.drop() // drop a collection</p>
</li>
</ul>
</div><hr><h3><p>In MongoDB what is Objecld composed of?</p>
</h3><div><ul>
<li>
<p>The Objectld is composed of the following parameters:</p>
</li>
<li>
<p>Client machine ID</p>
</li>
<li>
<p>Timestamp</p>
</li>
<li>
<p>3 byte incremented counter</p>
</li>
<li>
<p>Client process ID</p>
</li>
</ul>
</div><hr><h3><p>What does sharding mean in MongoDB?</p>
</h3><div><p>*&nbsp;Sharding is a process of storing data records among one or more machines applied by MongoDB to meet the demands of data growth. It forms a horizontal partition in the database and each partition is known as database shard or a shard.</p>
</div><hr><h3><p>What is CRUD?</p>
</h3><div><p>*&nbsp;Mongodb offers best CRUD operations to perform better database operations. The following are the operations:</p>
<ul>
<li>Create</li>
<li>Read</li>
<li>Update</li>
<li>Delete</li>
</ul>
</div><hr><h3><p>In MongoDB, which command can be used to provide all information of a query plan?</p>
</h3><div><p>*&nbsp;The explain() command is used to provide information of all the query plans. The possible models are as follows:</p>
<ul>
<li>'queryPlanner',</li>
<li>'executionStats'</li>
<li>'allPlansExecution'.</li>
</ul>
<p>More information about <a href="../../mongodb-find-queries">MongoDB find queries</a></p>
</div><hr><h3><p>Define GridFS and its functionality in MongoDB?</p>
</h3><div><p>*&nbsp;In MongoDB, <strong>GridFS</strong> is a special specification for storing and retrieving files which exceed the BSON-document size limit (16MB). The major functionality of this grid is to divide a file into smaller segments, and stores each of those segments as a separate document instead of storing then into a single document.</p>
</div><hr><h3><p>what command is used to create a MongoDB collection?</p>
</h3><div><p>*&nbsp;db.createCollection (name, options) is a command used to create collection MongoDB.</p>
</div><hr><h3><p>What feature in MongoDB is used to do safe backups?</p>
</h3><div><p>*&nbsp;To save backups of the old files “Journaling” feature is used in MongoDB databases.</p>
</div><hr><h3><p>What’s a good way to get a list of all unique tags for a collection of documents millions of items large when we doesn't have access to mongodb’s new “distinct” command ?</p>
</h3><div><ul>
<li>The normal way of doing tagging seems to be indexing multikeys. Even if your MongoDB driver doesn’t implement distinct, we can implement.</li>
</ul>
<p>In JavaScript you can write something like this:</p>
<pre><code>result = db.$cmd.findOne({“distinct” : “collection_name”, “key” : “tags”})
</code></pre>
<p>You do a findOne on the “$cmd” collection of whatever database you’re using. Pass it the collection name and the key you want to run distinct on.</p>
<p>If you ever need a command your driver doesn’t provide a helper for, you can look at the below link for a complete list of database commands.</p>
<p>https://docs.mongodb.com/manual/reference/command/</p>
</div><hr><h3><p>How to get the names of all the keys in a MongoDB collection?</p>
</h3><div><ul>
<li></li>
</ul>
<p>For example, from this:
db.things.insert( { type : [‘dog’, ‘cat’] } );
db.things.insert( { egg : [‘cat’] } );
db.things.insert( { type : [] } );
db.things.insert( { hello : []  } );
How to get the unique keys: type, egg, hello</p>
<p>We could do this with MapReduce:</p>
<pre><code>mr = db.runCommand({
“mapreduce” : “my_collection”,
“map” : function() {
for (var key in this) { emit(key, null); }
},
“reduce” : function(key, stuff) { return null; },
“out”: “my_collection” + “_keys”
})
</code></pre>
<p>Then run distinct on the resulting collection so as to find all the keys:</p>
<pre><code>db[mr.result].distinct(“_id”)
[“foo”, “bar”, “baz”, “_id”, …]
</code></pre>
</div><hr><h3><p>How to browse or query live MongoDB data?</p>
</h3><div><ul>
<li>
<p>Below is some utilities available in the market.</p>
</li>
<li>
<p>MongoHub is moved to a native mac version, please check&nbsp; <a href="https://github.com/bububa/MongoHub-Mac">https://github.com/bububa/MongoHub-Mac</a>.</p>
</li>
<li>
<p><a href="https://github.com/Imaginea/mViewer">https://github.com/Imaginea/mViewer</a> This is awesome with tree and document views.</p>
</li>
<li>
<p>genghisapp</p>
</li>
</ul>
<p>It is a web-based GUI that is clean, light-weight, straight-forward, offers keyboard shortcuts, and works awesomely. It also supports GridFS.</p>
<p>Best of all, it’s a single script.</p>
<pre><code>To install it
            $ gem install genghisapp bson_ext
            (bson_ext is optional but will greatly improve the performance of the gui)

            To run it (this will automatically open your web browser and navigate to the app as well)
            genghisapp

            To stop it
            genghisapp –kill
</code></pre>
</div><hr><h3><p>How to use map/reduce to handle more than 10000 unique keys for grouping in MongoDB?</p>
</h3><div><ul>
<li>Use Version 2.2. The db.collection.group() method's returned array can contain at most 20,000 elements; i.e. at most 20,000 unique groupings. For group by operations that result in more than 20,000 unique groupings, use mapReduce. Previous versions had a limit of 10,000 elements.</li>
</ul>
</div><hr><h3><p>Can anyone share some insight on the index/RAM relationship and what happens when both an individual index and all of my indexes exceed the size of available RAM?</p>
</h3><div><ul>
<li>MongoDB keeps what it can of the indexes in RAM. They’ll be swapped out on an LRU basis. You’ll often see documentation that suggests you should keep your “working set” in memory: if the portions of index you’re actually accessing fit in memory, you’ll be fine.</li>
</ul>
<p>It is the working set size plus MongoDB’s indexes that should ideally reside in RAM at all times i.e. the amount of available RAM should ideally be at least the working set size plus the size of indexes plus what the rest of the OS (Operating System) and other software running on the same machine needs. If the available RAM is less than that, LRUing is what happens and we might therefore get significant slowdown.</p>
<p>One thing to keep in mind is that in an index btree buckets are cached, not individual index keys i.e. if we had a uniform distribution of keys in an index including for historical data, we might need more of the index in RAM compared to when we have a compound index on time plus something else. With the latter, keys in the same btree bucket are usually from the same time era, so this caveat does not happen. Also, we should keep in mind that our field names in BSON are stored in the records (but not the index) so if we are under memory pressure they should be kept short.</p>
<h2>MongoDB Interview Questions and Answers for Experienced</h2>
</div><hr><h3><p>What does an appropriate db.ClockTime.update() statement look like to convert these text based values to a date datatype?</p>
</h3><div><ul>
<li>
<p>This code should do it:</p>
<blockquote>
<p>var cursor = db.ClockTime.find()
while (cursor.hasNext()) {
… var doc = cursor.next();
… db.ClockTime.update({_id : doc._id}, {$set : {ClockInTime : new Date(doc.ClockInTime)}})
… }
I have exactly the same situation as Jeff Fritz.
In my case I have succeed with the following simpler solution:
db.ClockTime.find().forEach(function(doc) {
doc.ClockInTime=new Date(doc.ClockInTime);
db.ClockTime.save(doc);
})</p>
</blockquote>
</li>
</ul>
</div><hr><h3><p>Updating a specific key/value inside of an array field with MongoDB</p>
</h3><div><ul>
<li>As a preface, I’ve been working with MongoDB for about a week now, so this may turn out to be a pretty simple answer.</li>
</ul>
<p>I have data already stored in my collection, we will call this collection content, as it contains articles, news, etc. Each of these articles contains another array called author which has all of the author’s information (Address, Phone, Title, etc).</p>
<p><strong>The Goal –</strong> I am trying to create a query that will update the author’s address on every article that the specific author exists in, and only the specified author block (not others that exist within the array).</p>
<p>Sort of a “Global Update” to a specific article that affects his/her information on every piece of content that exists.</p>
<p>Here is an example of what the content with the author looks like.</p>
<pre><code>{
“_id” : ObjectId(“4c1a5a948ead0e4d09010000”),
“authors” : [
{
“user_id” : null,
“slug” : “joe-somebody”,
“display_name” : “Joe Somebody”,
“display_title” : “Contributing Writer”,
“display_company_name” : null,
“email” : null,
“phone” : null,
“fax” : null,
“address” : null,
“address2” : null,
“city” : null,
“state” : null,
“zip” : null,
“country” : null,
“image” : null,
“url” : null,
“blurb” : null
},
{
“user_id” : null,
“slug” : “jane-somebody”,
“display_name” : “Jane Somebody”,
“display_title” : “Editor”,
“display_company_name” : null,
“email” : null,
“phone” : null,
“fax” : null,
“address” : null,
“address2” : null,
“city” : null,
“state” : null,
“zip” : null,
“country” : null,
“image” : null,
“url” : null,
“blurb” : null
},
],
“tags” : [
“tag1”,
“tag2”,
“tag3”
],
“title” : “Title of the Article”
}
</code></pre>
<p>I can find every article that this author has created by running the following command:</p>
<pre><code>db.content.find({authors: {$elemMatch: {slug: ‘joe-somebody’}}});
</code></pre>
<p>So theoretically I should be able to update the author's record for the slug joe-somebody but notjane-somebody (the 2nd author), I am just unsure exactly how you reach in and update every record for that author.</p>
<p>I thought I was on the right track, and here’s what I’ve tried.</p>
<pre><code>{
“_id” : ObjectId(“4c1a5a948ead0e4d09010000”),
“authors” : [
{
“user_id” : null,
“slug” : “joe-somebody”,
“display_name” : “Joe Somebody”,
“display_title” : “Contributing Writer”,
“display_company_name” : null,
“email” : null,
“phone” : null,
“fax” : null,
“address” : null,
“address2” : null,
“city” : null,
“state” : null,
“zip” : null,
“country” : null,
“image” : null,
“url” : null,
“blurb” : null
},
{
“user_id” : null,
“slug” : “jane-somebody”,
“display_name” : “Jane Somebody”,
“display_title” : “Editor”,
“display_company_name” : null,
“email” : null,
“phone” : null,
“fax” : null,
“address” : null,
“address2” : null,
“city” : null,
“state” : null,
“zip” : null,
“country” : null,
“image” : null,
“url” : null,
“blurb” : null
},
],
“tags” : [
“tag1”,
“tag2”,
“tag3”
],
“title” : “Title of the Article”
}
</code></pre>
<p>Solution:</p>
<p>This is what finally worked for me!</p>
<pre><code>db.content.update({‘authors.slug’:’joe-somebody’},{$set:{‘authors.$.address’:’Address That I wanted’}},false,true);
</code></pre>
<p>It updates all the records properly, thanks!</p>
<p>Maybe you can use the $ operator (positional-operator)?</p>
</div><hr><h3><p>MongoDB – simulate join or subquery</p>
</h3><div><ul>
<li>I’m trying to figure out the best way to structure my data in Mongo to simulate what would be a simple join or subquery in SQL.</li>
</ul>
<p>Say I have the classic Users and Posts example, with Users in one collection and Posts in another. I want to find all posts by users who’s city is “london”.</p>
<p>I’ve simplified things in this question, in my real world scenario storing Posts as an array in the User document won’t work as I have 1,000’s of “posts” per user constantly inserting.</p>
</div><hr><h3><p>Can Mongos $in operator help here? Can $in handle an array of 10,000,000 entries?</p>
</h3><div><ul>
<li>Honestly, if you can’t fit “Posts” into “Users”, then you have two options.</li>
</ul>
<ol>
<li>Denormalize some User data inside of posts. Then you can search through just the one collection.</li>
<li>Do two queries. (one to find users the other find posts)</li>
</ol>
<p>Based on your question, you’re trying to do #2.</p>
<p>Theoretically, you could build a list of User IDs (or refs) and then find all Posts belonging to a User$in that array. But obviously that approach is limited.</p>
</div><hr><h3><p>Can $in handle an array of 10,000,000 entries?</p>
</h3><div><ul>
<li>Look, if you’re planning to “query” your posts for all users in a set of 10,000,000 Users you are well past the stage of “query”. You say yourself that each User has 1,000s of posts so you’re talking about a query for “Users with Posts who live in London” returning 100Ms of records.<br>
<strong>100M records isn’t a query, that’s a dataset!</strong></li>
</ul>
<p>If you’re worried about breaking the $in command, then I highly suggest that you use map/reduce. The Mongo Map/Reduce will create a new collection for you. You can then trim down or summarize this dataset as you see fit.</p>
<p>$in can handle 100,000 entries. I’ve never tried 10,000,000 entries but the query (a query is also a document) has to be smaller than 4mb (like every document) so 10,0000,0000 entries isn’t possible.</p>
<p>Why don’t you include the user and its town in the Posts collection? You can index this town because you can index properties of embedded entities. You no longer have to simulate a join because you can query the Posts on the towns of its embedded users.</p>
<p>This means that you have to update the Posts when the town of a user changes but that doesn’t happen very often. This update will be fast if you index the UserId in the Posts collection.</p>
</div><hr><h3><p>Mongo complex sorting?</p>
</h3><div><ul>
<li>I know how to sort queries in MongoDB by multiple fields, e.g.,db.coll.find().sort({a:1,b:-1}).</li>
</ul>
</div><hr><h3><p>Can I sort with a user-defined function; e.g., supposing a and b are integers, by the difference between a and b (a-b)?</p>
</h3><div><ul>
<li>I don’t think this is possible directly; the sort documentation certainly doesn’t mention any way to provide a custom compare function.</li>
</ul>
<p>You’re probably best off doing the sort in the client, but if you’re really determined to do it on the server you might be able to use db.eval() to arrange to run the sort on the server (if your client supports it).</p>
<pre><code>Server-side sort:
db.eval(function() {
return db.scratch.find().toArray().sort(function(doc1, doc2) {
return doc1.a – doc2.a
})
});

Versus the equivalent client-side sort:
db.scratch.find().toArray().sort(function(doc1, doc2) {
return doc1.a – doc2.b
});
</code></pre>
<p>Note that it’s also possible to sort via an aggregation pipeline and by the $orderby operator (i.e. in addition to .sort()) however neither of these ways lets you provide a custom sort function either. Why don’t create the field with this operation and sort on it ?</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-vs-postgresql">MongoDB Vs PostgreSQL Comparison</a></strong></p>
</div><hr><h3><p>How to set a primary key in MongoDB?</p>
</h3><div><ul>
<li>I want to set one of <strong>my fields as the primary key.</strong> I am using MongoDB as my NoSQL.<br>
The _id field is reserved for primary key in mongodb, and that should be an unique value. If you don’t set anything to _id it will automatically fill it with “MongoDB Id Object”. But you can put any unique info into that field. Additional info: <a href="https://www.mongodb.org/display/DOCS/BSON">https://www.mongodb.org/display/DOCS/BSON</a> Hope it helps.</li>
</ul>
</div><hr><h3><p>Delete everything in a MongoDB database</p>
</h3><div><ul>
<li>
<p>I’m doing development on MongoDB. For totally non-evil purposes, I sometimes want to blow away everything in a databasethat is, to delete every single collection, and whatever else might be lying around, and start from scratch. Is there a single line of code that will let me do this? Bonus points for giving both a MongoDB console method and a MongoDB Ruby driver method.</p>
<p>use [database];
db.dropDatabase();
Ruby code should be pretty similar.
Also, from the command line:
mongo [database] –eval “db.dropDatabase();”Use
[databaseName]
db.Drop+databaseName();
drop collection
use databaseName
db.collectionName.drop();</p>
</li>
</ul>
</div><hr><h3><p>How to $set sub-sub-array items in MongoDB</p>
</h3><div><ul>
<li>
<p>I’m developing a webapp which has a portal-ish component to it (think like multiple panels that can be drug around from column to column and added or removed). I’m using MongoDB to store this info with a format like so…<br>
Skip code block</p>
<p>{
_id: ObjectId(…),
title: ‘My Layout’,
columns: [
{
order: 1,
width: 30,
panels: [
{ title: ‘Panel Title’, top: 100, content: ‘…’ },
{ title: ‘Panel Title’, top: 250, content: ‘…’ },
]
},
{
… multiple columns …
}
]
}</p>
<p>I’m attempting to use atomic/modifier operations with update() and this is getting confusing. If I wanted to just update one property of a specific panel, how do I reference that?
update(
{ _id: ObjectId(…) },
{ $set: { columns.[???].panels.[???].top: 500 }
)</p>
<p>If you know the index in the array you can access the array element directly using dot notation.
update(
{ _id: ObjectId(xxxx) },
{ $set: { ‘columns.0.panels.0.top’ : 125}}
)</p>
</li>
</ul>
<p>Make sure you encase the dot notated path in quotes as a string.</p>
<p><strong>Edit:</strong></p>
<p>To give more detail on how this could work dynamically, I’ll give an example in PHP:</p>
<pre><code>$action = array(“columns.$colNum.panels.$panelNum” =&gt; $newValue);
</code></pre>
<p>Yes there is the positional operator, but it does not appear to be advanced enough to change arrays within arrays, this may change in MongoDB 1.7.0<br>
There is an alternative you can do instead of trying to stuff this information into a nested document. Try to flatten it out. You can create a collection that has panel &amp; column objects:<br>
column object:</p>
<pre><code>{
_id: // MongoId
type: ‘column’,
user: ‘username’,
order: 1,
width: 30,
}
panel object:
{
_id: //MongoId
type: ‘panel’,
user: ‘username’,
parentColumn: //the columns _id string
top: 125,
left: 100
}
</code></pre>
<p>Then you can find all columns that belong to a user by doing:</p>
<pre><code>find({ type: ‘column’, user:’username’});
You can find all panels for a specific column by doing:
find({type: ‘panel’, columnOwner:’ownerID’});
Since each column and panel will have a unique ID given by MongoDB to it, you can easily query and atomically set options.
update({‘_id’: ObjectId(‘idstring’)}, {$set : { ‘top’ : 125}});
</code></pre>
</div><hr><h3><p>Some beginner’s questions about MongoDB</p>
</h3><div><ul>
<li>I’m a beginner with MongoDB and I’ve some questions:</li>
</ul>
<ol>
<li>When I’m connected to Mongo, and i executeshow dbs I see 2 databases: admin and local. What’s their role? Then if I execute an insert command likedb.foo.insert({“value”:”mongo”}), the test database appears. Why? How can i specify a custom name for a database?</li>
<li>Withshow dbs I get the databases (somehow like show databases in sql), how can I then list the collections inside a database (I would use show tables in sql)?</li>
<li>When executing a command, the MongoDB tutorial always uses thedb object. Is it the main object (a sort of “connection” object) that has to used for executing commands or it’s something else?</li>
</ol>
<p>Thanks!</p>
<ul>
<li>Adminand local contain various settings local to the server, like users who are authenticated to connect. Under beginner usage, you shouldn’t need to worry about them at all. By default you connect to a database named test. To connect to a new database, just use databasename from the mongo command line, or mongo databasename from your OS shell.</li>
<li>Use [database_name]and then show collections</li>
<li>Thedb object is your root handle to the currently-selected database on the mongo command line. The command line is really just a Javascript command line, and there are various mongodb-specific objects and functions exposed that let you do stuff. Try help() for a full listing.</li>
</ul>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-gui-tools">MongoDB GUI - Top 7 MongoDB GUI Tools</a></strong></p>
</div><hr><h3><p>How to update based on existing data in mongo</p>
</h3><div><ul>
<li>Sort of a mongo noob, and I have a feeling I am tackling this problem from the wrong direction.</li>
</ul>
<p>I have about a 7 million document collection. Each document has two fields that I want to modify(not replace), basically they are big strings that have , and I want to replace those with n.<br>
I spent about an hour trying to find a way to “backreference” the object returned by the query, which totally doesn’t exist. What is the best approach for something like this?<br>
You’ll have to query for all the documents and update them one by one. If you do it in JavaScript, it would be something like:</p>
<pre><code>mydb = db.getSisterDB(“whateverDBYoureUsing”);
var cursor = mydb.foo.find();
while (cursor.hasNext()) {
var x = cursor.next();
/* replace with n in x’s strings … */
db.foo.update({_id : x._id}, x);
}
</code></pre>
<p>You can copy this into a .js file (say, replace.js), change the db and collection names, and run it as a script from the shell:<br>
mongo replace.js</p>
</div><hr><h3><p>How to print out more than 20 items (documents) in MongoDB’s shell?</p>
</h3><div><ul>
<li></li>
</ul>
<pre><code>db.foo.find().limit(300)
won’t do it… it still prints out 20
db.foo.find().toArray()
db.foo.find().forEach(printjson)
</code></pre>
<p>will both print out very expanded view of each document instead of the 1-line version for find():<br>
DBQuery.shellBatchSize = 300<br>
will do.<br>
MongoDB Docs – Getting Started with the mongo Shell – Executing Queries<br>
You can use it inside of the shell to iterate over the next 20 results. Just type it if you see “has more” and you will see the next 20 items.<br>
from the shell if you want to show all results you could do db.collection.find().toArray() to get all results without it<br>
Could always do:</p>
<pre><code>db.foo.find().forEach(function(f){print(tojson(f, ”, true));});
To get that compact view.
Also, I find it very useful to limit the fields returned by the find so:
db.foo.find({},{name:1}).forEach(function(f){print(tojson(f, ”, true));});
</code></pre>
<p>which would return only the _id and name field from foo.</p>
</div><hr><h3><p>How to store timestamps? Are created and updated fields available automatically?</p>
</h3><div><ul>
<li>What’s the best way to store timestamps in MongoDB?</li>
</ul>
<p>Which format is best:</p>
<pre><code># “created”: { “d” : “2010-03-29”, “t” : “20:15:34” }
# “created”: “12343545234” # seconds since epoc
# “created”: “2010-03-14T21:20:14+0000”
</code></pre>
<p>Is there a way to have MongoDB automatically setcreated and updated fields?</p>
<p>Which format is best<br>
Best for what?<br>
Is there a way to have MongoDB automatically set created and updated fields?<br>
Created time is in the ObjectId but, as far as I know, you will have to update a updated field manually.</p>
<p><strong>Example:</strong></p>
<pre><code>ObjectId(“538141a9615760fd04ffef5f”).getTimestamp()
</code></pre>
<p>1. The format you need to process it with best performance in your application should be preferred. Note that as default every document in MongoDB gets a created timestamp</p>
<p>(https://www.mongodb.org/display/DOCS/Object+IDs#ObjectIDs-DocumentTimestamps)</p>
<p>2. See 1) + I think you need to manually set the “update” field.<br>
If you do following on mongo shell it shows you time stamp that represents when that documents inserted using mongoId. For ex. ObjectId(“51f3dee5ee49f9b91e0db133”).getTimestamp(), then it returns ISODate.</p>
</div><hr><h3><p>MongoDB: Updating documents using data from the same document</p>
</h3><div><ul>
<li>
<p>I have a list of documents, each with lat and lon properties (among others).</p>
<p>{ ‘lat’: 1, ‘lon’: 2, someotherdata […] }
{ ‘lat’: 4, ‘lon’: 1, someotherdata […] }
[…]
I want to modify it so that it looks like this:
{ ‘coords’: {‘lat’: 1, ‘lon’: 2}, someotherdata […]}
{ ‘coords’: {‘lat’: 4, ‘lon’: 1}, someotherdata […]}
[…]</p>
</li>
</ul>
<p>So far I’ve got this:</p>
<pre><code>db.events.update({}, {$set : {‘coords’: {‘lat’: db.events.lat, ‘lon’: db.events.lon}}}, false, true)
</code></pre>
<p>But it treats the db.events.lat and db.events.lon as strings. How can I reference the document’s properties? Cheers. The $rename operator (introduced a month after this question was posted) makes it really easy to do these kinds of things where you don’t need to modify the values.</p>
<p><strong>Insert some test documents</strong></p>
<pre><code>db.events.insert({ ‘lat’: 1, ‘lon’: 2, someotherdata: [] })
db.events.insert({ ‘lat’: 4, ‘lon’: 1, someotherdata: [] })
</code></pre>
<p><strong>use the $rename operator</strong></p>
<pre><code>db.events.update({}, {$rename: {‘lat’: ‘coords.lat’, ‘lon’: ‘coords.lon’}}, false, true)
</code></pre>
<p><strong>Results</strong></p>
<pre><code>Skip code block
db.events.find()
{
“_id” : ObjectId(“5113c82dd28c4e8b79971add”),
“coords” : {
“lat” : 1,
“lon” : 2
},
“someotherdata” : [ ]
}
{
“_id” : ObjectId(“5113c82ed28c4e8b79971ade”),
“coords” : {
“lat” : 4,
“lon” : 1
},
“someotherdata” : [ ]
}
</code></pre>
<p><strong>Update</strong>: If all you have to do is change the structure of a document without changing the values, see gipset’s answer for a nice solution.<br>
According to a (now unavailable) comment on the Update documentation page, you cannot reference the current document’s properties from within an update().<br>
You’ll have to iterate through all the documents and update them like this:</p>
<pre><code>Skip code block
db.events.find().snapshot().forEach(
function (e) {
// update document, using its own properties
e.coords = { lat: e.lat, lon: e.lon };
// remove old properties
delete e.lat;
delete e.lon;
// save the updated document
db.events.save(e);
}
)
</code></pre>
<p>Such a function can also be used in a map-reduce job or a server-side db.eval() job, depending on your needs.</p>
</div><hr><h3><p>In MongoDB how do you use $set to update a nested value?</p>
</h3><div><ul>
<li>In MongoDB how do you use $set to update a nested value?</li>
</ul>
<p>Using the dot notation:</p>
<pre><code>db.people.update({ }, { $set: { “address.street”: “Main Street” } })
</code></pre>
</div><hr><h3><p>Mongorestore of a db causing me trouble</p>
</h3><div><ul>
<li>I’m new to MongoDB and I have hard time to backup my local DB and restore it on my server. I found the link on Mongo’s website:</li>
</ul>
<p>https://www.mongodb.org/display/DOCS/Import+Export+Tools&nbsp;but I still have problems with the restore.</p>
<p>When I do my backup I call<br>
mongodump –db Gen<br>
Then I see that all the collections are dump in /bin/dump/Gen folder<br>
I copy-paste from local to the server in the same folder the call<br>
mongorestore –db Gen –drop –dbpath dump/Gen<br>
But I get the following : Error : root directory must be a dump of a single database when specifying a db name with –db<br>
What am I doing wrong?<br>
Thanks for the help!<br>
Ok I find out what I’m doing wrong :<br>
I was doing<br>
mongorestore –db Gen –drop –dbpath dump/Gen<br>
But without the –dbpath it works just fine!<br>
mongorestore –db Gen –drop dump/Gen<br>
Thanks everyone!</p>
<h2>MongoDB advanced interview questions and answers</h2>
</div><hr><h3><p>How to create user accounts in MongoDB?</p>
</h3><div><ul>
<li>I wonder what’s ‘correct’ way to create user accounts in MongoDB and actions like register/login. Do I have to create a specific collection for users (Username,Email,Password) or MongoDB has something built-in already for users?</li>
</ul>
<p>If I have to create users collection manually, how to deal with password encryption? Thanks.</p>
<p>You’ll probably have to create and manage the collection of users manually.</p>
<p>As for encrypting passwords, the common approach is to hash the passwords using a suitable hash-function before you store them in the db. Later, when a user tries to login you use the same hash-function on the string they entered in the password field and compare that result to the password entry in your db. That way you never store the actual passwords and if someone hacks you they won’t get your users passwords, just their hashes.</p>
<p>For extra security (against dictionary attacks) you should also salt the hashed passwords. Read about it here</p>
</div><hr><h3><p>How update the _id of one MongoDB Document?</p>
</h3><div><ul>
<li>
<p>want update an _id MongoDB of one document. I know it’s not a really good pratice. But with some technical reason, I need update it. But If I try to update it I have :</p>
<blockquote>
<p>db.clients.update({‘_id’:ObjectId(“4cc45467c55f4d2d2a000002”)}, {‘$set’:{‘_id’:ObjectId(“4c8a331bda76c559ef000004”)}});</p>
</blockquote>
</li>
</ul>
<p>Mod on _id not allowed<br>
And the update is not made. How I can really update it ?<br>
You cannot update it. You’ll have to save the document using a new _id, and then remove the old document.</p>
<p>Skip code block</p>
<pre><code>// store the document in a variable
doc = db.clients.findOne({_id: ObjectId(“4cc45467c55f4d2d2a000002”)})
// set a new _id on the document
doc._id = ObjectId(“4c8a331bda76c559ef000004”)
// insert the document, using the new _id
db.clients.insert(doc)
// remove the document with the old _id
db.clients.remove({_id: ObjectId(“4cc45467c55f4d2d2a000002”)})
To do it for your whole collection you can also use a loop (based on Niels example):
db.status.find().forEach(function(doc){ var id=doc._id; doc._id=doc.UserId; db.status.insert(doc); db.status.remove({_id:id}); })
</code></pre>
<p>In this case UserId was the new ID I wanted to use</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-query-and-examples">MongoDB Query &amp; Examples</a></strong></p>
</div><hr><h3><p>Get MongoDB Databases in a Javascript Array?</p>
</h3><div><p>I know that in the MongoDB terminal, I can run “show dbs” to see the available databases. I want to get them programmatically so that I can iterate over them and delete some based upon a regular expression.<br>
I have tried db.runCommand(“show dbs”) but that doesn’t work.<br>
Thanks in advance.</p>
<pre><code>&gt; db.getMongo().getDBNames()
[
“test”,
“admin”,
“local”
]
&gt; db.getMongo().getDBNames
function () {
return this.getDBs().databases.map(function (z) {return z.name;});
}
</code></pre>
<p>Based upon this answer</p>
<p>I was able to code up a solution.</p>
<pre><code>use admin

dbs = db.runCommand({listDatabases: 1})
dbNames = []
for (var i in dbs.databases) { dbNames.push(dbs.databases[i].name) }
Hopefully this will help someone else.
The below will create an array of the names of the database:
var connection = new Mongo();
var dbNames = connection.getDBNames();
</code></pre>
</div><hr><h3><p>MongoDB and “joins”</p>
</h3><div><ul>
<li>I’m sure MongoDB doesn’t officially support “joins”. What does this mean? Does this mean “We cannot connect two collections(tables) together.”?<br>
I think if we put the value for _id in collection A to the other_id in collection B, can we simply connect two collections?<br>
If my understanding is correct, MongoDB can connect two tables together, say, when we run a query. This is done by “Reference” written in</li>
</ul>
<p><a href="https://www.mongodb.org/display/DOCS/Schema+Design">https://www.mongodb.org/display/DOCS/Schema+Design</a>.</p>
<p>Then what does “joins” really mean?<br>
I’d love to know the answer because this is essential to learn MongoDB schema design.</p>
<p><a href="https://www.mongodb.org/display/DOCS/Schema+Design">https://www.mongodb.org/display/DOCS/Schema+Design</a></p>
<p>It’s no join since the relationship will only be evaluated when needed. A join (in a SQL database) on the other hand will resolve relationships and return them as if they were a single table (you “join two tables into one”). You can read more about DBRef here:</p>
<p><a href="https://docs.mongodb.org/manual/applications/database-references/">https://docs.mongodb.org/manual/applications/database-references/</a></p>
<p>There are two possible solutions for resolving references. One is to do it manually, as you have almost described. Just save a document’s _id in another document’s other_id, then write your own function to resolve the relationship. The other solution is to use DBRefs as described on the manual page above, which will make MongoDB resolve the relationship client-side on demand. Which solution you choose does not matter so much because both methods will resolve the relationship client-side (note that a SQL database resolves joins on the server-side).</p>
<p>The database does not do joins — or automatic “linking” between documents. However you can do it yourself client side. If you need to do 2, that is ok, but if you had to do 2000, the number of client/server turnarounds would make the operation slow.</p>
<p>In MongoDB a common pattern is embedding. In relational when normalizing things get broken into parts. Often in mongo these pieces end up being a single document, so no join is needed anyway. But when one is needed, one does it client-side.</p>
<p>Consider the classic ORDER, ORDER-LINEITEM example. One order and 8 line items are 9 rows in relational; in MongoDB we would typically just model this as a single BSON document which is an order with an array of embedded line items. So in that case, the join issue does not arise. However the order would have a CUSTOMER which probably is a separate collection – the client could read the cust_id from the order document, and then go fetch it as needed separately.</p>
<p>There are some videos and slides for schema design talks on the mongodb.org web site I belive.</p>
<p>The first example you link to shows how MongoDB references behave much like lazy loading not like a join. There isn’t a query there that’s happening on both collections, rather you query one and then you lookup items from another collection by reference.</p>
<h3>Mongo interface</h3>
</div><hr><h3><p>What are some GUIs to use with Mongo, and what features do they offer? I’m looking for facts here, not opinions on which interface is best.</p>
</h3><div><ul>
<li></li>
</ul>
<p><strong>Official List from MongoDB</strong></p>
<p><a href="https://docs.mongodb.com/ecosystem/">https://docs.mongodb.com/ecosystem/</a></p>
<p><strong>Web Based</strong></p>
<p>For PHP, I’d recommend Rock Mongo. Solid, lots of great features, easy setup.</p>
<p><a href="https://github.com/iwind/rockmongo">https://github.com/iwind/rockmongo</a></p>
<p>If you don’t want to install anything … you can use MongoHQ’s web interface (even if your MongoDB isn’t on MongoHQ - which is now named as Compose.)</p>
<p><a href="https://www.compose.com/">https://www.compose.com/</a></p>
<p><strong>Mac OS X</strong></p>
<p>While MongoHub had been a decent option for a while it’s bugs make it virtually unusable at this point …<br>
There is a more up-to-date (and less buggy) fork of the MongoHub project available:</p>
<p>https://github.com/fotonauts/MongoHub-Mac you can download a binary here.</p>
<p><strong>Windows</strong></p>
<p>By far, the best UI (for Windows) currently out there is MongoVUE.</p>
<p><a href="https://blog.mongovue.com/">https://blog.mongovue.com/</a></p>
<p>Looks great, lots of features, and if you are new it will really help you get going.</p>
<p><a href="https://blog.mongovue.com/features/">https://blog.mongovue.com/features/</a></p>
<p>Here’s a Q&amp;A with the author too if you are interested</p>
<p>On Mac there is MongoHub. On Windows you could try MongoVUE.<br>
Also see Do any visual tools exist for MongoDB (for Windows)?<br>
Screenshot of MongoHub:<br>
Here’s the official page of Admin UIs.<br>
I have not really used any of them. But it looks like there is quite a bit of coverage there.</p>
<p><strong>Web</strong></p>
<p>At the shop where I work we use the Prudence platform for some stuff, and also MongoDB, so we of course use MongoVision a lot. Browser based, tabbed collection views, pretty-printed document editor, and three themes OOB. Open source.</p>
<p><a href="https://code.google.com/p/mongo-vision/">https://code.google.com/p/mongo-vision/</a></p>
<p><strong>OS X</strong></p>
<p>MongoHub was as reliable as MongoVision.</p>
<p>https://mongohub.todayclose.com/</p>
</div><hr><h3><p>Why not MongoDB?</p>
</h3><div><ul>
<li>I recently used MongoDB for the first time and found it exceptionally easy to use and high-performing. Which leads to my question – why not MongoDB?<br>
Lets say I am implementing a Q &amp; A app. My approach would be to implement the User data in a MySQL database and then use MongoDB for the question and answer storage – one collection storing a question and all responses.</li>
</ul>
</div><hr><h3><p>Is there anything wrong with this approach?</p>
</h3><div><ul>
<li>MongoDB sounds like a fine application for your problem, but there are plenty of reasons why you would not use it.</li>
</ul>
<p>MongoDB would not be well suited for applications that need:</p>
<ol>
<li>Multi-Object Transactions: MongoDB only supports ACID transactions for a single document.</li>
<li>SQL: SQL is well-known and a lot of people know how to write very complex queries to do lots of things. This knowledge is transferrable across a lot of implementations where MongoDB’s queries language are specific to it.</li>
<li>Strong ACID guarantees: MongoDB allows for things like inconsistent reads which is fine in some applications, but not in all.</li>
<li>Traditional BI: A lot of very powerful tools exist that allow for OLAP and other strong BI applications and those run against traditional SQL database.</li>
</ol>
<p><strong>Possible downsides:</strong></p>
<p><strong>Ans:</strong></p>
<ol>
<li>You work in an organization that has only used SQL relational databases. You have no approval or support for using a NoSQL database yet.</li>
<li>You’ve never administered a MongoDB cluster; there’s a learning curve, as with all technologies.</li>
<li>Your data is really relational (e.g., one User has many Questions; a Question has many Answers), and you’ve overlooked the possibility.</li>
</ol>
<p>MondoDB is a fine solution, a good alternative for those situations where it applies. If you can use it, why not?<br>
MongoDB is a brilliant database and I enjoy using it. That said, it has a few gotchas if you come from the world of SQL.<br>
Apart from ACID and other things that are well documented (and in other answers too), these things have caught us by surprise:</p>
<p>1. MongoDB expects you to have memory. <strong>Lots of memory.</strong> If you can’t fit your working set in memory, you can forget about it. This is different from most relational DBs which use memory only as cache! <strong>To be more specific:</strong> MongoDB uses RAM as primary storage and “swaps” the unneeded parts out to disk (Mongo leaves the decision over which parts get “swapped” to kernel). Traditional RDBMS work the other way around – they use disk as primary storage and use RAM as caching mechanism. So in general MongoDB uses more RAM. This is not a bad thing by itself, but as a consequence “real” RAM consumption is difficult to predict, which can lead to serious and unexpected degradation of performance once the working set grows over the (hard to predict) limit.</p>
<p>2. <strong>Storage does not auto-shrink</strong> when you remove records. The space that is allocated per collection stays allocated until you either repair DB or drop the collection. And it is allocated in huge chunks on a DB level (data files), which are then allocated to collections when needed (extents). That said, inside the collection’s allocated space the documents that are removed DO release their space for other documents in the same collection. This is a good explanation of concepts: <a href="https://www.10gen.com/presentations/storage-engine-internals">https://www.10gen.com/presentations/storage-engine-internals</a></p>
<p>3. As a contrast to SQL which is parsed server-side, in Mongo you pass the data structures to query and CRUD functions. The consequence is that <strong>each driver provides a different syntax</strong>, which is a bit annoying. For instance, PyMongo uses a list of tuples instead of a dictionary (probably because dict in Python does not preserve order of keys) to specify which fields will be returned byfind(): (to be fair, that was probably the only sane way to do it – but it is a consequence of not using string-based language such as SQL)<br>
a. &nbsp; MongoDB shell: db.test.find({}, {a:1})<br>
b.&nbsp; &nbsp;PyMongo: db.find({}, fields=[(a,1,)]</p>
<p>This should not be viewed as a criticism of MongoDB – I enjoy using it and it has proven to be a reliable and performant tool. But to use it properly you need to learn about its space management.</p>
</div><hr><h3><p>Track MongoDB performance?</p>
</h3><div><ul>
<li>Is there a way to track ‘query’ performance in MongoDB? Specially testing indexes or subdocuments?<br>
In sql you can run queries, see execution time and other analytic metrics.<br>
I have a huge mongoDB collection and want to try different variations and indexes, not sure how to test it, would be nice to see how long did it take to find a record.. (I am new in MongoDB). Thanks</li>
</ul>
<p>There are two things here that you’ll likely be familiar with.<br>
1. Explain plans<br>
2. Slow Logs</p>
<p><strong>Explain Plans</strong></p>
<p>Here are some basic docs on explain. Running explain is as simple asdb.foo.find(query).explain(). (note that this actually runs the query, so if your query is slow this will be too)<br>
To understand the output, you’ll want to check some of the docs on the slow logs below. You’re basically given details about “how much index was scanned”, “how many are found”, etc. As is the case with such performance details, interpretation is really up to you. Read the docs above and below to point you in the right direction.</p>
<p><strong>Slow Logs</strong></p>
<p>By default, slow logs are active with a threshold of 100ms. Here’s a link to the full documentation on profiling. A couple of key points to get you started:<br>
Get/Set profiling:</p>
<pre><code>db.setProfilingLevel(2); // 0 =&gt; none, 1 =&gt; slow, 2 =&gt; all
db.getProfilingLevel();
See slow queries:
db.system.profile.find()
</code></pre>
</div><hr><h3><p>Mongodb can’t start</p>
</h3><div><ul>
<li>
<p>today I updated my Mongo.. mongodb-stable (from 10gen repo)<br>
but my service has down. the following command not working</p>
<p>$ sudo service mongodb start
$ start: Unknown job: mongodb</p>
</li>
</ul>
<p>even this command not working</p>
<pre><code>$ sudo /etc/init.d/mongodb start
$ Rather than invoking init scripts through /etc/init.d, use the service(8)
utility, e.g. service mongodb start
</code></pre>
<p>Since the script you are attempting to invoke has been converted to an<br>
Upstart job, you may also use the start(8) utility, e.g. start mongodb<br>
start: Unknown job: mongodb<br>
there is no mongo process running</p>
<pre><code>$ ps -ef|grep mongo
$ user  9689  8121  0 13:01 pts/1    00:00:00 grep –color=auto mongo
</code></pre>
<p>log is here<br>
Skip code block</p>
<pre><code>tail /var/log/mongodb/mongodb.log
Fri Dec 10 11:24:35 [conn4] end connection 127.0.0.1:54217
Fri Dec 10 11:25:35 [initandlisten] connection accepted from 127.0.0.1:54229 #5
Fri Dec 10 11:26:25 [initandlisten] connection accepted from 127.0.0.1:54243 #6
Fri Dec 10 11:26:30 [conn6] end connection 127.0.0.1:54243
Fri Dec 10 11:30:13 got kill or ctrl c or hup signal 15 (Terminated), will terminate after current cmd ends
Fri Dec 10 11:30:13 [interruptThread] now exiting
Fri Dec 10 11:30:13 dbexit:
Fri Dec 10 11:30:13 [interruptThread] shutdown: going to close listening sockets…
Fri Dec 10 11:30:13 [interruptThread] closing listening socket: 5
Fri Dec 10 11:30:13 [interruptThread] closing listening socket: 6
Fri Dec 10 11:30:13 [interruptThread] closing listening socket: 7
Fri Dec 10 11:30:13 [interruptThread] closing listening socket: 8
Fri Dec 10 11:30:13 [interruptThread] shutdown: going to flush oplog…
Fri Dec 10 11:30:13 [interruptThread] shutdown: going to close sockets…
Fri Dec 10 11:30:13 [interruptThread] shutdown: waiting for fs preallocator…
Fri Dec 10 11:30:13 [interruptThread] shutdown: closing all files…
Fri Dec 10 11:30:13     closeAllFiles() finished
Fri Dec 10 11:30:13 [interruptThread] shutdown: removing fs lock…
Fri Dec 10 11:30:13 dbexit: really exiting now
for now, I’m running Mongo through this command just for a while, creating process manually
$ sudo mongod -f /etc/mongodb.conf
</code></pre>
<p>any idea? or has anyone updated Mongo-stable via Update manager?</p>
<p><strong>Edits</strong>:</p>
<p>This mongodb version was v1.6.5 and it seems mongo team released it as stable with a bug. And they fixed it immediately at v1.7.4. You can see the major priority issue.<br>
Bug has been reported and fixed.</p>
<pre><code>https://jira.mongodb.org/browse/SERVER-2200
$ sudo apt-get purge mongodb-stable
$ sudo apt-get install mongodb-stable
(remove the lock file if present in /var/lib/mongodb)
$ sudo init 6
Then edit /etc/init/mongodb.conf removing the line “limit nofile 20000”
$ sudo vi /etc/init/mongodb.conf
$ sudo service mongodb start
mongodb start/running, process 2351
Worked.
</code></pre>
<p>Running <strong>Ubuntu 11.10</strong> confirm you have the latest version of MongoDB:</p>
<pre><code>$ mongod –version
db version v2.2.0
</code></pre>
<p>(If you don’t have the latest version of MongoDB, follow the <strong>Ubuntu Installation instructions</strong> at</p>
<p>First confirm that the <strong>mongodb</strong> user/group has permission to write to the data directory:</p>
<pre><code>$ sudo chown -R mongodb:mongodb /var/lib/mongodb/.
Start up MongoDB as a Daemon (background process) using the following command:
$ mongod –fork –dbpath /var/lib/mongodb/ –smallfiles –logpath /var/log/mongodb.log –logappend
</code></pre>
<p>To Shut Down MongoDB enter the Mongo CLI, access the admin and issue the shutdown command:</p>
<pre><code>$ ./mongo
&gt; use admin
&gt; db.shutdownServer()
</code></pre>
<p>See: https://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo</p>
</div><hr><h3><p>MongoDB: Unique Key in Embedded Document</p>
</h3><div><ul>
<li>
<p>Is it possible to set a unique key for a key in an embedded document?<br>
I have a Users collection with the following sample documents:</p>
<p>Skip code block
{
Name: “Bob”,
Items: [
{
Name: “Milk”
},
{
Name: “Bread”
}
]
},
{
Name: “Jim”
},</p>
</li>
</ul>
<p>Is there a way to create an index on the property Items.Name?<br>
I got the following error when I tried to create an index:</p>
<pre><code>&gt; db.Users.ensureIndex({“Items.Name”: 1}, {unique:true});
</code></pre>
<p>E11000 duplicate key error index: GroceryGuruApp.Users.$Items.Name_1 &nbsp;dup key: {<br>
: null }<br>
Any suggestions? Thank you!</p>
<p>Unique indexes exist only across collection. To enforce uniqueness and other constraints across document you must do it in client code. (Probably virtual collections would allow that, you could vote for it.)</p>
<p>What are you trying to do in your case is to create index on key Items.Name which doesn’t exist in any of the documents (it doesn’t refer to embedded documents inside array Items), thus it’s null and violates unique constraint across collection.</p>
<p>The index will be across all Users and since you asked it for ‘unique’, no user will be able to have two of the same named item AND no two users will be able to have the same named Item.<br>
Is that what you want?</p>
<p>Furthermore, it appears that it’s objecting to two Users having a ‘null’ value for Items.Name, clearly Jim does, is there another record like that?<br>
It would be unusual to require uniqueness on an indexed collection like this.</p>
<p>MongoDB does allow unique indexes where it indexes only the first of each value, see https://www.mongodb.org/display/DOCS/Indexes#Indexes-DuplicateValues, but I suspect the real solution is to not require uniqueness in this case.</p>
<p>If you want to ensure uniqueness only within the Items for a single user you might want to try the $addToSet option. See</p>
<p><a href="https://www.mongodb.org/display/DOCS/Updating#Updating-%24addToSet">https://www.mongodb.org/display/DOCS/Updating#Updating-%24addToSet</a></p>
<p>You can create a <strong>unique compound sparse index</strong> to accomplish something like what you are hoping for. It may not be the best option (client side still might be better), but it can do what you’re asking depending on specific requirements.</p>
<p>To do it, you’ll need to create another field on the same level as Name: Bob that is unique to each top-level record (could do FirstName + LastName + Address, we’ll call this key Identifier).</p>
<p>Then create an index like this:</p>
<pre><code>ensureIndex({‘Identifier’:1, ‘Items.name’:1},{‘unique’:1, ‘sparse’:1})
</code></pre>
<p>A sparse index will ignore items that don’t have the field, so that should get around your NULL key issue. Combining your unique Identifier and Items.name as a compound unique index should ensure that you can’t have the same item name twice per person.</p>
<p>Although I should add that I’ve only been working with Mongo for a couple of months and my science could be off. This is not based on empirical evidence but rather observed behaviour.</p>
<p><strong>More on MongoDB Indexes</strong><br>
1. Compound Keys Indexes<br>
2. Sparse Indexes</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-vs-elasticsearch">MongoDB Vs Elasticsearch Comparison</a></strong></p>
</div><hr><h3><p>Creating a database in Mongo: can’t connect, get “connect failed”</p>
</h3><div><ul>
<li>
<p>I want to create a new database in Mongo. However, I’m having trouble connecting:</p>
<p>:~$ mongo
MongoDB shell version: 1.6.5
connecting to: test
Tue Dec 21 18:16:25 Error: couldn’t connect to server 127.0.0.1 (anon):1154
exception: connect failed</p>
</li>
</ul>
<p>How can I connect to mongo in order to create a new database? Alternatively, can I create a new database from the command line?<br>
Slightly surprisingly, the Mongo docs don’t seem to cover how to create a database.<br>
Thanks.</p>
<p>In order to open Mongo JavaScript shell, a Listener should be initialized first.<br>
So, first run mongod.exe before running mongo.exe. Both are in the same location(/bin).</p>
<p>There is no separate commands to create a db in mongodb. Just type “use dbname;” in console. Now you have created a db of the name ‘dbname’. Now, if you type ‘show databases’ you cannot see the db name you just created. Because, mongo will not create any db, util you create collection and insert a document into that collection.<br>
Hope this is useful to you!</p>
<ol>
<li>cd /var/lib/mongodb/</li>
<li>Remove mongod.lock file from this folder</li>
<li>Sudo start mongodb (in console)</li>
<li>Mongo (in console)</li>
</ol>
<p>And it runs fine. First you’ll need to run mongod on one terminal. Then fire up another terminal and type mongo. This shall open the mongo shell. You also need to create /data/db/ where mongo will store your databases.</p>
</div><hr><h3><p>How can I use MongoDB to find all documents which have a field, regardless of the value of that field?</p>
</h3><div><p>For example, I have collection with documents, where documents can have field “url” (but most of them doesn’t). How can I find all documents, which have field “url” (regardless of value of this field)? To find if a key/field exists in your document use the $exists operator.<br>
Via the MongoDB shell …</p>
<pre><code>&gt; db.things.find( { url : { $exists : true } } );
</code></pre>
</div><hr><h3><p>Mongodb Query To select records having a given key</p>
</h3><div><ul>
<li>
<p>let the records in database are</p>
<p>{“_id”:”1?,”fn”:”sagar”,”ln”:”Varpe”}
{“_id”:”1?,”fn”:”sag”,”score”:”10?}
{“_id”:”1?,”ln”:”ln1?,” score”:”10?}
{“_id”:”1?,”ln”:”ln2?}</p>
</li>
</ul>
<p>I need to design a MongoDB query to find all records who has a given key<br>
like if i pass “ln” as a parameter to query it shold return all records in which “ln”is a Key , the results fo are</p>
<pre><code>{“_id”:”1?,”fn”:”sagar”,”ln”:”Varpe”}
{“_id”:”1?,”ln”:”ln1?,”score”:”10?}
{“_id”:”1?,”ln”:”ln2?}
</code></pre>
<p>To find if a key/field exists in your document use the $exists operator.<br>
Via the MongoDB shell …</p>
<pre><code>db.things.find( { ln : { $exists : true } } );
</code></pre>
<p>Possible duplicate of this question: MongoDB queries</p>
</div><hr><h3><p>“Field name duplication not allowed with modifiers” on update</p>
</h3><div><ul>
<li>
<p>I get a “Field name duplication not allowed with modifiers” error while trying to update a field(s) in Mongo. An example:</p>
<blockquote>
<p>db.test.insert({test: “test1”, array: [0]});
var testFetch = db.test.findOne({test: “test1”});
db.test.update(testFetch,
{$push: {array: 1}, //push element to end of key “array”
$pop:  {array: -1} //pop element from the start of key “array”
});</p>
</blockquote>
</li>
</ul>
<p>Field name duplication not allowed with modifiers<br>
Is there no way to perform this atomic operation? I don’t want to be doing two separate updates for this.<br>
There’s an outstanding issue for this on Mongo’s ticket system: https://jira.mongodb.org/browse/SERVER-1050<br>
Looks like it’s scheduled for this year. Your scenario is definitely a sensible scenario, but it’s also tied to a bunch of edge cases. What if you $push and $pop on an empty array? What’s expected? What do you want if you $push and $pull?<br>
I don’t want to be doing two separate updates for this.<br>
I know that doing this really has “code smell”, but is it a complete blocker for using this solution? Is the “double-update” going to completely destroy server performance?</p>
</div><hr><h3><p>In mongoDb, how do you remove an array element by its index</p>
</h3><div><ul>
<li></li>
</ul>
<pre><code>Skip code block
{
“_id” : ObjectId(“4d1cb5de451600000000497a”),
“name” : “dannie”,
“interests” : [
“guitar”,
“programming”,
“gadgets”,
“reading”
]
}
</code></pre>
<p>In the example above, assume the above document is in the <strong>db.people</strong> collection. How to remove the 3rd element of the <strong>interests</strong> array by it’s <strong>index</strong>?</p>
<p>Edit:<br>
This is my current solution:</p>
<pre><code>var interests = db.people.findOne({“name”:”dannie”}).interests;
interests.splice(2,1)
db.people.update({“name”:”dannie”}, {“$set” : {“interests” : interests}});
</code></pre>
<p>Is there a more direct way?</p>
<p>There is no straight way of pulling/removing by array index. In fact, this is an opened issue</p>
<p><a href="https://jira.mongodb.org/browse/SERVER-1014,">https://jira.mongodb.org/browse/SERVER-1014,</a></p>
<p>you may vote for it.</p>
<pre><code>The workaround is using $unset and then $pull:
db.lists.update({}, {$unset : {“interests.3” : 1 }})
db.lists.update({}, {$pull : {“interests” : null}})
</code></pre>
<p>Update: as mentioned in some of the comments this approach is not atomic and can cause some race conditions if other clients read and/or write between the two operations. If we need the operation to be atomic, we could:</p>
<ol>
<li>Read the document from the database</li>
<li>Update the document and remove the item in the array</li>
<li>Replace the document in the database. To ensure the document has not changed since we read it, we can use the update if current pattern describedin the mongo docs.</li>
</ol>
<p>You can use $pull modifier of update operation for removing a particular element in an array. In case you provided a query will look like this:<br>
db.people.update({“name”:”dannie”}, {‘$pull’: {“interests”: “guitar”}})</p>
<p>Also, you may consider using $pullAll for removing all occurrences. More about this on the official documentation page –</p>
<p><a href="https://www.mongodb.org/display/DOCS/Updating#Updating-%24pull">https://www.mongodb.org/display/DOCS/Updating#Updating-%24pull</a></p>
<p>This doesn’t use index as a criteria for removing an element, but still might help in cases similar to yours. IMO, using indexes for addressing elements inside an array is not very reliable since mongodb isn’t consistent on an elements order as fas as I know.</p>
</div><hr><h3><p>MongoDB custom and unique IDs</p>
</h3><div><ul>
<li></li>
</ul>
<p>I’m using MongoDB, and I would like to generate unique and cryptical IDs for blog posts (that will be used in restful URLS) such as s52ruf6wst or xR2ru286zjI.</p>
<p>What do you think is best and the more scalable way to generate these IDs?</p>
<p>I was thinking of following architecture :</p>
<p>A periodic (daily?) batch running to generate a lot of random and uniques IDs and insert them in a dedicated MongoDB collection with InsertIfNotPresent</p>
<p>And each time I want to generate a new blog post, I take an ID from this collection and mark it as “taken” with UpdateIfCurrent atomic operation WDYT? This is exactly why the developers of MongoDB constructed their ObjectID’s (the _id) the way they did … to scale across nodes, etc.</p>
<p>A BSON ObjectID is a 12-byte value consisting of a 4-byte timestamp (seconds since epoch), a 3-byte machine id, a 2-byte process id, and a 3-byte counter. Note that the timestamp and counter fields must be stored big endian unlike the rest of BSON. This is because they are compared byte-by-byte and we want to ensure a mostly increasing order. Here’s the schema:</p>
<p>0123 &nbsp; 456 &nbsp; &nbsp; &nbsp;78 &nbsp; &nbsp;91011</p>
<p>time &nbsp; machine &nbsp;pid &nbsp; inc<br>
Traditional databases often use monotonically increasing sequence numbers for primary keys. In MongoDB, the preferred approach is to use Object IDs instead. Object IDs are more synergistic with sharding and distribution.</p>
<p><a href="https://www.mongodb.org/display/DOCS/Object+IDs">https://www.mongodb.org/display/DOCS/Object+IDs</a></p>
<p>So I’d say just use the ObjectID’s</p>
<p>They are not that bad when converted to a string (these were inserted right after each other) …</p>
<p>For example:</p>
<p>4d128b6ea794fc13a8000001<br>
4d128e88a794fc13a8000002</p>
<p>They look at first glance to be “guessable” but they really aren’t that easy to guess …</p>
<p>4d128 b6e a794fc13a8000001<br>
4d128 e88 a794fc13a8000002</p>
<p>And for a blog, I don’t think it’s that big of a deal … we use it production all over the place.<br>
What about using UUIDs?</p>
<p>https://www.famkruithof.net/uuid/uuidgen as an example.</p>
</div><hr><h3><p>MongoDB shell run() function</p>
</h3><div><ul>
<li>run(“/test.js”)</li>
</ul>
<p>in mongo shell. i always get error</p>
<p>run(“/test.js”) shell: started program /test.js sh2516| Unable to start program /test.js errno:13 Permission denied 255</p>
<p>for test i add 777 permission on this file i doesn’t have any passwords on DB<br>
test.js is empty</p>
<p>What am I doing wrong?</p>
<p>try using load() rather than run(). load is for javascript while run is for system binaries.</p>
</div><hr><h3><p>“system.” In a Collection Name in MongoDB</p>
</h3><div><ul>
<li>I just discovered a bizarre behavior exhibited by MongoDB.<br>
Apparently, any collection name with the string “system.” anywhere in it will just not function correctly.<br>
To make matters worse, it won’t even tell you anything is wrong!</li>
</ul>
<p>It’s really more a matter of curiosity, but does anybody have any idea why this would happen? Is it documented somewhere?<br>
My assumption is that it uses “”system.*” collections to store things internally (like indexes) and doesn’t want you messing with them, but this doesn’t seem like the correct behavior to me.<br>
You are correct “system.*” is a reserved collection namespace used by MongoDB in each DB.<br>
It is used to store indexes and users, etc.</p>
<p>SQL Server has many such tables too, and I don’t believe they warn you not to use them either :)<br>
But you could always put in a request for such functionality:</p>
<p><a href="https://jira.mongodb.org/">https://jira.mongodb.org/</a></p>
<p>You can see them by running …<br>
&gt; show collections<br>
and you’ll see something like …<br>
system.indexes<br>
system.users<br>
So, you can see your indexes for example:<br>
&gt; db.system.indexes.find()<br>
From the MongoDB docs:</p>
<p>The <strong>.system.</strong>* namespaces in MongoDB are special and contain database system information. System collections include:<br>
1. <strong>system.namespaces</strong> lists all namespaces.<br>
2. <strong>system.indexes</strong> lists all indexes.<br>
3. Additional namespace / index metadata exists in the database.ns files, and is opaque.<br>
4. <strong>system.profile</strong> stores database profiling information.<br>
5. <strong>system.users</strong> lists users who may access the database.<br>
6. <strong>local.sources</strong> stores replica slave configuration data and state.<br>
7. Information on the structure of a stored object is stored within the object itself. See BSON .</p>
<p>There are several restrictions on manipulation of objects in the system collections. Inserting in system.indexes adds an index, but otherwise that table is immutable (the special drop index command updates it for you). <strong>system.users</strong> is modifiable. <strong>system.profile</strong> is droppable.</p>
<p>https://docs.mongodb.org/manual/reference/system-collections/</p>
</div><hr><h3><p>MongoDB Shell – access collection with period in name?</p>
</h3><div><ul>
<li>I have found a collection in one of our MongoDB databases with the name my.collection.<br>
Is there a way to access this collection from the MongoDB shell, despite it having a point in the name?<br>
&gt; db.my.collection.findOne();<br>
null<br>
I’m pretty sure that that is not correct.<br>
try this instead:<br>
db[“my.collection”].findOne();</li>
</ul>
<p>you run into the same issue with hyphens or any other name that does not match on [a-zA-Z_$][0-9a-zA-Z_$]<br>
This limitation comes from valid named for javascript object properties.</p>
<p>if collection name is “my.collection”<br>
db.my.collection.findOne(); // OK<br>
null<br>
if collection name is “my.1.collection”<br>
db.my.1.collection.findOne(); // Not OK<br>
SyntaxError: missing ; before statement<br>
Fix:<br>
db[“my.1.collection”].findOne(); // Now is OK<br>
null</p>
</div><hr><h3><p>How do I insert a record from one mongo database into another?</p>
</h3><div><ul>
<li>
<p>As far as I see all commands operate on the same database in mongodb. I want to do something like this:<br>
db.mySourceCollection.find().forEach( function(x){ db.theDestinationCollection.save(x)} );<br>
where mySourceCollection is on liveDatabase and theDestinationCollection is ontestDatabase.<br>
Use use :-)</p>
<blockquote>
<p>var documents = db.mySourceCollection.find()
use testDatabase</p>
</blockquote>
</li>
</ul>
<p>switched to db testDatabase</p>
<pre><code>&gt; documents.forEach(function(x){ db.theDestinationCollection.insert(x) })
</code></pre>
<p>db is used to refer to the currently connected database, however you can switch databases on the fly using the use command, as I’ve shown above.<br>
Check out the help command in the shell — it mentions this command and much more!</p>
<p>use dbname doesn’t work in scripted mode (i.e. when scripting the shell with javascript), so you should use the db.getSiblingDB() method instead to reassign the ‘db’ variable, e.g.:<br>
db = db.getSiblingDB(“otherdb”)</p>
<p>More info here: https://www.mongodb.org/display/DOCS/Scripting+the+shell</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-vs-couchdb">MongoDB Vs. CouchDB</a></strong></p>
</div><hr><h3><p>find inside a hash mongodb</p>
</h3><div><ul>
<li>I have this struct in my collection:<br>
{foo : 1, bar : 4, baz : {a : 1, b : 2 ,c : “fafofu”}}<br>
How do I find “a” and “b” inside baz ? It does not works db.my_collection.find({baz : {a : 1, b : 2});<br>
I don’t care about if “c” is “fafofu” or “cacocu” does not matters.<br>
You can use . to reach into the baz object.<br>
db.my_collection.find({“baz.a” : 1, “baz.b” : 2});</li>
</ul>
</div><hr><h3><p>Query IDE for MongoDB?</p>
</h3><div><ul>
<li>I’m wondering if there is an IDE for MongoDB that allows you to run queries and see the results? This would behave like query analyzer in SQL Server Management Studio. The issue I’m having right now is that I have to do queries, such as “db.MyTable.find()” from command prompt, which isn’t a good solution.<br>
If the answer is no, is there a more mature “no sql” solution like MongoDB that does have an IDE?</li>
</ul>
<p><strong>Web Based</strong></p>
<p>For PHP, I’d recommend Rock Mongo. Solid, lots of great features, easy setup.</p>
<p><a href="https://code.google.com/p/rock-php/wiki/rock_mongo">https://code.google.com/p/rock-php/wiki/rock_mongo</a></p>
<p>If you don’t want to install anything … you can use MongoHQ’s web interface (even if you your MongoDB isn’t on MongoHQ.)</p>
<p><a href="https://mongohq.com/home">https://mongohq.com/home</a></p>
<p><strong>Windows</strong></p>
<p>By far, the best UI (for Windows) currently out there is MongoVUE.</p>
<p><a href="https://blog.mongovue.com/">https://blog.mongovue.com/</a></p>
<p>Looks great, lots of features, and if you are new it will really help you get going</p>
<p><a href="https://blog.mongovue.com/features/">https://blog.mongovue.com/features/</a></p>
<p>Here’s a Q&amp;A with the author too if you are interested</p>
<p>https://learnmongo.com/posts/qa-ishann-kumar-creator-of-mongovue/</p>
<p>There is an official list of admin tools here:</p>
<p><a href="https://www.mongodb.org/display/DOCS/Admin+UIs">https://www.mongodb.org/display/DOCS/Admin+UIs</a></p>
<p>Another contender : https://www.robomongo.org/ Robomongo give you a shell-like an interface but outputs your results in the GUI. Its available for windows, mac(dmg, zip) and linux (deb, rpm, tar.gz) as a desktop application. Currently its free!</p>
<p>Robomongo prints the results in a treeView or Json text representation and supports the generation of UUID (.NET-,Python-,Java-Encoding). It has autocomplete, shows multiple results at once and has a query history.</p>
</div><hr><h3><p>MongoDB: Geting “Client Cursor::yield can’t unlock b/c of recursive lock” warning when use findAndModify in two process instances</p>
</h3><div><ul>
<li>I’m using: MongoDB 1.6.4, Python 2.6.6, PyMongo 1.9, Ubuntu 10.10<br>
I’m getting “Client Cursor::yield can’t unlock b/c of recursive lock” warning in my logs very often when use findAndModify in two process instances. When i use only one process warning doesn’t appear.<br>
How can i fix this?<br>
*Update 8 March 2013 *<br>
Is there a fix to this problem as of now?<br>
this is usually means you are missing indexes on fields used in query.<br>
I don’t know tech details of this warning but from my experience adding index on the query field helps. check you have index on fields that used in query part of findAndModify. also run db.collection.find().explain() to check if it uses the index.<br>
Thanks to the pingw33n who help solve this question.</li>
</ul>
</div><hr><h3><p>how to query child objects in mongodb</p>
</h3><div><ul>
<li>I’m new to mongodb and am trying to query child objects. I have a collection of States, and each State has child Cities. One of the Cities has a Name property that is null, which is causing errors in my app. How would I query the State collections to find child Cities that have a name == null?</li>
</ul>
<p>If it is exactly null (as opposed to not set):</p>
<pre><code>db.states.find({“cities.name”: null})
</code></pre>
<p>(but as javierfp points out, it also matches documents that have no cities array at all, I’m assuming that they do).</p>
<p>If it’s the case that the property is not set:</p>
<pre><code>db.states.find({“cities.name”: {“$exists”: false}})
</code></pre>
<p>I’ve tested the above with a collection created with these two inserts:</p>
<pre><code>]db.states.insert({“cities”: [{name: “New York”}, {name: null}]})
db.states.insert({“cities”: [{name: “Austin”}, {color: “blue”}]})
</code></pre>
<p>The first query finds the first state, the second query findsthe second. If you want to find them both with one query you can make an $or query:</p>
<pre><code>db.states.find({“$or”: [
{“cities.name”: null},
{“cities.name”: {“$exists”: false}}
]})
Assuming your “states” collection is like:
{“name” : “Spain”, “cities” : [ { “name” : “Madrid” }, { “name” : null } ] }
{“name” : “France” }
The query to find states with null cities would be:
db.states.find({“cities.name” : {“$in” : [null], “$exists” : true}});
</code></pre>
<p>It is a common <strong>mistake</strong> to query for nulls as:</p>
<pre><code>db.states.find({“cities.name” : null});
</code></pre>
<p>because this query will return all documents lacking the key (in our example it will return Spain and France). So, unless you are sure the key is always present you must check that the key exists as in the first qeury.</p>
</div><hr><h3><p>MongoDB 1.6.5: how to rename field in collection</p>
</h3><div><ul>
<li>
<p>$rename function is available only in development version 1.7.2. How to rename field in 1.6.5?<br>
The simplest way to perform such an operation is to loop through the data set re-mapping the name of the field. The easiest way to do this is to write a function that performs the re-write and then use the .find().forEach() syntax in the shell.<br>
Here’s a sample from the shell:</p>
<p>Skip code block
db.foo.save({ a : 1, b : 2, c : 3});
db.foo.save({ a : 4, b : 5, c : 6});
db.foo.save({ a : 7, b : 8 });
db.foo.find();
remap = function (x) {
if (x.c){
db.foo.update({_id:x._id}, {$set:{d:x.c}, $unset:{c:1}});
}
}</p>
<p>db.foo.find().forEach(remap);
db.foo.find();</p>
</li>
</ul>
<p>In the case above I’m doing an $unset and a $set in the same action. MongoDB does not support transactions across collections, but the above is a single document. So you’re guaranteed that the set and unset will be atomic (i.e. they both succeed or they both fail).</p>
<p>The only limitation here is that you’ll need to manage outside writers to keep the data consistent. My normal preference for this is simply to turn off writes while this updates. If this option is not available, then you’ll have to figure out what level of consistency you want for the data. (I can provide some ideas here, but it’s really going to be specific to your data and system)<br>
db.collection_name.update({}, {$rename: {“oldname”: “newname”}}, false, true);</p>
<p>This will rename the column for each row in the collection.<br>
Also, I discovered that if your column (the one you’re renaming) appears within the index catalog (db.collection_name.getIndexes()), then you’re going to have to drop and recreate the index (using the new column name) also.</p>
</div><hr><h3><p>Is it normal size for MongoDB?</p>
</h3><div><ul>
<li>I just import my <strong>Mysql</strong> database (size 2,8 Mio) in my new <strong>Mongo</strong> database with very simple php script i build, import was ok without error but when i look my <strong>Mongo</strong> database (with RockMongo) i can see this : Data Size 8.01m, Storage Size 13.7m.</li>
</ul>
<p><strong>MongoDB</strong> is bigger than <strong>Mysql</strong> for the same amount of data, is this normal?<br>
Thanks for your help and sorry for my english.</p>
<p>Yes, it’s normal that the “same” data will take up more space in mongodb. There’s a few things you need to take into account:</p>
<ol>
<li>the document _id that’s stored for each document (unless you are specifying your own value for that) is 12 bytes per doc</li>
<li>you’re storing the key for each key-value pair in each document, whereas in MySql the column name is not stored for every single row so you have that extra overhead in your mongodb documents too. One way to reduce this is to use shortened key names (“column names”) in your docs</li>
<li>mongodb automatically adds padding to allow documents to grow<br>
In similar tests, loading data from SQL Server to MongoDB, with shortened 2 character document key names instead of the full names as per SQL Server, I see about 25-30% extra space being used in MongoDB.</li>
</ol>
</div><hr><h3><p>Maximum number of databases supported by MongoDB</p>
</h3><div><ul>
<li>I would like to create a database for each customer. But before, I would like to know how many databases can be created in a single instance of MongoDB ?<br>
There’s no explicit limit, but there are probably some implicit limits due to max number of open file handles / files in a directory on the host OS/filesystem.<br>
see: https://groups.google.com/group/mongodb-user/browse_thread/thread/01727e1af681985a?fwc=2</li>
</ul>
</div><hr><h3><p>Mongo $in operator performance</p>
</h3><div><ul>
<li>
<p>Is it slow / poor form to use the $in operator in MongoDB with a large array of possibilities?</p>
<p>posts.find({
author : {
$in : [‘friend1',’friend2',’friend3’….’friend40’]
}
})</p>
</li>
</ul>
<p>App Engine, for example, won’t let you use more than 30 because they translate directly to one query per item in the IN array, and so instead force you into using their method for handling fan out. While thats probably the most efficient method in Mongo too, the code for it is significantly more complex so I’d prefer to just use this generic method.<br>
Will Mongo execute these $in queries efficiently for reasonable-sized datasets?</p>
<p>It can be fairly efficient with small lists (hard to say what small is, but at least into the tens/hundreds) for $in. It does not work like app-engine since mongodb has actual btree indexes and isn’t a column store like bigtable.</p>
<p>With $in it will skip around in the index to find the matching documents, or walk through the whole collection if there isn’t an index to use.<br>
If you build an index (ensureIndex) on the list element, it should be pretty quick.</p>
<p>Have you tried using explain()? Its a good, built-in way to profile your queries: https://www.mongodb.org/display/DOCS/Indexing+Advice+and+FAQ#IndexingAdviceandFAQ-Use%7B%7Bexplain%7D%7D.</p>
</div><hr><h3><p>Mongo Query question $gt,$lt</p>
</h3><div><ul>
<li>
<p>I have a query below. I want get items between 4 and 6 so only a:1 should match because it has the value 5 in b.</p>
<blockquote>
<p>db.test.find({ b : { $gt :  4  }, b: {$lt : 6}});
{ “_id” : ObjectId(“4d54cff54364000000004331”), “a” : 1, “b” : [ 2, 3, 4, 5 ] }
{ “_id” : ObjectId(“4d54d0074364000000004332”), “a” : 2, “b” : [ 2, 4, 6, 8 ] }</p>
</blockquote>
</li>
</ul>
<p>Can someone tell be why a:2 is matching this query? I can’t really see why it is being returned.<br>
I also tried what was specified in the tutorial but id did not seem to work:</p>
<pre><code>&gt; db.test.find({ b : { $gt :  4, $lt : 6}});
{ “_id” : ObjectId(“4d54cff54364000000004331”), “a” : 1, “b” : [ 2, 3, 4, 5 ] }
{ “_id” : ObjectId(“4d54d0074364000000004332”), “a” : 2, “b” : [ 2, 4, 6, 8 ] }
&gt;
</code></pre>
<h4>Subscribe to our youtube channel to get new updates..!</h4>
<p>And this one to avoid any confusion regarding GT/GTE</p>
<pre><code>&gt; db.test.find({b: {$gt: 4.5, $lt: 5.5}});
{ “_id” : ObjectId(“4d54cff54364000000004331”), “a” : 1, “b” : [ 2, 3, 4, 5 ] }
{ “_id” : ObjectId(“4d54d0074364000000004332”), “a” : 2, “b” : [ 2, 4, 6, 8 ] }
&gt;
</code></pre>
<p>only a:1 should be returned.<br>
As suggested, I gave $elemMatch a try but it did not appear to work either (objectIds are different because I am on a different machine)</p>
<pre><code>&gt; db.test.find();
{ “_id” : ObjectId(“4d5a24a5e82e00000000433f”), “a” : 1, “b” : [ 2, 3, 4, 5 ] }
{ “_id” : ObjectId(“4d5a24bbe82e000000004340”), “a” : 2, “b” : [ 2, 4, 6, 8 ] }
&gt; db.test.find({b: {$elemMatch: {$gt : 4, $lt: 6 }}});
&gt;
</code></pre>
<p>No documents were returned.<br>
This is a really confusing topic. I work at 10gen and I had to spend a while wrapping my head around it<br>
Let’s walk through how the query engine processes this query.<br>
Here’s the query again:</p>
<pre><code>&gt; db.test.find({ b : { $gt :  4, $lt : 6}});
</code></pre>
<p>When it gets to the record that seems like it shouldn’t match…</p>
<pre><code>{ “_id” : ObjectId(“4d54cff54364000000004331”), “a” : 1, “b” : [ 2, 4, 6, 8 ] }
</code></pre>
<p>The match is not performed against each element of the array, but rather against the array as a whole.<br>
The comparison is performed in three steps:</p>
<p><strong>Step 1:</strong> Find all documents where b has a value greater than 4<br>
b: [2,4,6,8] matches because 6 &amp; 8 are greater than 4</p>
<p><strong>Step 2</strong>: Find all documents where b has a value less than 6<br>
b: [2,4,6,8] matches because 2 &amp; 4 are less than 6</p>
<p><strong>Step 3:</strong> Find the set of documents that matched in both step 1 &amp; 2.<br>
The document with b: [2,4,6,8] matched both steps 1 &amp; 2 so it is returned as a match. Note that results are also de-duplicated in this step, so the same document won’t be returned twice.</p>
<p>If you want your query to apply to the individual elements of the array, rather than the array as a whole, you can use the $elemMatch operator. For example</p>
<pre><code>&gt; db.temp.find({b: {$elemMatch: {$gt: 4, $lt: 5}}})
&gt; db.temp.find({b: {$elemMatch: {$gte: 4, $lt: 5}}})
{ “_id” : ObjectId(“4d558b6f4f0b1e2141b66660”), “b” : [ 2, 3, 4, 5, 6 ] }
</code></pre>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-show-collections">MongoDB Show Collections</a></strong></p>
</div><hr><h3><p>MongoDB: How to change the type of a field?</p>
</h3><div><ul>
<li>
<p>There is a question already in Stackoverflow, very similar with my question. The thing is that the answer for that questions was for a Java Driver, I am trying to do it in the shell.<br>
I am doing this…</p>
<p>db.meta.update({‘fields.properties.default’: { $type : 1 }}, {‘fields.properties.default’: { $type : 2 }})</p>
</li>
</ul>
<p>This is not working<br>
The only way to change the $type of the data is to perform an update on the data where the data has the correct type.</p>
<p>In this case, it looks like you’re trying to change the $type from 1 (double) to 2 (string).</p>
<p>https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24type</p>
<p>So simply load the document from the DB, perform the cast (new String(x)) and then save the document again.</p>
<p>If you need to do this programmatically and entirely from the shell, you can use thefind(…).forEach(function(x) {}) syntax.<br>
In response to the second comment below. Change the field bad from a number to a string in collection foo.</p>
<pre><code>db.foo.find( { ‘bad’ : { $type : 1 } } ).forEach( function (x) {
x.bad = new String(x.bad); // convert field to string
db.foo.save(x);
});
// String to Integer
db.db-name.find({field-name : {$exists : true}}).forEach( function(obj) { obj.field-name = new NumberInt( obj.field-name ); db.db-name.save(obj); } );
// Integer to String
db.db-name.find({field-name : {$exists : true}}).forEach( function(obj) { obj.field-name = “”+obj.field-name; db.db-name.save(obj); } );
This is what I used for string to int conversion.
db.my_collection.find().forEach( function(obj) {
obj.my_value= parseInt(obj.my_value);
db.my_collection.save(obj);
});
db.coll.find().forEach(function(data) {
db.coll.update({_id:data._id},{$set:{myfield:parseInt(data.myfield)}});
})
</code></pre>
</div><hr><h3><p>Many to many update in MongoDB without transactions</p>
</h3><div><ul>
<li>I have two collections with a many-to-many relationship. I want to store an array of linked ObjectIds in both documents so that I can take Document A and retrieve all linked Document B’s quickly, and vice versa.</li>
</ul>
<p>Creating this link is a two step process<br>
1. Add Document A’s ObjectId to Document B<br>
2. Add Document B’s ObjectId to Document A</p>
<p>After watching a MongoDB video I found this to be the recommended way of storing a many-to-many relationship between two collections<br>
I need to be sure that both updates are made. What is the recommended way of robustly dealing with this crucial two step process without a transaction?<br>
I could condense this relationship into a single link collection, the advantage being a single update with no chance of Document B missing the link to Document A. The disadvantage being that I’m not really using MongoDB as intended. But, because there is only a single update, it seems more robust to have a link collection that defines the many-to-many relationship.</p>
<p>Should I use safe mode and manually check the data went in afterwards and try again on failure? Or should I represent the many-to-many relationship in just one of the collections and rely on an index to make sure I can still quickly get the linked documents?<br>
Any recommendations? Thanks</p>
<p><strong>@Gareth</strong>, you have multiple legitimate ways to do this. So they key concern is how you plan to query for the data, (i.e.: what queries need to be fast)<br>
Here are a couple of methods.</p>
<p><strong>Method #1: the “links” collection</strong><br>
You could build a collection that simply contains mappings between the collections.</p>
<p>Pros:<br>
1. Supports atomic updates so that data is not lost</p>
<p>Cons:<br>
2. Extra query when trying to move between collections</p>
<p><strong>Method #2: store copies of smaller mappings in larger collection</strong></p>
<p>For example: you have millions of Products, but only a hundred Categories. Then you would store the Categories as an array inside each Product.</p>
<p>Pros:<br>
1. Smallest footprint<br>
2. Only need one update</p>
<p>Cons:<br>
1. Extra query if you go the “wrong way”</p>
<p><strong>Method #3: store copies of all mappings in both collections</strong><br>
(what you’re suggesting)<br>
Pros:<br>
1. Single query access to move between either collection<br>
Cons:<br>
1. Potentially large indexes<br>
2. Needs transactions (?)<br>
Let’s talk about “needs transactions”. There are several ways to do transactions and it really depends on what type of safety you require.<br>
Should I use safe mode and manually check the data went in afterwards and try again on failure?<br>
You can definitely do this. You’ll have to ask yourself, what’s the worst that happens if only one of the saves fails?</p>
<p><strong>Method #4: queue the change</strong></p>
<p>I don’t know if you’ve ever worked with queues, but if you have some leeway you can build a simple queue and have different jobs that update their respective collections.<br>
This is a much more advanced solution. I would tend to go with #2 or #3.</p>
</div><hr><h3><p>MongoDB log file growth</p>
</h3><div><ul>
<li>Currently my log file sits at 32 meg. Did I miss an option that would split the log file as it grows?<br>
Rotate the logs yourself</li>
</ul>
<p><a href="https://www.mongodb.org/display/DOCS/Logging">https://www.mongodb.org/display/DOCS/Logging</a></p>
<p>or use ‘logrotate’ with an appropriate configuration.<br>
You can use logrotate to do this job for you.<br>
Put this in /etc/logrotate.d/mongod (assuming you use Linux and have logrotated installed):<br>
Skip code block</p>
<pre><code>/var/log/mongo/*.log {
daily
rotate 30
compress
dateext
missingok
notifempty
sharedscripts
copytruncate
postrotate
/bin/kill -SIGUSR1 `cat /var/lib/mongo/mongod.lock 2&gt; /dev/null` 2&gt; /dev/null || true
endscript
}
</code></pre>
<p>If you think that 32 megs is too large for a log file, you may also want to look inside to what it contains.<br>
If the logs seem mostly harmless (“open connection”, “close connection”), then you may want to start mongod with the –quiet switch. This will reduce some of the more verbose logging.</p>
</div><hr><h3><p>MongoDB field order and document position change after update</p>
</h3><div><ul>
<li>
<p>I am learning MongoDB and I noticed that whenever I do an update on a document the field being updated is pushed to the end of the order, so if I had something like:</p>
<p>db.collection.save({field1: value1, field2: value2, …, field 10: value10});
db.collection.update({field1: value1}, {$set: {field2: new_value}});
then if you do:
db.collection.find();
it will display:
{ “field1?:”value1”, …, “field10?:”value10”, “field2?:”new_value”}</p>
</li>
</ul>
<p>You can see how the field order changes where the updated field is being pushed to the end of the document. In addition, the document itself is being pushed to the end of the collectoin. I know that it’s a “schema-less” DB and it may not be a huge problem, but it just doesn’t look “pretty” :). Is there a way to do an in-place update without changing the order?<br>
MongoDB allocates space for a new document based on a certain padding factor. If your update increases the size of the document beyond the size originally allocated the document will be moved to the end of the collection. The same concept applies to fields in a document.</p>
<p>Both document structure and collection structure in MongoDB based on JSON principles. JSON is a <strong>set</strong> of key/value pairs (in particular fieldName/fieldValue for document and index/document for collection). From this point of view it doesn’t seem that you can relay on order at all.</p>
<p>In the case of the documents if the field size changes, it writes out a new document with the fields sorted by field name. This behavior can be seen with the following statements<br>
Case 1: No change in size of field, so no change in field order</p>
<pre><code>db.testcol.find() 
db.testcol.save({a:1,c:3,b:2}) 
db.testcol.find()
 { “_id” : ObjectId(“4d5efc3bec5855af36834f5a”), “a” : 1, “c” : 3, “b” : 2 } 
db.testcol.update({a:1},{$set:{c:22}}) 
db.testcol.find() { “_id” : ObjectId(“4d5efc3bec5855af36834f5a”), “a” : 1, “c” : 22, “b” : 2 }
</code></pre>
<p>Case 2: Field size changes and the fields are reodered</p>
<pre><code>db.testcol.find() db.testcol.save({a:1,c:”foo”,b:2,d:4}) 
db.testcol.find()
{ “_id” : ObjectId(“4d5efdceec5855af36834f5e”), “a” : 1, “c” : “foo”, “b” : 2, “d” : 4 } 
db.testcol.update({a:1},{$set:{c:”foobar”}}) 
db.testcol.find() 
{ “_id” : ObjectId(“4d5efdceec5855af36834f5e”), “a” : 1, “b” : 2, “c” : “foobar”, “d” : 4 }
</code></pre>
<p>Is there a particular reason why you do not want the fields reordered? The above was using 1.8.0_rc0 on OS X<br>
FYI, in MongoDB 2.6 updates will preserve field order, with the following exceptions:<br>
1. The _id field is always the first field in the document.<br>
2. Updates that include renaming of field names may result in the reordering of fields in the document.</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-find-queries">MongoDB Find Queries</a></strong></p>
</div><hr><h3><p>Limit MongoDB database size?</p>
</h3><div><ul>
<li>We’re interested in deploying MongoDB, but we need to know if we can limit database/table sizes?</li>
</ul>
<p>For example:</p>
<pre><code>db.user1.find() db.user2.find()
</code></pre>
<p>As you can see from the above, each user will have their own database. We want to limit each user’s database so we don’t have any one user eating up all our hard drive space.</p>
<p>Is this possible with MongoDB?<br>
Thanks.</p>
<p>You can create a database per user and enable the –quota option. This will allow you keep any user from using too much space.</p>
<p>https://www.mongodb.org/display/DOCS/Command+Line+Parameters<br>
https://www.mongodb.org/display/DOCS/Excessive+Disk+Space</p>
</div><hr><h3><p>While Creating New User in MongoDB, it has to be created under admin?</p>
</h3><div><ul>
<li>I want to create a new user in MongoDB, So i have to do that by login to admin by(use admin) and then i have to use the command add user to create new user is it?<br>
Thanks,<br>
If no users created you can create new user without any authentification, but if you have created admin user for specific database you should authentifcate, and then perform any operation.</li>
</ul>
<p><strong>Documentation:</strong><br>
If no users are configured in admin.system.users, one may access the database from the localhost interface without authenticating. Thus, from the server running the database (and thus on localhost), run the database shell and configure an administrative user:</p>
<pre><code>$ ./mongo
&gt; use admin
&gt; db.addUser(“theadmin”, “anadminpassword”)
</code></pre>
<p>We now have a user created for database admin. Note that if we have not previously authenticated, we now must if we wish to perform further operations, as there is a user in admin.system.users.</p>
<pre><code>&gt; db.auth(“theadmin”, “anadminpassword”)
</code></pre>
<p>We can view existing users for the database with the command:</p>
<pre><code>&gt; db.system.users.find()
</code></pre>
<p>Now, let’s configure a “regular” user for another database.</p>
<pre><code>&gt; use projectx
&gt; db.addUser(“joe”, “passwordForJoe”)
</code></pre>
</div><hr><h3><p>When to embed documents in Mongo DB</p>
</h3><div><ul>
<li>
<p>I’m trying to figure out how to best design Mongo DB schemas. The Mongo DB documentation recommends relying heavily on embedded documents for improved querying, but I’m wondering if my use case actually justifies referenced documents.<br>
A very basic version of my current schema is basically: (Apologies for the psuedo-format, I’m not sure how to express Mongo schemas)<br>
Skip code block</p>
<p>users {
email (string)
}
games {
user (reference user document)
date_started (timestamp)
date_finished (timestamp)
mode (string)
score: {
total_points (integer)
time_elapsed (integer)
}
}</p>
</li>
</ul>
<p>Games are short (about 60 seconds long) and I expect a lot of concurrent writes to be taking place.</p>
<p>At some point, I’m going to want to calculate a high score list, and possibly in a segregated fashion (e.g., high score list for a particular game.mode or date)<br>
Is embedded documents the best approach here? Or is this truly a problem that relations solves better? How would these use cases best be solved in Mongo DB?<br>
… is this truly a problem that relations solves better?</p>
<p>The key here is less about “is this a relation?” and more about “how am I going to access this?”</p>
<p>MongoDB is not “anti-reference”. MongoDB does <strong>not</strong> have the benefits of joins, but it <strong>does</strong> have the benefit of embedded documents.<br>
As long as you understand these trade-offs then it’s perfectly fair to use references in MongoDB. It’s really about how you plan to query these objects.<br>
Is embedded documents the best approach here?</p>
<p>Maybe. Some things to consider.<br>
1. Dogames have value outside of the context of the user?<br>
2. How manygames will a single user have?<br>
3. Isgames transactional in nature?<br>
4. How are you going to accessgames? Do you always need all of a user’s games?</p>
<p>If you’re planning to build leaderboards and a user can generate hundreds of game documents, then it’s probably fair to have games in their own collection. Storing ten thousand instances of “game” inside of each users isn’t particularly useful.</p>
<p>But depending on your answers to the above, you could really go either way. As the litmus test, I would try running some Map / Reduce jobs (i.e. build a simple leaderboard) to see how you feel about the structure of your data.</p>
</div><hr><h3><p>Why Is MongoDB So Fast</p>
</h3><div><ul>
<li>I was showing my co-worker performance benchmarks of MongoDB vs SQL 2008 and while he believes MongoDB is faster, he doesn’t understand how its possible. His logic, was that SQL has been around for decades, and has some of the smartest people working on it, and how can MongoDB; a relatively new kid on the block be so superior in performance? I wasn’t able to really provide a solid and technical answer, and I was hoping you guys could assist.</li>
</ul>
<p>MongoDB isn’t like a traditional relational database. It’s noSQL or document based, it provides weak consistency guarantees, and it doesn’t have to guarantee consistency like SQL.<br>
MongoDB is fast because its web scale!</p>
<p>Its a fun video and well worth everyone watching, but it does answer your question – that most of the noSQL engines like MongoDB are not robust and not resilient to crashes and other outages. This security is what they sacrifice to gain speed.</p>
<p>SQL has to do quite a lot, Mongo just has to drop bits onto disk (almost)</p>
</div><hr><h3><p>How to remove an element from a doubly-nested array in a MongoDB document</p>
</h3><div><ul>
<li>
<p>I have a document structure something along the lines of the following:</p>
<p>{
“_id” : “777”,
“someKey” : “someValue”,
“someArray” : [
{
“name” : “name1”,
“someNestedArray” : [
{
“name” : “value”
},
{
“name” : “delete me”
}
]
}
]
}</p>
</li>
</ul>
<p>I want to delete the nested array element with the value “delete me”.</p>
<p>I know I can find documents which match this description using nested $elemMatch expressions. What is the query syntax for removing the element in question?<br>
To delete the item in question you’re actually going to use an update. More specifically you’re going to do an update with the $pull command which will remove the item from the array.</p>
<pre><code>db.temp.update({ _id : “777” }, {$pull : { “someArray.0.someNestedArray” : {“name”:”delete me”} } } )
</code></pre>
<p>There’s a little bit of “magic” happening here. Using .0 indicates that we know that we are modifying the 0th item of someArray. Using {“name”:”delete me”} indicates that we know the exact data that we plan to remove.</p>
<p>This process works just fine if you load the data into a client and then perform the update. This process works less well if you want to do “generic” queries that perform these operations.<br>
I think it’s easiest to simply recognize that updating arrays of sub-documents generally requires that you have the original in memory at some point.</p>
<p>In response to the first comment below, you can probably help your situation by changing the data structure a little</p>
<p>Skip code block</p>
<pre><code>“someObjects” : {
“name1”:  {
“someNestedArray” : [
{
“name” : “value”
},
{
“name” : “delete me”
}
]
}
}
</code></pre>
<p>Now you can do {$pull : { “someObjects.name1.someNestedArray” : …</p>
<p>Here’s the problem with your structure. MongoDB does not have very good support for manipulating “sub-arrays”. Your structure has an array of objects and those objects contain arrays of more objects.</p>
<p>If you have the following structure, you are going to have a difficult time using things like $pull:</p>
<pre><code>array [
{ subarray : array [] },
{ subarray : array [] },
]
</code></pre>
<p>If your structure looks like that and you want to update subarray you have two options: 1. Change your structure so that you can leverage $pull. 2. Don’t use $pull. Load the entire object into a client and use findAndModify.</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-port">MongoDB Port</a></strong></p>
</div><hr><h3><p>Can MongoDB work when size of database larger then RAM? or when index larger then RAM?</p>
</h3><div><ul>
<li>Yes it can work. To what level it will perform is more of an “It Depends”</li>
</ul>
<p>The key thing is to ensure your <strong>working set</strong> can fit in RAM. So if you have 16GB of RAM and 20GB database (inc. indexes) for example, if you need to only access half of all the data as the other half is older/never actually queried then you’ll be fine as only half of your database needs to be in RAM (10GB).</p>
<p>Working set is key here. For example, if you have a logging application outputting to MongoDB, it may be that your working set is the amount of data (and indexes) from the past 3 months and that all data before that you don’t access.</p>
<p>When your working set exceeds the amount of RAM, then it will carry on working but with noticeably degraded performance as things will then be constantly having to go to disk which is far less performant. If you’re in this situation of exceeding RAM constraints on a machine, then this is where sharding comes into play – so you can balance the data out over a number of machines therefore increasing the amount of data that can be kept in RAM.</p>
</div><hr><h3><p>Multiple $inc updates in MongoDB</p>
</h3><div><ul>
<li><strong>Is it possible to update a single document by passing two $inc operators in a single update document?</strong></li>
</ul>
<p>For example, I am trying to increment two different fields in a given document using the following update document:</p>
<pre><code>{
“$inc” : { “ViewAggregates.4d75b891842f2d3930cf7674” : 1 },
“$inc” : { “ViewAggregates.Total” : 1 }
}
</code></pre>
<p>No errors are thrown and the document is updated but only one of the fields has been incremented. It is as if the server disregarded the first $inc operator and only the second was actually applied.</p>
<p>Is this the intendedcorrect behavior or is there something I am missing?<br>
This is an interesting side-effect of dictionary keys being unique — the second $inc overwrites the first.</p>
<pre><code>However, it’s still possible to increment more than one field:
{
“$inc”: {
“ViewAggregates.4d75b891842f2d3930cf7674” : 1,
“ViewAggregates.Total” : 1
}
}
</code></pre>
<p>This works for many other operators too :-)</p>
</div><hr><h3><p>MongoDB : Indexes order and query order must match?</p>
</h3><div><ul>
<li>
<p>This question concern the internal method to manage indexes and serching Bson Documents.<br>
When you create a multiple indexes like “index1”, “index2”, “index3?…the index are stored to be used during queries, but what about the order of queries and the performance resulting.<br>
sample</p>
<p>index1,index2,index3—-&gt; query in the same order index1,index2,index3 (best case) index1,index2,index3—-&gt; query in another order index2,index1,index3 (the order altered)</p>
</li>
</ul>
<p>Many times you use nested queries including this 3 index and other items or more indexes. The order of the queries would implicate some time lost?. Must passing the queries respecting the indexes order defined or the internal architecture take care about this order search? I searching to know if i do take care about this or can make my queries in freedom manier.<br>
Thanks.</p>
<p>The order of the conditions in your query does not affect whether it can use an index or no.</p>
<pre><code>e.g. typical document structure:
{
“FieldA” : “A”,
“FieldB” : “B”
}
</code></pre>
<p>If you have an compound index on A and B :</p>
<pre><code>db.MyCollection.ensureIndex({FieldA : 1, FieldB : 1})
</code></pre>
<p>Then both of the following queries will be able to use that index:</p>
<pre><code>db.MyCollection.find({FieldA : “A”, FieldB : “B”})
db.MyCollection.find({FieldB : “B”, FieldA : “A”})
</code></pre>
<p>So the ordering of the conditions in the query do not prevent the index being used – which I think is the question you are asking.</p>
<p>You can easily test this out by trying the 2 queries in the shell and adding .explain() after the find. I just did this to confirm, and they both showed that the compound index was used.<br>
however, if you run the following query, this will NOT use the index as FieldA is not being queried on:</p>
<pre><code>db.MyCollection.find({FieldB : “B”})
</code></pre>
<p>So it’s the ordering of the fields in the index that defines whether it can be used by a query and not the ordering of the fields in the query itself (this was what Lucas was referring to).</p>
<p>If you have a compound index on multiple fields, you can use it to query on the beginning subset of fields. So if you have an index on<br>
a,b,c<br>
you can use it query on<br>
a<br>
a,b<br>
a,b,c<br>
So yes, order matters. You should clarify your question a bit if you need a more precise answer.</p>
</div><hr><h3><p>MongoDB :: are MongoIds unique across collections?</p>
</h3><div><ul>
<li>I was wondering: can Mongo IDs have the same value in different collections in the same database?<br>
Thank you,<br>
The uniqueness constraint for _id is per collection, so yes – one and the same ID can occur once per Collection.<br>
It’s however very unlikely, if not impossible, for the same ID to be generated twice. So in order for this to happen you would have to manually insert duplicate IDs.</li>
</ul>
</div><hr><h3><p>like query in mongoDB</p>
</h3><div><ul>
<li>
<p>I am working on mongodb . In which i Want to use like query. my collection structure is as follows.</p>
<p>{ “name” : “xy” , “age” : 34 , “location” : “sss”}
{ “name” : “xyx” , “age” : 45 , “location” : “sshs”}
{ “name” : “x” , “age” : 33 , “location” : “shhss”}
{ “name” : “pq” , “age” : 23 , “location” : “hhh”}
{ “name” : “pqr” , “age” : 12 , “location” : “sss”}</p>
</li>
</ul>
<p>i want to find records matching to “name” : “x”.<br>
so query will return all three records matching xy ,xyz,x.<br>
Is it possible in mongo.<br>
if any one knows plz reply.<br>
Thanks<br>
You can use regular expressions to do this:<br>
db.customers.find( { name : /^x/i } );<br>
You will probably want to have some indexes on the name field.<br>
Read more at the MongoDB Documetation site.</p>
</div><hr><h3><p>How to check if an array field contains a unique value or another array in MongoDB?</p>
</h3><div><ul>
<li>
<p>I am using mongodb now.<br>
I have blogpost collection, and blogpost has a tags filed which is an array, e.g.</p>
<p>blogpost1.tags = [‘tag1’, ‘tag2’, ‘tag3’, ‘tag4’, ‘tag5’]
blogpost2.tags = [‘tag2’, ‘tag3’]
blogpost3.tags = [‘tag2’, ‘tag3’, ‘tag4’, ‘tag5’]
blogpost4.tags = [‘tag1’, ‘tag4’, ‘tag5’]</p>
</li>
</ul>
<p>How can I do these searchs</p>
<pre><code>contains ‘tag1’
contains [‘tag1',’tag2’],
contains any of [‘tag3’, ‘tag4’]
</code></pre>
<p>Try this out:</p>
<pre><code>db.blogpost.find({ ‘tags’ : ‘tag1’}); //1
db.blogpost.find({ ‘tags’ : { $all : [ ‘tag1’, ‘tag2’ ] }}); //2
db.blogpost.find({ ‘tags’ : { $in : [ ‘tag3’, ‘tag4’ ] }}); //3
</code></pre>
<p>My experience is that for (2) the following solution is much faster than the one with “$all”:</p>
<p>db.blogpost.find({ $and: [ {tags: ‘tag1’} ,{tags: ‘tag2’} ] });</p>
<p>but to be honest, I do not not why. I would be interested in, if anyone knows.</p>
</div><hr><h3><p>create secure database in mongodb</p>
</h3><div><ul>
<li>I want to create the database in mongodb and thats secure.<br>
here ..secure mean .application has to pass username/password to connect my database in mongodb.<br>
javaamtho<br>
From Mongo Java Tutorial</li>
</ul>
<p>MongoDB can be run in a secure mode where access to databases is controlled through name and password authentication. When run in this mode, any client application must provide a name and password before doing any operations. In the Java driver, you simply do the following with the connected mongo object :<br>
boolean auth = db.authenticate(myUserName, myPassword);</p>
<p>If the name and password are valid for the database, auth will be true. Otherwise, it will be false. You should look at the MongoDB log for further information if available.<br>
Most users run MongoDB without authentication in a trusted environment.</p>
<p><strong>Configuring Authentication and Security</strong></p>
<p>Authentication is stored in each database’s system.users collection. For example, on a database projectx, projectx.system.users will contain user information.<br>
We should first configure an administrator user for the entire db server process. This user is stored under the special admin database.</p>
<p>If no users are configured in admin.system.users, one may access the database from the localhost interface without authenticating. Thus, from the server running the database (and thus on localhost), run the database shell and configure an administrative user:</p>
<pre><code>$ ./mongo
&gt; use admin
&gt; db.addUser(“theadmin”, “anadminpassword”)
</code></pre>
<p>We now have a user created for database admin. Note that if we have not previously authenticated, we now must if we wish to perform further operations, as there is a user in admin.system.users.</p>
<pre><code>&gt; db.auth(“theadmin”, “anadminpassword”)
</code></pre>
<p>We can view existing users for the database with the command:</p>
<pre><code>&gt; db.system.users.find()
</code></pre>
<p>Now, let’s configure a “regular” user for another database.</p>
<pre><code>&gt; use projectx
&gt; db.addUser(“joe”, “passwordForJoe”)
</code></pre>
<p>Finally, let’s add a readonly user. (only supported in 1.3.2+)</p>
<pre><code>&gt; use projectx
&gt; db.addUser(“guest”, “passwordForGuest”, true)
</code></pre>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-create-collection">MongoDB Create Collection</a></strong></p>
</div><hr><h3><p>How do I copy a database from one MongoDB server to another?</p>
</h3><div><ul>
<li>
<p>I have two mongodbs in different server, both start with –auth. Now I want to copy a db from one server to another.</p>
<blockquote>
<p>mongo
use admin
db.copyDatabase(“mydb”,”mydb”,”another_server”)
It shows:
{ “errmsg” : “”, “ok” : 0 }
And:
db.getLastError()
null</p>
</blockquote>
</li>
</ul>
<p>Seems no error, but the copy is not successful. What’s the correct command to use?<br>
If you are using <strong>–auth</strong>, you’ll need to include your username/password in there…<br>
Also you must be on the “destination” server when you run the command.<br>
db.copyDatabase(, , , , );<br>
If all that doesn’t work, you might want to try something like creating a slave of the database you want to copy …</p>
</div><hr><h3><p>Case-insensitive query on mongodb</p>
</h3><div><ul>
<li>
<p>Is there a way to query for a case-insensitive value on mongo without using map/reduce?<br>
Suppose you have document that contains tag field and you want search on it</p>
<p>Tags
{
tag,
…
}
First option is use regex(but it work slow as @RestRisiko said):
db.tags.find( { “tag” : { “$regex” : “C#”, “$options” : “-i” } })
Second option is create another, lower case field( and in mongodb it best way):
Tags
{
tag,
tagLower,
..
}
And use find as usual:
db.tags.find( { “tagLower” : “c#”})</p>
</li>
</ul>
<p>It will work faster, because above code can use index for search.<br>
You have to normalize the data to be queried. Using a regular expression for case-insensitive search might work as well it won’t use indexes. So your only option is to normalize. If you need to preserve the original state then you need to denormalize the data and store the normalized values in a dedicated column of the document.</p>
</div><hr><h3><p>MongoDB load balancing</p>
</h3><div><ul>
<li>I was looking at best load balancing option for concurrent users with Mongo DB. I have looked at Master Slave replication but don’t think this will load balance. Are there any open source DB load balancers for Mongo DB? I have looked at Sequoia but looks like that project is no longer actively supported.</li>
</ul>
<p>Please note: The data is not very huge &amp; also not use case for sharding. both Master Slave and Replica Sets will load balance in MongoDB, if you set slaveOK in your driver.<br>
When slaveOK is enabled MongoDB drivers direct all reads to secondaries/slaves. This provides relatively effective read balancing; for write balancing your only option.would be sharding.</p>
</div><hr><h3><p>MongoDB: unconditional updates?</p>
</h3><div><ul>
<li>This seems like a silly question but I haven’t yet found the answer. If I simply wanted to add the same field-&gt;value to EVERY record in a MongoDB collection, what would be the appropriate shell command to do so? I tried doing a multi update with a blank query ({}) but that resulted in this error:</li>
</ul>
<p><strong>multi update only works with $ operators</strong></p>
<p>I’m a bit puzzled about how to get around this. Any suggestions?<br>
The error says it all: You can only modify multiple documents using the $ modifier operators. You probably had something like this:</p>
<pre><code>&gt; db.coll.update({ }, { a: ‘b’ }, false, true);
</code></pre>
<p>Which would normally replace the first object in the collection with { a: ‘b’ } if multi was false. You wouldn’t want to replace all the objects in your collection with the same document!<br>
Use the $set operator instead:</p>
<pre><code>&gt; db.coll.update({ }, { ‘$set’: { a: ‘b’ } }, false, true);
</code></pre>
<p>This will set the a property of every document (creating it as necessary) to ‘b’.</p>
</div><hr><h3><p>Mongo: find items that don’t have a certain field</p>
</h3><div><ul>
<li>
<p>Is it possible in Mongo to search for documents in a collection that are missing a certain field?<br>
Yeah, it’s possible using $exists:</p>
<p>db.things.find( { a : { $exists : false } } ); // return if a is db.things.find( { a : { $exists : false } } ); // return if a is missing</p>
</li>
</ul>
<p>If you don’t care if the field is missing or null (or if it’s never null) then you can use the slightly shorter and safer:</p>
<p>db.things.find( { a : null } ); // return if a is missing or null</p>
<p>It’s safer because $exists will return true even if the field is null, which often is not the desired result and can lead to an NPE.</p>
</div><hr><h3><p>Is there a sample MongoDB Database along the lines of world for MySql?</p>
</h3><div><ul>
<li>As someone new to Mongo, I am looking for a sample MongoDB database that I can import and play with. Something along the lines of world for mysql or Northwind for MSSQL.<br>
Is there one? (I couldn’t find any reference to one at https://www.mongodb.org nor did my googling help)<br>
For Windows users: Please follow the following steps to import from the json file if you are using windows 7:</li>
</ul>
<ol>
<li>
<p>Download the above mentionedJSON file and place it inside a folder (say d:sample)</p>
</li>
<li>
<p>Open a command prompt, start the mongo server by going in to the bin directory and typing in mongoD</p>
</li>
<li>
<p>Now take another command prompt and go to the bin directory again and write following command C:mongodbbin&gt;mongoimport –db test –collection zips –file d:samplezips.json</p>
</li>
<li>
<p>The import would start working immediatly and at the end it would show some thing like this Thu Dec 19 17:11:22 imported 29470 objects</p>
</li>
</ol>
<p>That’s it!<br>
I found this you can import the json data with:<br>
mongoimport –db scratch –collection zips –file zips.json<br>
I guess that you can import any json data that you find, it also supports csv and tsv. Hope this helps.<br>
This doesn’t have everything, but it is a nice step towards getting Northwind on MongoDB:<br>
https://github.com/tmcnab/northwind-mongo</p>
</div><hr><h3><p>MongoDB query help: $elemMatch in nested objects</p>
</h3><div><ul>
<li></li>
</ul>
<pre><code>&gt; db.test.insert({“a” : { “b” : { “c” : { “d1” : [ “e1” ],
“d2” : [ “e2” ],
“d3” : [ “e3”, “e4” ],
“d4” : [ “e5”, “e6” ] } } } })
&gt; db.test.find({‘a.b.c’ : {$exists : true}})
{ “_id” : ObjectId(“4daf2ccd697ebaacb10976ec”), “a” : { “b” : { “c” : { “d1” : [ “e1” ], “d2” : [ “e2” ], “d3” : [ “e3”, “e4” ], “d4” : [ “e5”, “e6” ] } } } }
</code></pre>
<p>But none of these work:</p>
<pre><code>&gt; db.test.find({‘a.b’: “c”})
&gt; db.test.find({‘a.b’: {$elemMatch : {“c” : {$exists: true}}}})
&gt; db.test.find({‘a.b’: {$elemMatch : {$elemMatch : {$all : [“e1”] }}}})
</code></pre>
<p>Suppose I don’t know what the values of c and d1…d4 are. Is there a generic way to search the nested-objects’ structure for particular values?<br>
I thought that was what $elemMatch was for.<br>
Thank you.</p>
<p>I thought that was what $elemMatch was for…<br>
From the docs: Using the $elemMatch query operator, you can match an entire document within an array.<br>
This does not sounds like what you’re looking for.</p>
<p>Is there a generic way to search the nested-objects’ structure for particular values?<br>
It sounds like you want to search “everything in object ‘c’ for an instance of ‘e1'”.<br>
MongoDB supports two related features, but the features not quite what you’re looking for.<br>
1. Reach into objects, dot notation:db.test.find({‘a.b.c.d1’ : ‘e1’})<br>
2. Read through arrays: `db.test.find({‘a.b.c.d4’ : ‘e5’})<br>
It sounds like you’re looking for the ability to do both at the same time. You want to “reach into objects” and “read through arrays” in the same query.<br>
Unfortunately, I do not know of such a feature. You may want to file a feature request for this.</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-create-index">MongoDB Create Index</a></strong></p>
</div><hr><h3><p>MongoDB Cursor Timeouts while doing a lot of writes</p>
</h3><div><ul>
<li>We have a cluster of 2 replica Sets, with 3 servers per set. With a single collection being sharded. We also have a quite a few more(8+) collections that we use on a daily basis. With the majority of the data being in the sharded collection with close to 100 Million records in it.</li>
</ul>
<p>Recently we have added the requirement to obtain 100x the data that we had been getting previously, and we need to write this to mongodb. A daemon has been set in place to perform the writes necessary to keep the database up to date. The script performs at over 200 writes a second, with the majority going to the all separate collections.<br>
With this quantity of writes, we have been unable to perform large reads for analytical purposes. Receiving a combination of Cursor Timeouts client-side and server-side(“Cursor Not Found”).</p>
<p>We have attempted to do limit/skip schemes on the reads, but the problem persists. What is the best course of action to remedy this as we require both a large amount of writes, with few, but large reads?</p>
<p>Typically, in a case like this you want to start looking at the queries causing the time. Then you want to look at the hardware to see what’s being stressed.</p>
<ol>
<li>Are these queries correctly indexed?</li>
<li>How big are the indexes? Do they fit in RAM?</li>
<li>Can you provide some details on where the bottlenecks are?</li>
<li>Are you locked on on IO?</li>
<li>Are your processors running at full speed?</li>
</ol>
<p>Also, is there anything unusual in the logs?<br>
Basically we need to ensure that you have: 1. Correctly built the system to handle the query 2. Correctly provisioned the system to handle the data volumes</p>
</div><hr><h3><p>Is moving documents between collections a good way to represent state changes in MongoDB?</p>
</h3><div><ul>
<li>I have two collections, one (<strong>A)</strong> containing items to be processed (relatively small) and one (<strong>B</strong>) with those already processed (fairly large, with extra result fields).<br>
Items are read from <strong>A</strong>, get processed and save()’d to <strong>B</strong>, then remove()’d from <strong>A</strong>.</li>
</ul>
<p>The rationale is that indices can be different across these, and that the “incoming” collection can be kept very small and fast this way.<br>
I’ve run into two issues with this:</p>
<ol>
<li>if either remove() or save() time out or otherwise fail under load, I lose the item completely, or process it twice</li>
<li>if both fail, the side effects happen but there is no record of that I can sidestep the double-failure case with findAndModify locks (not needed otherwise, we have a process-level lock) but then we have stale lock issues and partial failures can still happen. There’s no way to atomically remove+save to different collections, as far as I can tell (maybe by design?)<br>
Is there a Best Practice for this situation?</li>
<li>There’s no way to atomically remove+save to different collections, as far as I can tell (maybe by design?)<br>
Yes this is by design. MongoDB explicitly does not provides joins or transactions. Remove + Save is a form of transaction.<br>
Is there a Best Practice for this situation?<br>
You really have two low-complexity options here, both involve findAndModify.<br>
<strong>Option #1: a single collection</strong><br>
Based on your description, you are basically building a queue with some extra features. If you leverage a single collection then you use findAndModify to update the status of each item as it is processing.<br>
Unfortunately, that means you will lose this: …that the “incoming” collection can be kept very small and fast this way.<br>
<strong>Option #2: two collections</strong><br>
The other option is basically a two phase commit, leveraging findAndModify.<br>
Take a look at the docs for this here.<br>
Once an item is processed in A you set a field to flag it for deletion. You then copy that item over toB. Once copied to B you can then remove the item from A.</li>
</ol>
</div><hr><h3><p>For Mongodb is it better to reference an object or use a natural String key?</p>
</h3><div><ul>
<li>I am building a corpus of indexed sentences in different languages. I have a collection of Languages which have both an ObjectId and the ISO code as a key. Is it better to use a reference to the Language collection or store a key like “en” or “fr”?<br>
I suppose it’s a compromise between:</li>
</ul>
<ol>
<li>ease of referencing the Language</li>
<li>object in that collection</li>
<li>speed in doing queries where the sentence has a certain language</li>
<li>the size of the data on disk</li>
</ol>
<p>Any best practices that I should know of?<br>
In the end, it really comes down to personal choice and what will work best for your application.<br>
The only requirement that MongoDB imposes upon _id is that it be unique. It can be an ObjectId (which is provided by default), a string, even an embedded document (As I recall it cannot be an Array though).</p>
<p>In this case, you can likely guarantee ISO Code is a unique value and it may be an ideal value. You have a ‘known’ primary key which is also useful in itself by being identifiable, so using that instead of a generated ID is probably a more sensible bet. It also means anywhere you ‘reference’ this information in another collection you can save the ISO Code instead of an Object ID; those browsing your raw data can immediately identify what information that reference points at.</p>
<p>As an aside:<br>
The two big benefit of ObjectId is that they can be generated uniquely across multiple machines, processes and threads without needing any kind of central sequence tracking by the MongoDB server. They also are stored as a special type in MongoDB that only uses 12 bytes (as opposed to the 24 byte representation of the string version of an ObjectID)</p>
</div><hr><h3><p>Does the MongoDB stats() function return bits or bytes?</p>
</h3><div><ul>
<li>
<p>When using MongoDB’s .stats() function to determine document size, are the values returned in bits or bytes?<br>
Bytes of course. Unless you pass in a scale as optional argument.<br>
Running the collStats command – db.collection.stats() – returns all sizes in bytes, e.g.</p>
<blockquote>
<p>db.foo.stats()
{
“size” : 715578011834,  // total size (bytes)
“avgObjSize” : 2862,    // average size (bytes)
}</p>
</blockquote>
</li>
</ul>
<p>However, if you want the results in another unit then you can also pass in a scale argument.<br>
For example, to get the results in KB:</p>
<pre><code>&gt; db.foo.stats(1024)
{
“size” : 698806652,  // total size (KB)
“avgObjSize” : 2,    // average size (KB)
}
Or for MB:
&gt; db.foo.stats(1024 * 1024)
{
“size” : 682428,    // total size (MB)
“avgObjSize” : 0,   // average size (MB)
}
</code></pre>
</div><hr><h3><p>Storing Friend Relationships in MongoDB?</p>
</h3><div><ul>
<li>I was wondering what the best way of storing friend relationship data using MongoDB is?<br>
Coming from mysql I had a separate table with friend relationships that had two foreign keys, each pointing to a friend in the “friendship” however, with MongoDB its possible to have arrays of references or even embedded documents..so whats the best way to store these relationships<br>
Immediate first reaction was that I’d store an array of friend object ids in each user, however, that troubles me, because then, in order to remove a “friendship” I would have to do deletes on both friend’s documents whereas if I stored the relationship in a separate collection (a la SQL) i could remove or add a relationship by just modifying one collection.<br>
Thanks!</li>
</ul>
<p>Keeping a list of friend_ids in a user, is what I’ll recommend. Few reasons,<br>
1.You query a user, and you have list of all friends upfront available.<br>
2.The requests (pending, accepted) can be handled well, by seeing that a respective ids should be present in both the user’s friends list. And I can get list of actual and accepted friends by querying</p>
<pre><code>my_id, my_friends = user._id, user.friends
db.users.find({‘_id’:{‘$in’: my_friends}, ‘friends’: my_id})
</code></pre>
<p>Yes, while removing a friendship , you have to $pull from both the friend’s list of both users, but frequency of that would be much less. But you query less in getting the friend-list, which would be used frequently.</p>
</div><hr><h3><p>MongoDB – file size is huge and growing</p>
</h3><div><ul>
<li>
<p>I have an application that use mongo for storing short living data. All data older than 45 minutes is removed by script something like:<br>
oldSearches = [list of old searches]<br>
connection = Connection()<br>
db = connection.searchDB<br>
res = db.results.remove{‘search_id’:{“$in”:oldSearches}})<br>
I’ve checked current status –</p>
<blockquote>
<p>db.results.stats()
{
“ns” : “searchDB.results”,
“count” : 2865,
“size” : 1003859656,
“storageSize” : 29315124464,
“nindexes” : 1,
“ok” : 1
}</p>
</blockquote>
</li>
</ul>
<p>So, according to this 1gb of data occupies 29GB of storage. Data folder looks like this(You may see that many files are very old – last accessed in the middle of may):<br>
Skip code block</p>
<pre><code>ls -l /var/lib/mongodb/
total 31506556
-rwxr-xr-x 1 mongodb nogroup          6 2011-06-05 18:28 mongod.lock
-rw——- 1 mongodb nogroup   67108864 2011-05-13 17:45 searchDB.0
-rw——- 1 mongodb nogroup  134217728 2011-05-13 14:45 searchDB.1
-rw——- 1 mongodb nogroup 2146435072 2011-05-20 20:45 searchDB.10
-rw——- 1 mongodb nogroup 2146435072 2011-05-28 00:00 searchDB.11
-rw——- 1 mongodb nogroup 2146435072 2011-05-27 13:45 searchDB.12
-rw——- 1 mongodb nogroup 2146435072 2011-05-29 16:45 searchDB.13
-rw——- 1 mongodb nogroup 2146435072 2011-06-07 13:50 searchDB.14
-rw——- 1 mongodb nogroup 2146435072 2011-06-06 01:45 searchDB.15
-rw——- 1 mongodb nogroup 2146435072 2011-06-07 13:50 searchDB.16
-rw——- 1 mongodb nogroup 2146435072 2011-06-07 13:50 searchDB.17
-rw——- 1 mongodb nogroup 2146435072 2011-06-06 09:07 searchDB.18
-rw——- 1 mongodb nogroup  268435456 2011-05-13 14:45 searchDB.2
-rw——- 1 mongodb nogroup  536870912 2011-05-11 00:45 searchDB.3
-rw——- 1 mongodb nogroup 1073741824 2011-05-29 23:37 searchDB.4
-rw——- 1 mongodb nogroup 2146435072 2011-05-13 17:45 searchDB.5
-rw——- 1 mongodb nogroup 2146435072 2011-05-18 17:45 searchDB.6
-rw——- 1 mongodb nogroup 2146435072 2011-05-16 01:45 searchDB.7
-rw——- 1 mongodb nogroup 2146435072 2011-05-17 13:45 searchDB.8
-rw——- 1 mongodb nogroup 2146435072 2011-05-23 16:45 searchDB.9
-rw——- 1 mongodb nogroup   16777216 2011-06-07 13:50 searchDB.ns
-rw——- 1 mongodb nogroup   67108864 2011-04-23 18:51 test.0
-rw——- 1 mongodb nogroup   16777216 2011-04-23 18:51 test.ns
According to “top” mongod uses 29G of virtual memory ( and 780Mb of RSS)
</code></pre>
<p>Why do i have such abnormal values? Do i need to run something additional to .remove() function to clean up database from old values?</p>
<p><strong>Virtual memory size</strong> and resident size will appear to be very large for the mongod process. This is benign: virtual memory space will be just larger than the size of the datafiles open and mapped; resident size will vary depending on the amount of memory not used by other processes on the machine.</p>
<p><a href="https://www.mongodb.org/display/DOCS/Caching">https://www.mongodb.org/display/DOCS/Caching</a></p>
<p>When you remove an object from MongoDB collection, the space it occupied is not automatically garbage collected and new records are only appended to the end of data files, making them grow bigger and bigger. This explains it all:</p>
<p><a href="https://www.mongodb.org/display/DOCS/Excessive+Disk+Space">https://www.mongodb.org/display/DOCS/Excessive+Disk+Space</a></p>
<p>For starters, simply use:</p>
<pre><code>db.repairDatabase()
</code></pre>
</div><hr><h3><p>Mongo does not have a max() function, how do I work around this?</p>
</h3><div><p>I have a MongoDB collection and need to find the max() value of a certain field across all docs. This value is the timestamp and I need to find the latest doc by finding the largest timestamp. Sorting it and getting the first one gets inefficient really fast. Shall I just maintain a ‘maxval’ separately and update it whenever a doc arrives with a larger value for that field? Any better suggestions? Thanks much.</p>
<p>For sure if it will be big collection and if you need always display max timestamp you may need create separate collection and store statistic data there instead of order big collection each time.</p>
<pre><code>statistic
{
_id = 1,
id_from_time_stamp_collection = ‘xxx’,
max_timestamp: value
}
</code></pre>
<p>And whenever new doc come just update statistic collection with id = 1(with $gt condition in query, so if new timestamp will be greater than max_timestamp then max_timestamp will be updated, otherwise – no).<br>
Also probably you can store and update other statistic data within statistic collection.<br>
if you have an index on the timestsamp field, finding the highest value is efficientl something like<br>
db.things.find().sort({ts:-1}).limit(1)<br>
but if having an index is too much overhead storing the max in a separate collection might be good.</p>
</div><hr><h3><p>Mongodb drop every database</p>
</h3><div><ul>
<li>
<p>I would like to know if there’re a command to drop every databases from my mongodb ?<br>
I know if I want to drop only one datatable, I just need to type the name of the database like the code below but I dont want to have to specify it.<br>
mongo DB_NAME –eval ‘db.dropDatabase();’<br>
Any help would be appreciated.<br>
Thanks.<br>
John<br>
you can create a javascript loop that do the job and then execute it in the mongoconsole.</p>
<p>var dbs = db.getMongo().getDBNames()
for(var i in dbs){
db = db.getMongo().getDB( dbs[i] );
print( “dropping db ” + db.getName() );
db.dropDatabase();
}
save it to dropall.js and then execute:
mongo dropall.js
Try this command:
mongo –quiet –eval ‘db.getMongo().getDBNames().forEach(function(i){db.getSiblingDB(i).dropDatabase()})’
You can do it easy through c# official driver:
var _mongoServer = MongoServer.Create(“mongodb://localhost:27020”);
var names = _mongoServer.GetDatabaseNames();
foreach (var name in names)
{
_mongoServer.DropDatabase(name);
}</p>
</li>
</ul>
</div><hr><h3><p>mongodb find by comparing field values</p>
</h3><div><ul>
<li>Is it possible to express the following SQL query in mongodb:<br>
SELECT * FROM table AS t WHERE t.field1 &gt; t.filed2;</li>
</ul>
<p><strong>edit:</strong> To summarize:.<br>
using a third field storing “field1 – field2” is almost perfect, but requires a little extra maintenance.<br>
$where will load and eval in JavaScript and won’t use any indexes. No good for large data.<br>
map/reduce has the same problem and will go trough all records even if we need only one<br>
You can do this using $where:<br>
db.coll.find( { $where: “this.field1 &gt; this.field2” } );<br>
<strong>But:</strong><br>
Javascript executes more slowly than the native operators, but it is very flexible<br>
If performance is an issue better to go with way suggested by @yi_H.<br>
You could store in your document field1 – field2 as field3, then search for { field3: { $gt: 0 } }<br>
It also possible to get matching documents with mapreduce.</p>
</div><hr><h3><p>insert to specific index for mongo array</p>
</h3><div><ul>
<li>
<p>Mongo supports arrays of documents inside documents. For example, something like</p>
<p>{_id: 10, “coll”: [1, 2, 3] }
Now, imagine I wanted to insert an arbitrary value at an arbitrary index
{_id: 10, “coll”: [1, {name: ‘new val’}, 2, 3] }</p>
</li>
</ul>
<p>I know you can update values in place with $ and $set, but nothing for insertion. it kind of sucks to have to replace the entire array just for inserting at a specific index.<br>
Now you can achieve this with a new upcoming version 2.6. To do this you have to use $positionoperator. For your particular example:</p>
<pre><code>db.students.update(
{ _id: 10},
{ $push: {
coll: {
$each: [ {name: ‘new val’} ],
$position: 1
}
}}
)
</code></pre>
</div><hr><h3><p>Where does MongoDB store its documents?</p>
</h3><div><ul>
<li>I have inserted and fetched data using MongoDB, in PHP. Is there an actual copy of this data in a document somewhere?<br>
MongoDB stores it’s data in the data directory specified by –dbpath. It uses a database format so it’s not actual documents, but there are multiple documents in each file and you cannot easily extract the data from this format yourself.</li>
</ul>
<p>To read and/or update a document you need to use a MongoDB client, in the same way that you send SQL queries to MySQL through a MySQL client. You probably want to do it programmatically by using one of the client libraries for your programming language, but there is also a command-line client if you need to do manual updates.</p>
<p>By default Mongo stores its data in the directory /data/db.<br>
You can specify a different directory using the –dbpath option.<br>
If youre running Mongo on Windows it will be C:datadb (the driver letter will be the same as the working directory). To avoid confusion, Id recommend that you always specify a data directory using–dbpath.</p>
</div><hr><h3><p>What does it mean to fit “working set” into RAM for MongoDB?</p>
</h3><div><ul>
<li>MongoDB is fast, but only when your working set or index can fit into RAM. So if my server has 16G of RAM, does that mean the sizes of all my collections need to be less than or equal to 16G? How does one say “ok this is my working set, the rest can be “archived?”</li>
</ul>
<p>“Working set” is basically the amount of data AND indexes that will be active/in use by your system.<br>
So for example, suppose you have 1 year’s worth of data. For simplicity, each month relates to 1GB of data giving 12GB in total, and to cover each month’s worth of data you have 1GB worth of indexes again totalling 12GB for the year.</p>
<p>If you are always accessing the last 12 month’s worth of data, then your working set is: 12GB (data) + 12GB (indexes) = 24GB.<br>
However, if you actually only access the last 3 month’s worth of data, then your working set is: 3GB (data) + 3GB (indexes) = 6GB. In this scenario, if you had 8GB RAM and then you started regularly accessing the past 6 month’s worth of data, then your working set would start to exceed past your available RAM and have a performance impact.<br>
But generally, if you have enough RAM to cover the amount of data/indexes you expect to be frequently accessing then you will be fine.<br>
Edit: Response to question in comments</p>
<p>I’m not sure I quite follow, but I’ll have a go at answering. Firstly, the calculation for working set is a “ball park figure”. Secondly, if you have a (e.g.) 1GB index on user_id, then only the portion of that index that is commonly accessed needs to be in RAM (e.g. suppose 50% of users are inactive, then 0.5GB of the index will be more frequently required/needed in RAM). In general, the more RAM you have, the better especially as working set is likely to grow over time due to increased usage. This is where sharding comes in – split the data over multiple nodes and you can cost effectively scale out. Your working set is then divided over multiple machines, meaning the more can be kept in RAM. Need more RAM? Add another machine to shard on to.</p>
<p>The working set is basically the stuff you are using most (frequently). If you use index A for collection B to search for a subset of documents then you could consider that your working set. As long as the most commonly used parts of those structures can fit in memory then things will be exceedingly fast. As parts no longer fit in your working set, like many of the documents then that can slow down. Generally things will become much slower if your indexes exceed your memory.</p>
<p>Yes, you can have lots of data, where most of it is “archived” and rarely used without affecting the performance of our application or impacting your working set (which doesn’t include that archived data).</p>
</div><hr><h3><p>MongoDB: Updating a document in an array</p>
</h3><div><ul>
<li>
<p>I have a collection with documents of this schema:</p>
<p>{
_id: something,
recipients: [{id:1, name:”Andrey”, isread:false}, {id:2, name:”John”, isread:false}]
}
Now, I want to update “isread” for John (id = 2) using findAndModify(), because I also need to get the original document.
I’m trying this command:
db.messages.findAndModify({query:{‘recipients.id’:2}, update:{‘recipients.$.isread’:true}})
but what it does, it just replaces the whole “recipients” field with ‘recipients.$.isread’, so the document now looks like:
{
_id: someid,
‘recipients.$.isread’:true
}</p>
</li>
</ul>
<p>What am I doing wrong?<br>
Try to use $set like this:</p>
<p>db.messages.findAndModify({query:{‘recipients.id’:2}, update:{$set:{‘recipients.$.isread’:true}}})</p>
</div><hr><h3><p>How to limit number of updating documents in mongodb</p>
</h3><div><ul>
<li>How to implement somethings similar to db.collection.find().limit(10) but while updating documents?<br>
Now I’m using something really crappy like getting documents withdb.collection.find().limit() and then updating them.<br>
In general I wanna to return given number of records and change one field in each of them.<br>
Thanks.</li>
</ul>
<p>Unfortunately the workaround you have is the only way to do it AFAIK. There is a boolean flagmulti which will either update all the matches (when true) or update the 1st match (when false).</p>
<p>You can use:</p>
<pre><code>db.collection.find().limit(NUMBER_OF_ITEMS_YOU_WANT_TO_UPDATE).forEach(
function (e) {
e.fieldToChange = “blah”;
….
db.collection.save(e);
}
);
</code></pre>
<p>(Credits for forEach code: MongoDB: Updating documents using data from the same document)<br>
What this will do is only change the number of entries you specify. So if you want to add a field called “newField” with value 1 to only half of your entries inside “collection”, for example, you can put in</p>
<pre><code>db.collection.find().limit(db.collection.count() / 2).forEach(
function (e) {
e.newField = 1;
db.collection.save(e);
}
);
</code></pre>
<p>If you then want to make the other half also have “newField” but with value 2, you can do an update with the condition that newField doesn’t exist:<br>
db.collection.update( { newField : { $exists : false } }, { $set : { newField : 2 } }, {multi : true} );</p>
</div><hr><h3><p>Compound indices for OR+Sort query in mongodb</p>
</h3><div><ul>
<li>
<p>For this OR query:</p>
<p>db.messages.find({ $or: [ { to: { $ne: null }, from: “xyz” }, { to: “xyz” } ] }).sort({_id: -1}).limit(50)</p>
</li>
</ul>
<p>with following indices:</p>
<pre><code>{to:1, from: 1, _id:-1} and {from:1, to:1, _id:-1}
</code></pre>
<p>mongo is always doing a full scan.<br>
I was hoping that mongo could use these two indices and merge the results.<br>
Do I need to split this into two queries (one for each OR clause) and merge myself? Or is there some other index that can help?</p>
<p>This is a known issue, https://jira.mongodb.org/browse/SERVER-1205, which you can vote for if it is very important for your use case.</p>
</div><hr><h3><p>MongoDB: Unique index on array element’s property</p>
</h3><div><ul>
<li>
<p>I have a structure similar to this:</p>
<p>class Cat {
int id;
List kittens;
}
class Kitten {
int id;
}</p>
</li>
</ul>
<p>I’d like to prevent users from creating a cat with more than one kitten with the same id. I’ve tried creating an index as follows:<br>
db.Cats.ensureIndex({‘id’: 1, ‘kittens.id’: 1}, {unique:true})<br>
But when I attempt to insert a badly-formatted cat, Mongo accepts it.<br>
Am I missing something? can this even be done?<br>
As far as I know, unique indexes only enforce uniqueness across different documents, so this would throw a duplicate key error:</p>
<pre><code>db.cats.insert( { id: 123, kittens: [ { id: 456 } ] } )
db.cats.insert( { id: 123, kittens: [ { id: 456 } ] } )
</code></pre>
<p>But this is allowed:</p>
<pre><code>db.cats.insert( { id: 123, kittens: [ { id: 456 }, { id: 456 } ] } )
</code></pre>
<p>I’m not sure if there’s any way enforce the constraint you need at the Mongo level, maybe it’s something you could check in the application logic when you insert of update?</p>
</div><hr><h3><p>Updating embedded document property in Mongodb</p>
</h3><div><ul>
<li>
<p>I have a document that looks like this:<br>
Skip code block</p>
<p>{
“_id”: 3,
“Slug”: “slug”,
“Title”: “title”,
“Authors”: [
{
“Slug”: “slug”,
“Name”: “name”
}
]
}</p>
</li>
</ul>
<p>I want to update all Authors.Name based on Authors.Slug. I tried this but it didn’t work:</p>
<pre><code>.update({“Authors.Slug”:”slug”}, {$set: {“Authors.Name”:”zzz”}});
</code></pre>
<p>What am I doing wrong here?</p>
<pre><code>.update(Authors:{$elemMatch:{Slug:”slug”}}, {$set: {‘Authors.$.Name’:”zzz”}});
</code></pre>
</div><hr><h3><p>What is the best way to store dates in MongoDB?</p>
</h3><div><ul>
<li>I am just starting to learn about MongoDB and hoping to slowly migrate from MySQL.</li>
</ul>
<p>[</p>
<h3>MongoDB Certification Training !</h3>
<p>Explore Curriculum</p>
<p>](https://mindmajix.com/mongodb-training#curriculum)</p>
<p>In MySQL, there are two different data types – DATE (‘0000-00-00’) and DATETIME (‘0000-00-00 00:00:00’). In my MySQL, I use the DATE type, but I am not sure how to transfer them into MongoDB. In MongoDB, there is a Date object, which is comparable to DATETIME. It seems it would be most appropriate to use Date objects, but that would be wasting space, since hours, min, sec are not utilized. On the other hand, storing dates as strings seems wrong.</p>
<p>Is there a golden standard on storing dates (‘0000-00-00’) in MongoDB?</p>
<p>BSON (the storage data format used by mongo natively) has a dedicated date type UTC datetime which is a 64 bit (so, 8 byte) signed integer denoting milliseconds since Unix time epoch. There are very few valid reasons why you would use any other type for storing dates and timestamps.</p>
<p>If you’re desperate to save a few bytes per date (again, with mongo’s padding and minimum block size and everything this is only worth the trouble in very rare cases) you can store dates as a 3 byte binary blob by storing it as an unsigned integer in YYYYMMDD format, or a 2 byte binary blob denoting “days since January 1st of year X” where X must be chosen appropriately since that only supports a date range spanning 179 years.</p>
<p>EDIT: As the discussion below demonstrates this is only a viable approach in very rare circumstances. <strong>Basically; use mongo’s native date type</strong><br>
I’m actually in the process of converting a MongoDB database where dates are stored as proper Date() types to instead store them as strings in the form yyyy-mm-dd. Why, considering that every other answerer says that this is a horrible idea? Simply put, because of the neverending pain I’ve been suffering trying to work with dates in JavaScript, which has no (real) concept of timezones.</p>
<p>I had been storing UTC dates in MongoDB, i.e. a Date() object with my desired date and the time set as midnight UTC, but it’s unexpectedly complicated and error-prone to get a user submitted date correctly converted to that from whatever timezone they happen to be in. I’ve been struggling to get my JavaScript “whatever local timezone to UTC” code to work (and yes, I’m aware of Sugar.js and Moment.js) and I’ve decided that simple strings like the good old MySQL standard yyyy-mm-dd is the way to go, and I’ll parse into Date() objects as needed at runtime on the client side.</p>
<p>Incidentally, I’m also trying to sync this MongoDB database with a FileMaker database, which also has no concept of timezones. For me the simplicity of simply not storing time data, especially when it’s meaningless like UTC midnight, helps ensure less-buggy code even if I have to parse to and from the string dates now and then.</p>
</div><hr><h3><p>MongoDb : Avoid excessive disk space</p>
</h3><div><ul>
<li>I am having a database which has been allocated a space of 85GB. I got this size using the show dbs command. But when I use the db.stats(), i get the storage size as 63GB. After going through the docs I found dat mongo db allocates a size to the db that is created and then the actual data is filled.</li>
</ul>
<p>Why does mongo does this preallocation and is there a way I can avoid this preallocation ?<br>
If Yes, will it be a good idea to do it or it is going to affect from performance point of view ?<br>
Thanks!!!</p>
<p>Details can be found here: https://www.mongodb.org/display/DOCS/Excessive+Disk+Space<br>
Now to your case. I think that the current size of your datafiles cannot be caused by preallocation alone. The maximum size of allocated data files is 2G. Maybe you once stored much more data than today? The link above also shows how to reclaim this data if you’re sure you will not need it soon anyway. This will require a lot of disk space during the process, so you must give this some planning.</p>
<p>Disabling preallocation will indeed have perfomance impact. When you do many inserts, the process would regularly have to wait to create a new file.</p>
</div><hr><h3><p>Get n-th element of an array in mongo</p>
</h3><div><ul>
<li>
<p>As part of my document in mongo I’m storing an array of objects. How can I query it for only the 4th element of the array for example? So I don’t want the get the entire array out, just the 4th element.<br>
Use $slice.</p>
<p>db.foo.find({ bar : “xyz” } , { my_array : { $slice : [n , 1] } } )</p>
</li>
</ul>
<p>will retrieve the nth element of the array “my_array” of all documents in the foo collection where bar = “xyz”.<br>
Some other examples from the MongoDB documentation:</p>
<pre><code>db.posts.find({}, {comments:{$slice: 5}}) // first 5 comments
db.posts.find({}, {comments:{$slice: -5}}) // last 5 comments
db.posts.find({}, {comments:{$slice: [20, 10]}}) // skip 20, limit 10
db.posts.find({}, {comments:{$slice: [-20, 10]}}) // 20 from end, limit 10
</code></pre>
<p>Which you can read here: <a href="https://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields">https://www.mongodb.org/display/DOCS/Retrieving+a+Subset+of+Fields</a></p>
<p>Another way to do this is to use the update array syntax. Here, contribs.1 sets the second element in the contribs array to have value ALGOL 58 (Taken from the manual page on update syntax)</p>
<pre><code>db.bios.update(
{ _id: 1 },
{ $set: { ‘contribs.1’: ‘ALGOL 58’ } }
)
</code></pre>
</div><hr><h3><p>How to delete n-th element of array in mongodb</p>
</h3><div><ul>
<li>
<p>For example i have a document</p>
<p>db.test.save({_id: 1, list:[
{key: “a”},
{key: “b”},
{key: “c”},
{key: “d”},
{key: “e”}
]})</p>
</li>
</ul>
<p>and i need remove second element from the list. For now I do that in a two steps. First of all I unset second list element but unset operator do not remove element, it is going to be null, after that I pull any nullable value from the list field</p>
<pre><code>db.test.update({_id: 1}, {$unset: {“list.2”: 1}})
db.test.update({_id: 1}, {$pull: {list: null}})
</code></pre>
<p>I want to ask whether there is solution do that in a one operation?<br>
No, unfortunately what you are doing is currently the best option. Have a look at this question: In mongoDb, how do you remove an array element by it’s index which links to a Jira for this very issue.</p>
</div><hr><h3><p>Slow pagination over tons of records in mongo</p>
</h3><div><ul>
<li>I have over 300k records in one collection in Mongo.<br>
When I run this very simple query:<br>
db.myCollection.find().limit(5);<br>
It took only few miliseconds. When I use skip in the query:<br>
db.myCollection.find().skip(200000).limit(5)<br>
It won’t return anything… it is running minutes and return nothing.<br>
How to make it better?<br>
From MongoDB documentation:</li>
</ul>
<p><strong>Paging Costs</strong></p>
<p>Unfortunately skip can be (very) costly and requires the server to walk from the beginning of the collection, or index, to get to the offset/skip position before it can start returning the page of data (limit). As the page number increases skip will become slower and more cpu intensive, and possibly IO bound, with larger collections.<br>
Range based paging provides better use of indexes but does not allow you to easily jump to a specific page.</p>
<p>You have to ask yourself a question: how often do you need 40000th page? Also see this article;<br>
One approach to this problem, if you have large quantities of documents and you are displaying them in sorted order (I’m not sure how useful skip is if you’re not) would be to use the key you’re sorting on to select the next page of results.</p>
<p>So if you start with</p>
<pre><code>db.myCollection.find().limit(100).sort(created_date:true);
</code></pre>
<p>and then extract the created date of the last document returned by the cursor into a variablemax_created_date_from_last_result, you can get the next page with the far more efficient (presuming you have an index on created_date) query</p>
<pre><code>db.myCollection.find({created_date : { $gt : max_created_date_from_last_result} }).limit(100).sort(created_date:true);
</code></pre>
</div><hr><h3><p>How to use variables in MongoDB Map-reduce map function</p>
</h3><div><ul>
<li>
<p>Given a document</p>
<p>{_id:110000, groupings:{A:’AV’,B:’BV’,C:’CV’,D:’DV’},coin:{old:10,new:12}}</p>
</li>
</ul>
<p>My specs call for the specification of attributes for mapping and aggregation at run time, as the groupings the interested in are not known up front, but specified by the user.<br>
For example, one user would specify [A,B] which will cause mapping emissions of</p>
<pre><code>emit( {A:this.groupings.A,B:this.groupings.B},this.coin )
</code></pre>
<p>while another would want to specify [A,C] which will cause mapping emissions of</p>
<pre><code>emit( {A:this.groupings.A,C:this.groupings.C},this.coin )
</code></pre>
<p>B/c the mapper and reducer functions execute server side, and don’t have access to client variables, I haven’t been able to come up with a way to use a variable map key in the mapper function.</p>
<p>If I could reference a list of things to group by from the scope of the execution of the map function, this is all very strait forward. However, b/c the mapping function end up getting from from a different scope, I don’t know how to do this, or if it’s even possible.</p>
<p>Before I start trying to dynamically build java script to execute through the driver, does anyone have a better suggestion? Maybe a ‘group’ function will handle this scenario better?<br>
You can pass global, read-only data into map-reduce functions using the “scope” parameter on the map-reduce command. It’s not very well documented, I’m afraid. As pointed out by @Dave Griffith, you can use the scope parameter of the mapReduce function.</p>
<p>I struggled a bit to figure out how to properly pass it to the function because, as pointed out by others, the documentation is not very detailed. Finally, I realised that mapReduce is expecting 3 params:<br>
1. map function<br>
2. reduce function<br>
3. object with one or more of the params definedin the doc</p>
<p>Eventually, I arrived at the following code in Javascript:</p>
<pre><code>// I define a variable external to my map and to my reduce functions
var KEYS = {STATS: “stats”};
function m() {
// I use my global variable inside the map function
emit(KEYS.STATS, 1);
}
function r(key, values) {
// I use a helper function
return sumValues(values);
}
// Helper function in the global scope
function sumValues(values) {
var result = 0;
values.forEach(function(value) {
result += value;
});
return value;
}
db.something.mapReduce(
m,
r,
{
out: {inline: 1},
// I use the scope param to pass in my variables and functions
scope: {
KEYS: KEYS,
sumValues: sumValues // of course, you can pass function objects too
}
}
);
</code></pre>
</div><hr><h3><p>mongo dbname –eval ‘db.collection.find()’ does not work</p>
</h3><div><ul>
<li>
<p>Why does this work:</p>
<h1>mongo dbname</h1>
<p>MongoDB shell version: 1.8.3
connecting to: nextmuni_staging</p>
<blockquote>
<p>db.collection.find()
{ “foo” : “bar” }
bye</p>
</blockquote>
</li>
</ul>
<p>While this does not work:</p>
<pre><code># mongo localhost/dbname –eval ‘db.collection.find()’
MongoDB shell version: 1.8.3
connecting to: localhost/dbname
DBQuery: dbname.collection -&gt; undefined
</code></pre>
<p>It should be exactly the same, no?<br>
Thanks!<br>
The return val of db.collection.find() is a cursor type. Executing this command from within the shell will create a cursor and show you the first page of data. You can start going through the rest by repeating the ‘it’ command.</p>
<p>I think the scope of variables used during the execution of an eval’d script is only for the lifetime of the script (data can be persisted into collections of course) so once the script terminates those cursor variables no longer exist and so you would be able to send another eval script to page the data. So the behaviour you get during a shell session wouldn’t really work from an eval script.</p>
<p>To get close to the behaviour you could run something like this:<br>
mongo dbname –eval “db.collection.find().forEach(function(x){printjson(x);})”<br>
That shows you that the command does execute and produce a cursor which you can then iterate over sending the output to stdout.<br>
Edit: I think the point I was trying to make was that the command you are issuing is working its just the output is not what you expect.</p>
</div><hr><h3><p>Compact command not freeing up space in MongoDB 2.0</p>
</h3><div><ul>
<li>I just installed MongoDB 2.0 and tried to run the compact command instead of the repair command in earlier versions. My database is empty at the moment, meaning there is only one collection with 0 entries and the two system collections (indices, users). Currently the db takes about 4 GB of space on the harddisk. The db is used as a temp queue with all items being removes after they have been processed.</li>
</ul>
<p>I tried to run the following in the mongo shell.<br>
use mydb<br>
db.theOnlyCollection.runCommand(“compact”)<br>
It returns with<br>
ok: 1<br>
But still the same space is taken on the harddisk. I tried to compact the system collections as well, but this did not work.<br>
When I run the normal repair command<br>
db.repairDatabase()<br>
the database is compacted and only takes 400 MB.<br>
Anyone has an idea why the compact command is not working?<br>
Thanks a lot for your help.<br>
Best<br>
Alex<br>
Collection compaction is not supposed to decrease the size of data files. Main point is to defragment collection and index data – combine unused space gaps into continuous space allowing new data to be stored there. Moreover it may actually increase the size of data files:<br>
Compaction may increase the total size of your data files by up to 2GB. Even in this case, total collection storage space will decrease.</p>
<p>https://www.mongodb.org/display/DOCS/compact+Command#compactCommand-Effectsofacompaction</p>
</div><hr><h3><p>MongoDB: order by two fields sum</p>
</h3><div><ul>
<li>SELECT (a+b) as c FROM my_table ORDER BY c ASC;<br>
How can I order by two columns sum in Mongo?<br>
You can’t do it easy without an extra action.<br>
To sort on any computed value you need to store it in a document first or in other worlds you need to create extra field ‘c’, and store a + b in it with each update/insert and only then sort on ‘c’ as usual.</li>
</ul>
</div><hr><h3><p>Is it practical to use Mongo’s capped collection a memory cache?</p>
</h3><div><ul>
<li>Is it practical to use Mongo’s capped collections as poor man’s memcache assuming it will be kept in memory most of the time?<br>
You can definitely use capped collections for this purpose. But it’s important to know the basic limitations.</li>
</ul>
<p>1. Data will expire based on insert order not time-to-expire<br>
2. Data that is frequently accessed may still be pushed out of memory<br>
3. _idcolumns are not defined on Capped Collections by default, you will need to ensure those indexes.<br>
4. The objects cannot be modified in a way that changes the size of the object. For example, youcouldincrement an existing integer, but you cannot add a field or modify a string value on the entry.<br>
5. The capped collection scannot be sharded.</p>
<p>Because of #1 &amp; #4 &amp; #5, you are definitely losing some the core Memcache functionality.<br>
There is a long-outstanding JIRA ticket for TTL-based capped collections which is probably exactly what you want.<br>
Of course, the big question in this whole debate is “where is the extra RAM”. Many people who use MongoDB as their primary store simply drop Memcache. If you have a bunch of extra RAM sitting around, why not just use it store the actual data instead of copies of that data?</p>
</div><hr><h3><p>MongoDB Path Change?</p>
</h3><div><ul>
<li>My server went down from an electrical failure and for a few horrifying seconds, I thought I’d lost all MongoDB data. I then realized that when the server restarted, mongo automatically restarted without the –dbpath option.</li>
</ul>
<p>What I can’t figure out is why, even though my mongodb.conf has the dbpath set to /var/lib/mongodb, mongo looked for the db files in /data/db on startup. Can anyone shed some light on this?<br>
Thanks!</p>
<p>/data/db is the default path that mongod will look for data files in if it is started with no options. Does your startup script instruct mongod to load the correct config file? If not, that would explain this behavior.</p>
<p>When was the last time you updated Mongod on your system? and how did you update it?</p>
<p>Depending how you installed / updated Mongod it could happen that either the /etc/init.d/mongo script or the /etc/mongo.conf files could be overwritten.<br>
Or somebody edited those files a long time ago, and this is the first time Mongo got restarted, and now it looks like there’s suddenly a change.<br>
I haven’t seen either of those two things happen in a long time (but if you’re using Gentoo, you would probably see this happen)<br>
What OS do you use?<br>
It’s a good idea to keep backups of those files…</p>
</div><hr><h3><p>In MongoDB, how do I find documents where array size is greater than 1?</p>
</h3><div><ul>
<li>
<p>I have a MongoDB collection (accommodations) that has documents in the following format:</p>
<p>Skip code block
{
“_id” : ObjectId(“4e8ae86d08101908e1000001”),
“name” : [“Some Name”],
“zipcode” : [“2223”]
}
{
“_id” : ObjectId(“4e8ae86d08101908e1000002”),
“name” : [“Another “, “Name”],
“zipcode” : [“2224”]
}
{
“_id” : ObjectId(“4e8ae86d08101908e1000003”),
“name” : [“Yet”, ” Another “, “Name”],
“zipcode” : [“2225”]
}</p>
</li>
</ul>
<p>My question is: How can I select all documents that have a name array size of greater than 1?<br>
I can get documents that match an array size:</p>
<pre><code>db.accommodations.find({“name”:{$size:2 }})
</code></pre>
<p>This will correctly return the documents where there are 2 elements in the name array. However I can’t do a $gt command to return all documents where the name field has an array size of greater than 2:</p>
<pre><code>db.accommodations.find({“name”:{$size: {$gt:1} }})
</code></pre>
<p>Any ideas how I can do this on existing data… preferably without modifying the data?<br>
Many thanks</p>
<p><strong>Update:</strong></p>
<p>For mongodb versions 2.2+ more efficient way to do this described by @JohnnyHK in anotheranswer.<br>
1.Using $where<br>
db.accommodations.find( { $where: “this.name.length &gt; 1” } );<br>
But…<br>
Javascript executes more slowly than the native operators listed on this page, but is very flexible. See the server-side processing page for more information.</p>
<p>2.Create <strong>extra</strong> field NamesArrayLength, update it with names array length and then use in queries:<br>
db.accommodations.find({“NamesArrayLength”: {$gt: 1} });<br>
It will be better solution, and will work much faster (you can create index on it).<br>
There’s a more efficient way to do this in MongoDB 2.2+ now that you can use numeric array indexes in query object keys.<br>
// Find all docs that have at least a second name array element.<br>
db.accommodations.find({‘name.1’: {$exists: true}})<br>
I believe this is the fastest query that answers your question, because it doesn’t use an interpreted$where clause:</p>
<pre><code>{$nor: [
{name: {$exists: false}},
{name: {$size: 0}},
{name: {$size: 1}}
]}
</code></pre>
<p>It means “all documents except those without a name (either non existant or empty array) or with just one name.”<br>
Test:<br>
Skip code block</p>
<pre><code>&gt; db.test.save({})
&gt; db.test.save({name: []})
&gt; db.test.save({name: [‘George’]})
&gt; db.test.save({name: [‘George’, ‘Raymond’]})
&gt; db.test.save({name: [‘George’, ‘Raymond’, ‘Richard’]})
&gt; db.test.save({name: [‘George’, ‘Raymond’, ‘Richard’, ‘Martin’]})
&gt; db.test.find({$nor: [{name: {$exists: false}}, {name: {$size: 0}}, {name: {$size: 1}}]})
{ “_id” : ObjectId(“511907e3fb13145a3d2e225b”), “name” : [ “George”, “Raymond” ] }
{ “_id” : ObjectId(“511907e3fb13145a3d2e225c”), “name” : [ “George”, “Raymond”, “Richard” ] }
{ “_id” : ObjectId(“511907e3fb13145a3d2e225d”), “name” : [ “George”, “Raymond”, “Richard”, “Martin” ] }
&gt;
</code></pre>
</div><hr><h3><p>heterogeneous bulk update in mongodb</p>
</h3><div><ul>
<li>
<p>I know that we can bulk update documents in mongodb with<br>
db.collection.update( criteria, objNew, upsert, multi )<br>
in one db call, but it’s homogeneous, i.e. all those documents impacted are following one kind of criteria. But what I’d like to do is something like<br>
db.collection.update([{criteria1, objNew1}, {criteria2, objNew2}, …]<br>
, to send multiple update request which would update maybe absolutely different documents or class of documents in single db call.<br>
What I want to do in my app is to insert/update a bunch of objects with compound primary key, if the key is already existing, update it; insert it otherwise.<br>
Can I do all these in one combine in mongodb?<br>
That’s two seperate questions. To the first one; there is no MongoDB native mechanism to bulk send criteria/update pairs although technically doing that in a loop yourself is bound to be about as efficient as any native bulk support.<br>
Checking for the existence of a document based on an embedded document (what you refer to as compound key, but in the interest of correct terminology to avoid confusion it’s better to use the mongo name in this case) and insert/update depending on that existence check can be done with upsert :</p>
<p>document A :
{
_id: ObjectId(…),
key: {
name: “Will”,
age: 20
}
}</p>
</li>
</ul>
<p>db.users.update({name:”Will”, age:20}, {$set:{age: 21}}), true, false)<br>
This upsert (update with insert if no document matches the criteria) will do one of two things depending on the existence of document A :<br>
1. Exists : Performs update “$set:{age:21}” on the existing document<br>
2. Doesn’t exist : Create a new document with fields “name” and field “age” with values “Will” and “20” respectively (basically the criteria are copied into the new doc) and then the update is applied ($set:{age:21}). End result is a document with “name”=”Will” and “age”=21.<br>
Hope that helps</p>
</div><hr><h3><p>Is it possible to mongodump the last “x” records from a collection?</p>
</h3><div><ul>
<li>Can you use mongodump to dump the latest “x” documents from a collection? For example, in the mongo shell you can execute:<br>
db.stats.find().sort({$natural:-1}).limit(10);<br>
Is this same capability available to mongodump?<br>
I guess the workaround would be to dump the above documents into a new temporary collection and mongodump the entire temp collection, but would be great to just be able to do this via mongodump.<br>
Thanks in advance,</li>
</ul>
<p>Michael<br>
mongodump does not fully expose the cursor interfaces. But you can work around it, using the –query parameter. First get the total number of documents of the collection<br>
db.collection.count()<br>
Let’s say there are 10000 documents and you want the last 1000. To do so get the id of first document you want to dump.</p>
<pre><code>db.collection.find().sort({_id:1}).skip(10000 – 1000).limit(1)
</code></pre>
<p>In this example the id was “50ad7bce1a3e927d690385ec”. Now you can feed mongodump with this information, to dump all documents a with higher or equal id.<br>
$ mongodump -d ‘your_database’ -c ‘your_collection’ -q ‘{_id: {$lte: ObjectId(“50ad7bce1a3e927d690385ec”)}}’</p>
<p><strong>UPDATE</strong> the new parameters ‘–limit’ and ‘–skip’ were added to mongoexport will be probably available in the next version of the tool: https://github.com/mongodb/mongo/pull/307<br>
mongodump supports the –query operator. If you can specify your query as a json query, you should be able to do just that.</p>
<p>If not, then your trick of running a query to dump the records into a temporary collection and then dumping that will work just fine. In this case, you could automate the dump using a shell script that calls a mongo with a javascript command to do what you want and then calling mongodump.</p>
</div><hr><h3><p>How do you get the size of an individual index in MongoDB?</p>
</h3><div><ul>
<li>I know I can use db.collection.totalIndexSize() to get the total index size, but I’m interested in seeing the size of an individual index.<br>
Is this supported?</li>
</ul>
<p>Certainly can. db.collection.stats().indexSizes is an embedded document where each index name is a key and the value is the total index size in bytes :</p>
<pre><code>&gt; db.test.stats()
{
“ns” : “test.test”,

“indexSizes” : {
“_id_” : 137904592,
“a_1” : 106925728
},
“ok” : 1
}
</code></pre>
</div><hr><h3><p>mongodb Mongod complains that there is no /data/db folder</p>
</h3><div><ul>
<li>I am using my new mac for the first time today. I am following the get started guide on the mongodb.org up until the step where one creates the /data/db directory. btw, I used the homebrew route.</li>
</ul>
<p>So I open a terminal, and I think I am at what you called the Home Directory, for when I do “ls”, I see folders of Desktop Application Movies Music Pictures Documents and Library.<br>
So I did a<br>
mkdir -p /data/db<br>
first, it says permission denied. I kept trying different things for half and hour and finally :<br>
mkdir -p data/db<br>
worked. and when I “ls”, a directory of data and nested in it a db folder do exist.<br>
then I fire up mongod and it complains about not finding data/db<br>
Have I done something wrong?<br>
Now I have done the<br>
sudo mkdir -p /data/db<br>
and when I do a “ls” I do see the data dir and the db dir. inside the db dir though, there is absolutely nothing in it and when I now run mongod</p>
<p>Skip code block</p>
<pre><code>Sun Oct 30 19:35:19 [initandlisten] exception in initAndListen: 10309 Unable to create/openlock file: /data/db/mongod.lock errno:13 Permission denied Is a mongod instance already running?, terminating
Sun Oct 30 19:35:19 dbexit:
Sun Oct 30 19:35:19 [initandlisten] shutdown: going to close listening sockets…
Sun Oct 30 19:35:19 [initandlisten] shutdown: going to flush diaglog…
Sun Oct 30 19:35:19 [initandlisten] shutdown: going to close sockets…
Sun Oct 30 19:35:19 [initandlisten] shutdown: waiting for fs preallocator…
Sun Oct 30 19:35:19 [initandlisten] shutdown: lock for final commit…
Sun Oct 30 19:35:19 [initandlisten] shutdown: final commit…
Sun Oct 30 19:35:19 [initandlisten] shutdown: closing all files…
Sun Oct 30 19:35:19 [initandlisten] closeAllFiles() finished
Sun Oct 30 19:35:19 [initandlisten] shutdown: removing fs lock…
Sun Oct 30 19:35:19 [initandlisten] couldn’t remove fs lock errno:9 Bad file descriptor
Sun Oct 30 19:35:19 dbexit: really exiting now
EDIT Getting error message for
sudo chown mongod:mongod /data/db
chown: mongod: Invalid argument
</code></pre>
<p>Thanks, everyone!<br>
<strong>You created the directory in the wrong place</strong></p>
<p>/data/db means that it’s directly under the ‘/’ root directory, whereas you created ‘data/db’ (without the leading /) probably just inside another directory, such as the ‘/root’ homedirectory.</p>
<p><strong>You need to create this directory as root</strong></p>
<p>Either you need to use sudo , e.g. sudo mkdir -p /data/db<br>
Or you need to do su – to become superuser, and then create the directory with mkdir -p /data/db</p>
<p>Note:<br>
MongoDB also has an option where you can create the data directory in another location, but that’s generally not a good idea, because it just slightly complicates things such as DB recovery, because you always have to specify the db-path manually. I wouldn’t recommend doing that.</p>
<p>Edit:<br>
the error message you’re getting is “U<strong>nable to create/open lock file: /data/db/mongod.lock errno:13 Permission denied</strong>”. The directory you created doesn’t seem to have the correct permissions and ownership — it needs to be writable by the user who runs the MongoDB process.<br>
To see the permissions and ownership of the ‘/data/db/’ directory, do this: (this is what the permissions and ownership should look like)<br>
$ ls -ld /data/db/<br>
drwxr-xr-x 4 mongod mongod 4096 Oct 26 10:31 /data/db/<br>
The left side ‘drwxr-xr-x’ shows the permissions for the User, Group, and Others. ‘mongod mongod’ shows who owns the directory, and which group that directory belongs to. Both are called ‘mongod’ in this case.</p>
<p><strong>If your ‘/data/db’ directory doesn’t have the permissions and ownership above, do this:<br>
sudo chmod 0755 /data/db</strong><br>
sudo chown mongod:mongod /data/db<br>
that should make it work..</p>
<p>Check here to better understand the meaning of the directory permissions:</p>
<p><a href="https://www.dartmouth.edu/~rc/help/faq/permissions.html">https://www.dartmouth.edu/~rc/help/faq/permissions.html</a></p>
<p>Maybe also check out one of the tutorials you can find via Google: “UNIX for beginners”<br>
After getting the same error as Nik<br>
chown: id -u: Invalid argument<br>
I found out this apparently occurred from using the wrong type of quotation marks (should have been <strong>backquotes</strong>) Ubuntu Forums<br>
Instead I just used<br>
sudo chown $USER /data/db<br>
as an alternative and now mongod has the permissions it needs.</p>
</div><hr><h3><p>mongodb replicaset host name change error</p>
</h3><div><ul>
<li>
<p>I have a mongodb replicaset on ubuntu.. In replica set, hosts are defined as localhost. You can see ;</p>
<p>Skip code block
{
“_id” : “myrep”,
“version” : 4,
“members” : [
{
“_id” : 0,
“host” : “localhost:27017”
},
{
“_id” : 2,
“host” : “localhost:27018”
},
{
“_id” : 1,
“host” : “localhost:27019”,
“priority” : 0
}
]
}</p>
</li>
</ul>
<p>I want to change host adresses with real ip of server. But when i run rs.reconfig, I get error :</p>
<pre><code>{
“assertion” : “hosts cannot switch between localhost and hostname”,
“assertionCode” : 13645,
“errmsg” : “db assertion failure”,
“ok” : 0
}
</code></pre>
<p>How can i solve it ? Thank you.<br>
There is a cleaner way to do this:<br>
use local</p>
<pre><code>cfg = db.system.replset.findOne({_id:”replicaSetName”})
cfg.members[0].host=”newHost:27017?
db.system.replset.update({_id:”replicaSetName”},cfg)
</code></pre>
<p>then restart mongo</p>
</div><hr><h3><p>Mongo compound indexes, using less-than-all in a query</p>
</h3><div><ul>
<li>I understand that with MongoDB, for a query to make use of a compound index it must use ALL of the keys in the index, or at least some of the keys starting from the left. For example<br>
db.products.find({ “a”:”foo”, “b”:”bar” })<br>
Will happily make use of an index made up of {a, b, c}.<br>
However, if I want to query:<br>
db.products.find( {“a”:”foo”, “c”:”thing” })<br>
I believe this can’t use the index. Could this be solved by adding a trivial condition on “b”, e.g.<br>
db.products.find( {“a”:”foo”, “b”:{ $ne : “” }, “c”:”thing” })<br>
Even when I don’t actually care about the value of b. The reason for this is that we currently have 45m objects, and it’s going to continue growing so we’re looking to consolidate our indexes to save on resources.<br>
Many thanks.</li>
</ul>
<p>In general, a query on a multi-column index that does not sufficiently limit matches for one of the columns will restrict the usefulness of the multi-column index. In your example, using query criteria of {“a”:”foo”, “b”:{$ne:””}, “c”:”thing”} will limit the usefulness of an {a,b,c} index to matching only on a. If your query criteria will be executed often, create an {a,c,b} index (or {a,c} ifb will not be used in query criteria).</p>
<p>Use the explain function on your queries to see if an index is being used to its full potential. Ifexplain tells you indexOnly is true, then your query is only using the index to find matching documents; otherwise, MongoDB needs to look at each document to find matches.<br>
For further information, see:<br>
1. Optimization<br>
2. Indexes<br>
3. Query Optimizer</p>
</div><hr><h3><p>New to MongoDB Can not run command mongo</p>
</h3><div><ul>
<li>
<p>I was trying to run MongoDB:</p>
<p>Skip code block
E:mongobin&gt;mongod
mongod –help for help and startup options
Sun Nov 06 18:48:37
Sun Nov 06 18:48:37 warning: 32-bit servers don’t have journaling enabled by default. Please use –journal if you want durability.
Sun Nov 06 18:48:37
Sun Nov 06 18:48:37 [initandlisten] MongoDB starting : pid=7108 port=27017 dbpath=/data/db 32-bit host=pykhmer-PC
Sun Nov 06 18:48:37 [initandlisten]
Sun Nov 06 18:48:37 [initandlisten] ** NOTE: when using MongoDB 32 bit, you are limited to about 2 gigabytes of data
Sun Nov 06 18:48:37 [initandlisten] **       see https://blog.mongodb.org/post/137788967/32-bit-limitations
Sun Nov 06 18:48:37 [initandlisten] **       with –journal, the limit is lower
Sun Nov 06 18:48:37 [initandlisten]
Sun Nov 06 18:48:37 [initandlisten] db version v2.0.1, pdfile version 4.5
Sun Nov 06 18:48:37 [initandlisten] git version: 3a5cf0e2134a830d38d2d1aae7e88cac31bdd684
Sun Nov 06 18:48:37 [initandlisten] build info: windows (5, 1, 2600, 2, ‘Service Pack 3’) BOOST_LIB_VERSION=1_42
Sun Nov 06 18:48:37 [initandlisten] options: {}
Sun Nov 06 18:48:37 [initandlisten] exception in initAndListen: 10296 dbpath (/data/db) does not exist, terminating
Sun Nov 06 18:48:37 dbexit:
Sun Nov 06 18:48:37 [initandlisten] shutdown: going to close listening sockets…
Sun Nov 06 18:48:37 [initandlisten] shutdown: going to flush diaglog…
Sun Nov 06 18:48:37 [initandlisten] shutdown: going to close sockets…
Sun Nov 06 18:48:37 [initandlisten] shutdown: waiting for fs preallocator…
Sun Nov 06 18:48:37 [initandlisten] shutdown: closing all files…
Sun Nov 06 18:48:37 [initandlisten] closeAllFiles() finished
Sun Nov 06 18:48:37 dbexit: really exiting now
E:mongobin&gt;mongo
MongoDB shell version: 2.0.1
connecting to: test
Sun Nov 06 18:48:42 Error: couldn’t connect to server 127.0.0.1 shell/mongo.js:84
exception: connect failed
E:mongo&gt;ls
GNU-AGPL-3.0  README  THIRD-PARTY-NOTICES  bin  data</p>
</li>
</ul>
<p>I was looking at</p>
<p><a href="https://www.mongodb.org/display/DOCS/Quickstart+Windows">https://www.mongodb.org/display/DOCS/Quickstart+Windows</a></p>
<p>and following the instructions. Could anyone tell me what is the problem with running MongoDB (I am using Windows 7)?<br>
I think your log output states it clearly;</p>
<p>exception in initAndListen: 10296 dbpath (/data/db) does not exist, terminating<br>
You may simply create this directory or better to define it as a configuration value within your configuration file then use it as mongod -f C:pathtoyourmongodb.conf.<br>
After you’ve installed MongoDB you should firstly create a data directory for your db.<br>
By default MongoDB will store data in /data/db,<br>
but it won’t automatically create that directory. To create it, do:</p>
<pre><code>$ sudo mkdir -p /data/db/
$ sudo chown `id -u` /data/db
</code></pre>
<p>You can also tell MongoDB to use a different data directory,<br>
with the –dbpath option.<br>
For more detailed information go to MongoDB wiki page.<br>
Specify the database path explicitly like so, and see if that resolves the issue.</p>
<pre><code>mongod –dbpath data/db
mongod –dbpath “c://data/db”
</code></pre>
<p>run the above code, this will start the server.<br>
Check that path to database data files exists :<br>
Sun Nov 06 18:48:37 [initandlisten] <strong>exception</strong> in initAndListen: 10296 <strong>dbpath (/data/db) does not exist,</strong> terminating</p>
</div><hr><h3><p>MongoDB: Mapreduce: reduce-&gt;multiple not supported yet</p>
</h3><div><ul>
<li>
<p>I have a MongoDB collection (named “catalog”) containing about 5 astronomical catalogs. Several of these catalogs reference each other, so one of the the documents might look something like this:</p>
<p>{ “_id” : ObjectId(“4ec574a68e4e7a519166015f”), “bii” : 20.9519, “class” : 2480, “cpdname” : “CPD -21 6109”, “decdeg” : -21.8417, “decpm” : 0.004, “dmname” : “-21 4299”, “hdname” : “HD 145612”, “lii” : 352.8556, “name” : “PPM 265262”, “ppmname” : “PPM 265262”, “radeg” : 243.2005, “rapm” : 0.0012, “vmag” : 9.6, “xref” : [ ] }</p>
</li>
</ul>
<p>What I want to do is use mapreduce to move the fields such as “hdname”,”ppmname”, etc into the xref array (then unset them).<br>
So I try to do this one at a time, starting with the hdname field. Here are the map and reduce functions:</p>
<pre><code>Skip code block
map = function() {
for (var hdname in this.hdname) {
emit(this._id,this.hdname);
}
}
reduce = function(key, values) {
var result = [];
for (var hdname in values) {
result.push(hdname);
}
return result;
}
</code></pre>
<p>I try running the following command in the mongo shell:<br>
db.catalog.mapReduce(map, reduce,”catalog2?);<br>
Unfortunately, I get the following error:<br>
Thu Nov 17 15:52:17 uncaught exception: map reduce failed:</p>
<pre><code>{
“assertion” : “reduce -&gt; multiple not supported yet”,
“assertionCode” : 10075,
“errmsg” : “db assertion failure”,
“ok” : 0
}
</code></pre>
<p>Obviously I’m a newbie… can anyone help?<br>
Jason<br>
The documentation says “Currently, the return value from a reduce function cannot be an array (it’s typically an object or a number).”<br>
So create an object instead and wrap your array in that. Make sure also that the output of reduce is the same as the input type, so you’ll need to emit a similar value in the map operation.<br>
BUT … why use Map-Reduce to do this? If you emit the _id value there’s nothing to reduce as each key will be unique. Why not just iterate over the collection copying the values and updating each record one by one?</p>
</div><hr><h3><p>MongoDB sorting</p>
</h3><div><ul>
<li>
<p>I want implement a “bump” feature for topics. Once a topic is bumped, it will have a new “bump_date” field. I want to sort it so that when there is a “bump_date” field, it will be sorted as if it was the “created” field. Here’s an example of my db.topics:</p>
<p>Skip code block
{
“text” : “test 1”,
“created” : “Sun Nov 20 2011 02:03:28 GMT-0800 (PST)”
},
{
“text” : “test 2”,
“created” : “Sun Nov 18 2011 02:03:28 GMT-0800 (PST)”
},
{
“text” : “test 3”,
“created” : “Sun Nov 17 2011 02:03:28 GMT-0800 (PST)”,
“bump_date: : “Sun Nov 19 2011 02:03:28 GMT-0800 (PST)”
}</p>
</li>
</ul>
<p>I want the sort to return in the order of “test 1”, “test 3”, “test 2”<br>
Sorting in MongoDB is done like so:<br>
db.collection.find({ … spec … }).sort({ key: 1 })<br>
where 1 is ascending and -1 is descending.<br>
In your specific example: db.topics.find().sort({ bump_date: 1 }), although it might be better to call it something like “updated_at”.<br>
You’ll also definitely want to put an index on your “bump_date” field.</p>
<pre><code>sorting: https://www.mongodb.org/display/DOCS/Sorting+and+Natural+Order
indexes: https://www.mongodb.org/display/DOCS/Indexes
</code></pre>
<p>As Brian Hicks suggested, creating an additional updated_at field is the way to go. This way, when a document is created you can have created_at and updated_at initially be the same.</p>
<pre><code>{
“created_at”: xxx,
“updated_at”: xxx
}
</code></pre>
<p>If you then “bump” the updated_at field by setting it to the current time when there is a a bump event you can sort on the updated_at field to achieve the ordering you desire.</p>
</div><hr><h3><p>MongoDB inserts float when trying to insert integer</p>
</h3><div><ul>
<li></li>
</ul>
<pre><code>&gt; db.data.update({‘name’: ‘zero’}, {‘$set’: {‘value’: 0}})
&gt; db.data.findOne({‘name’: ‘zero})
{‘name’: ‘zero’, ‘value’: 0.0}
</code></pre>
<p>How do I get Mongo to insert an integer?<br>
Thank you</p>
<pre><code>db.data.update({‘name’: ‘zero’}, {‘$set’: {‘value’: NumberInt(0)}})
</code></pre>
<p>You can also use NumberLong.</p>
</div><hr><h3><p>Mongodb : $in operator vs lot of single queries</p>
</h3><div><ul>
<li>I know mongo is able to handle a lot of requests/sec, but let’s say I have to query a lot of documents of a collection given their _id; what sounds better, making a $in on the _id attribute with all the ids I want to get, or loop over findOne queries?<br>
Thanks by advance :)</li>
</ul>
<p>I would definitely go with using the $in query and providing a array of _ids instead of looping unless the documents are large and returning them all in a single query would go over the size limit of 4mb (16mb on more recent versions of MongoDB)<br>
Example:</p>
<pre><code>db.collection.find({
“key”: { “$in”: [
ObjectId(“xxx”),
ObjectId(“yyy”),
ObjectId(“zzz”)
]}}
)
</code></pre>
<p>Why?<br>
1. If you loop, there is a certain amount of setup and teardown for each query creating and exhausting cursors which would create overhead.<br>
2. If you are not doing this on a local machine it also creates tcp/ip overhead for every request. Locally you could use domain sockets.<br>
3. There is a index on “_id” created by default and collecting a group of documents to return in a batch request should be extremely fast so there is no need to break this up into smaller queries.<br>
There’s some additional documentation here if you want to check it out.</p>
</div><hr><h3><p>Mongodb – How to find string in multiple fields?</p>
</h3><div><ul>
<li>
<p>Using Pymongo for this scenario.<br>
I have User that has email, first_name, last_name.<br>
I am using this Pymongo snippet:</p>
<p>user_found = users.find({‘$or’:[
{’email’:{‘$regex’:searchString, ‘$options’:’i’}},
{‘first_name’:{‘$regex’:searchString, ‘$options’:’i’}},
{‘last_name’:{‘$regex’:searchString, ‘$options’:’i’}}]})</p>
</li>
</ul>
<p>this example works, if I want to find searchString in:<br>
1. email, or<br>
2. first_name, or<br>
3. last_name<br>
now I need to also find searchString in first_name + last_name combined.<br>
how can I do that? Is there a way in mongo, through the query, to combine the two into a “fullname” then search the fullname?<br>
Easiest way is to add an array field and populate it with all of the variants that you want to search on. Index that array field.</p>
<p>That way you only need one index and your search across all fields is simple and doesn’t change when you want to search on some new search variant. You can also normalize the text you put into the search array, for example, lower casing it, removing punctuation etc.</p>
<p>See https://stackoverflow.com/q/8206188/224370</p>
<p>Edit: MongoDB’s documentation now covers keyword search and the new full-text search feature.</p>
</div><hr><h3><p>Get BinData UUID from Mongo as string</p>
</h3><div><ul>
<li>I currently have some ids stored in Mongo as UUIDs (necessary for processing). They get returned like this:<br>
“_id” : new BinData(3, “JliB6gIMRuSphAD2KmhzgQ==”)<br>
What would be an easy way to turn this value into a string for debugging?<br>
Just to be clear – the application can handle the data fine. I just need a way to get the actual UUID from Mongo quickly.</li>
</ul>
<p>The answer to your question is more complicated that you would expect! The main reason it’s complicated is that for historical reasons (unfortunately) different drivers have written UUIDs to the database using different byte orders. You don’t mention which driver you are using, but I’ll use the C# driver as an example.<br>
Suppose I use the following code to insert a document:</p>
<pre><code>var guid = new Guid(“00112233-4455-6677-8899-aabbccddeeff”);
collection.Insert(new BsonDocument {
{ “_id”, guid },
{ “x”, 1 }
});
If I then examine the document using the Mongo shell, it looks like this:
&gt; db.test.findOne()
{ “_id” : BinData(3,”MyIRAFVEd2aImaq7zN3u/w==”), “x” : 1 }
&gt;
The Mongo shell has a built-in function called hex that you can use to display the binary value as a hex string:
&gt; var doc = db.test.findOne()
&gt; doc._id.hex()
33221100554477668899aabbccddeeff
&gt;
</code></pre>
<p>Look carefully: the byte order of the hex string doesn’t match the original UUID value used in the C# program. That’s because the C# driver uses the byte order returned by Microsoft’s ToByteArray method of the Guid class (which sadly returns the bytes in a bizarre order, which fact was not discovered for many months). Other drivers have their own idiosyncracies.<br>
To help out with this we have some helper functions written in Javascript that can be loaded into the Mongo shell. They are defined in this file:</p>
<p>https://github.com/mongodb/mongo-csharp-driver/blob/master/uuidhelpers.js</p>
<p>The Mongo shell can be told to process a file as it starts up by providing the name of the file on the command line (along with the –shell argument). Having loaded this file we have access to a number of helper functions to create and display BinData values that are UUIDs. For example:</p>
<p>C:mongodbmongodb-win32-x86_64-2.0.1bin&gt;mongo –shell uuidhelpers.js</p>
<p>MongoDB shell version: 2.0.1<br>
connecting to: test<br>
type “help” for help</p>
<pre><code>&gt; var doc = db.test.findOne()
&gt; doc._id.toCSUUID()
CSUUID(“00112233-4455-6677-8899-aabbccddeeff”)
&gt; db.test.find({_id : CSUUID(“00112233-4455-6677-8899-aabbccddeeff”)})
{ “_id” : BinData(3,”MyIRAFVEd2aImaq7zN3u/w==”), “x” : 1 }
&gt;
</code></pre>
<p>In this example the toCSUUID function is used to display a BinData value as a CSUUID and the CSUUID function is used to create a BinData value for a UUID using the C# driver’s byte ordering conventions so that we can query on a UUID. There are similar functions for the other drivers (toJUUID, toPYUUID, JUUID, PYUUID).<br>
Some day in the future all drivers will standardize on a new binary subtype 4 with a standard byte order. In the meantime you have to use the appropriate helper function that matches whatever driver you are using.</p>
</div><hr><h3><p>All columns in MongoDB</p>
</h3><div><ul>
<li>I was wondering how you would find all of the column names in a table in MongoDB, like how you use SHOW COLUMNS FROM foo; in mysql.<br>
MongoDB is schemaless and does not have tables. In MongoDB, each collection can have different types of items. You could store two very different items in the same collection:<br>
db.test.insert( { “SomeString” : “How much wood would the woodchop chop …” } );<br>
db.test.insert( { “Amount”: 2040.20, “Due”: new ISODate(“2012-11-10”), “UserId” : new ObjectId(“…”)} );<br>
usually the objects are somehow related or have a common base type, but it’s not required.<br>
You can, however, take a look at invidual records using<br>
db.collectionName.findOne()<br>
or<br>
db.collectionName.find().pretty()<br>
However, there’s no guarantee from MongoDB that any two records look alike or have the same fields: <strong>there’s no schema.</strong></li>
</ul>
</div><hr><h3><p>Can’t map file memory in MongoDB</p>
</h3><div><ul>
<li>The windows server 2003 box hosting our MongoDB instance ran out of disk space, and Mongo started generating the error:<br>
<strong>Can’t map file memory.</strong><br>
After adding additional disk space to the server and restarting the MongoDB windows service, any operation against the database still generates the “Can’t map file memory” error. I tried doing a repair even and it gives the same error:</li>
</ul>
<p><strong>&gt; db.repairDatabase(); { “assertion” : “can’t map file memory”, “assertionCode” : 10085, “errmsg” : “db assertion failure”, “ok” : 0 }</strong></p>
<p>Any idea what I can do to get my database operational again??<br>
Stopping the service, deleting the lock file, and then doing a mongod –repair worked, even though db.repairDatabase did not.</p>
<p>The answer from Justin worked for me.<br>
Here are some more detailed instructions for Ubuntu:<br>
Stop Mongo Service: sudo service mongodb stop<br>
Delete Lock File: sudo rm /var/lib/mongodb/mongod.lock<br>
Repair the DB: sudo mongod –repair –dbpath=/var/lib/mongodb<br>
Restart the Mongo Service: sudo service mongodb start<br>
Hope that helps someone.<br>
(edited – note that mongodb is the service name, but mongod is the correct command for repairing)</p>
</div><hr><h3><p>Why does MongoDB have collections</p>
</h3><div><ul>
<li>MongoDB being document-oriented, the structure of collections seems to be a special case of documents. By that I mean one can define a document to contain other documents. So a collection is just a document containing other documents.<br>
So why do we need collections after all?<br>
Logically yes, you could design a database system like that, but practically speaking no.<br>
1. A collection has indexes on the documents in it.<br>
2. A collection requires the documents in it to have unique ids.<br>
3. A document is limited in size.</li>
</ul>
</div><hr><h3><p>How to update a field in MongoDB using existing value</p>
</h3><div><ul>
<li>
<p>I’ve been looking for a way to create an update statement that will take an existing numeric field and modify it using an expression. For example, if I have a field called Price, is it possible to do an update that sets Price to 50% off the existing value ?<br>
So, given { Price : 19.99 }<br>
I’d like to do db.collection.update({tag : “refurb”}, {$set {Price : Price * 0.50 }}, false, true);<br>
Can this be done or do I have to read the value back to the client, modify, then update ? I guess the question then is can expressions be used in update, and can they reference the document being updated. Thanks.</p>
<p>You can run server-side code with db.eval().
db.eval(function() {
db.collection.find({tag : “refurb”}).forEach(function(e) {
e.Price = e.Price * 0.5;
db.collection.save(e);
});
});</p>
</li>
</ul>
<p>Note this will block the DB, so it’s better to do find-update operation pair.</p>
<p>See <a href="https://www.mongodb.org/display/DOCS/Server-side+Code+Execution">https://www.mongodb.org/display/DOCS/Server-side+Code+Execution</a></p>
<p>As of the release notes from upcoming Mongo 2.6 you would be able to use the new $mul operator. It would multiply the value of the field by the number with the following syntax.</p>
<pre><code>{
field: { $mul: }
}
So in your case you will need to do the following:
db.collection.update(
{ tag : “refurb”},
{ $mul: { Price : 0.5 } }
);
</code></pre>
</div><hr><h3><p>MongoDB $where queries and tailable cursors — WAS: date math best practices</p>
</h3><div><ul>
<li>My problem: give me a list of documents older than X amount of time.<br>
If I have a document created with:<br>
db.dates.insert({date: new Date()});<br>
And now I want to find it only when the “date” has become 30 minutes old:<br>
db.dates.find({ $where: “this.date.getTime() + 30 * 60000 &lt;= new Date()”});<br>
This works, but in the Mongo documentation states quite clearly that there is a significant performance penalty to $where queries.<br>
Thus the question, is there a better way?</li>
</ul>
<p>==========UPDATE 1==========<br>
I should have added that I am hoping to have this query function “dynamically” be creating the query one time and using it to obtain a tailable cursor on a capped collection… and I am not sure any longer that it is actually possible.<br>
I will test and repost.</p>
<p>==========UPDATE 2==========<br>
So, looks like my “delayed” queue is going to have to be handled in code, either with polling or some “check, then sleep” algorithm, because that appears to be what mongo’s delayed replication is doing (from db.cpp):</p>
<pre><code>Skip code block
if ( replSettings.slavedelay &amp;&amp; ( unsigned( time( 0 ) ) &lt; nextOpTime.getSecs() + replSettings.slavedelay) ) {
assert( justOne );
oplogReader.putBack( op );
_sleepAdviceTime = nextOpTime.getSecs() + replSettings.slavedelay + 1;
dblock lk;
if ( n &gt; 0 ) {
syncedTo = last;
save();
}
log() &lt;&lt; “repl:   applied ” &lt;&lt; n &lt;&lt; ” operations” &lt;&lt; endl;
log() &lt;&lt; “repl:   syncedTo: ” &lt;&lt; syncedTo.toStringLong() &lt;&lt; endl;
log() &lt;&lt; “waiting until: ” &lt;&lt; _sleepAdviceTime &lt;&lt; ” to continue” &lt;&lt; endl;
return okResultCode;
}
</code></pre>
<p>The $lte operator (and other range queries) will work and utilize indexes, but it cannot evaluate expressions. You have to query against a query-time constant (which would be ‘now – 30 min’):<br>
var threshold = new Date();<br>
threshold.setMinutes(-30);<br>
// now, query against a constant:<br>
db.dates.find({“date” : {$lte : threshold}});<br>
Of course, you can do the same with any driver for any programming language, e.g. C#</p>
<pre><code>var c = db.Collection.Find(Query.LTE(“date”, DateTime.UtcNow.AddMinutes(-30));
</code></pre>
</div><hr><h3><p>How to implement post tags in Mongo?</p>
</h3><div><ul>
<li>
<p>I’m toying with Mongo to make a SO-like pet project, and I want to implement post tags. Each tag has a name and a slug (string to be used as an id in the URL), and a post has multiple tags. I’d like to be able to create queries like “find posts, which have tag A, don’t have tag B”, and I’m wondering what’s the mongo-way to do this.<br>
One way is to store an array of tag ids with each post – this will make the said query easy, but will require an extra one for each post to get tag name and a slug. Another way is to store an array of [tag name, tag slug] with each post, but I’m not sure I’ll be able to use that info in a find.<br>
Is there some other method, which will work better for mongo? I’m new to NoSQL, so I’d appreciate any advise on how this can be accomplished. Also, I’m using PHP binding, but that shouldn’t matter probably.<br>
If the tags you use and their respective slugs are unlikely to change, I think your second approach is the better one. However I would suggest a small change – rather than storing an array of [name, slug], make the fields explicit by creating a tag subdocument as in this example post document:</p>
<p>Skip code block
{
“_id” : ObjectId(“4ee33229d8854784468cda7e”),
“title” : “My Post”,
“content” : “This is a post with some tags”,
“tags” : [
{
“name” : “meta”,
“slug” : “34589734”
},
{
“name” : “post”,
“slug” : “34asd97x”
},
]
}</p>
</li>
</ul>
<p>You can then query for posts with a particular tag using dot notation like this:</p>
<pre><code>db.test.find({ “tags.name” : “meta”})
</code></pre>
<p>Because tags is an array, mongo is clever enough to match the query against any element of the array rather than the array as a whole, and dot-notation allows you to match against a particular field.<br>
To query for posts not containing a specific tag, use $ne:</p>
<pre><code>db.test.find({ “tags.name” : { $ne : “fish” }})
And to query for posts containing one tag but not the other, use $and:
db.test.find({ $and : [{ “tags.name” : { $ne : “fish”}}, {“tags.name” : “meta”}]})
</code></pre>
<p>Hope this helps!</p>
</div><hr><h3><p>What operations are cheap/expensive in mongodb?</p>
</h3><div><p>I’m reading up on MongoDB, and trying to get a sense of where it’s best used. One question that I don’t see a clear answer to is which operations are cheap or expensive, and under what conditions.<br>
Can you help clarify?<br>
Thanks.<br>
It is often claimed that mongodb has insanely fast writes. While they are not slow indeed, this is quite an overstatement. Write throughput in mongodb is limited by global write lock. Yes, you heard me right, there can be only <strong>ONE</strong> write operation happening on the server at any given moment.<br>
Also I suggest you take advantage of schemaless nature of mongodb and store your data denormalized. Often it is possible to do just one disk seek to fetch all required data (because it is all in the same document). Less disk seeks – faster queries.<br>
If data sits in RAM – no disk seeks are required at all, data is served right from memory. So, make sure you have enough RAM.<br>
Map/Reduce, group, $where queries are slow.<br>
It is not fast to keep writing to one big document (using $push, for example). The document will outgrow its disk boundaries and will have to be copied to another place, which involves more disk operations.<br>
And I agree with @AurelienB, some basic principles are universal across all databases.</p>
</div><hr><h3><p>MongoDB: Find a document by non-existence of a field?</p>
</h3><div><p>Is there a way to specify a condition of “where document doesn’t contain field” ?<br>
For example, I want to only find the first of these 2 because it doesn’t have the “price” field.</p>
<pre><code>{“fruit”:”apple”, “color”:”red”}
{“fruit”:”banana”, “color”:”yellow”, “price”:”2.00?}
db.mycollection.find( { “price” : { “$exists” : false } } )
</code></pre>
<p>nostalgic URL : https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-%24exists<br>
updated URL: https://docs.mongodb.org/manual/reference/operator/query/exists/#op._S_exists</p>
</div><hr><h3><p>How to remove deprecated fields in Mongo?</p>
</h3><div><p>I have removed some fields from document definition. I want to remove this field across all documents of collection. How can I do it?<br>
Try:</p>
<pre><code>db.collection.update(
{ ‘’: { ‘$exists’: true } },  // Query
{ ‘$unset’: { ‘’: true  } },  // Update
false, true                          // Upsert, Multi
)
</code></pre>
<p>where field is your deprecated field and collection is the collection it was removed from.<br>
The general update command is of the form db.collection.update( criteria, objNew, upsert, multi ). The false and true trailing arguments disable upsert mode and enable multi update so that the query updates all of the documents in the collection (not just the first match).</p>
<p><strong>Update for MongoDB 2.2+:</strong></p>
<p>You can now provide a JSON object instead of positional arguments for upsert and multi.</p>
<pre><code>db.collection.update(
{ ‘’: { ‘$exists’: true } },  // Query
{ ‘$unset’: { ‘’: true  } },  // Update
{ ‘multi’: true }                    // Options
)
just do something like this
db.people.find().forEach(function(x) {
delete x.badField;
db.people.save(x);
})
</code></pre>
<p>oooh the $unset answer someone gave using update() here is pretty awesome too.</p>
</div><hr><h3><p>Combine two $or statements</p>
</h3><div><p>I am trying to perform a query which is composed of two $or’s:</p>
<pre><code>|——————–
| Date1  |  Date2   |
|——————–
| NULL   |  NULL    | *
| NULL   |  TODAY   | *
| NULL   |  TOMRW   |
| TODAY  |  TODAY   | *
| TODAY  |  NULL    | *
| TOMRW  |  NULL    |
|——————–
(I’ve marked the rows that would match with an asterisk)
(Date1 == null || Date1 &lt;= today) &amp;&amp; (Date2 == null || Date2 &lt;= today)
</code></pre>
<p>I am not sure how to express this query in MongoDB.<br>
It can be broken down into two individual queries that do exactly what they should:<br>
Skip code block</p>
<pre><code>{
“$or”: [{
“Date1”: {
“$exists”: false
}
},
{
“Date1”: {
“$exists”: true,
“$lte”: new Date(“2012-01-07T04:45:52.057Z”)
}
}]
}
and
Skip code block
{
“$or”: [{
“Date2”: {
“$exists”: false
}
},
{
“Date2”: {
“$exists”: true,
“$lte”: new Date(“2012-01-07T04:45:52.057Z”)
}
}]
}
</code></pre>
<p>Both of these select the correct set of documents – I just dont know how to execute them as a single query.<br>
My initial thought was to do a query like this:</p>
<pre><code>{
$and: [orQuery1, orQuery2]
}
</code></pre>
<p>Using an $and query returns 0 results. It was explained why here in this thread: $and query returns no result<br>
Also in that thread, a suggestion was made to do a query like this:</p>
<pre><code>{
Key: {valToMatch1: 1, valToMatch2: 2}
}
</code></pre>
<p>But I dont think an $or can be executed this way.<br>
So, the question is: How do I construct my query such that I can combine the two $or’s into a single query?<br>
(Its getting very late so I hope this question makes sense.)<br>
use test</p>
<pre><code>db.test.insert({a:1})
db.test.insert({a:2, Date2:new Date(“01/07/2012”)})
db.test.insert({a:3, Date2:new Date(“01/08/2012”)})
db.test.insert({a:4, Date1:new Date(“01/07/2012”), Date2:new Date(“01/07/2012”)})
db.test.insert({a:5, Date1:new Date(“01/07/2012”)})
db.test.insert({a:6, Date1:new Date(“01/08/2012”)})
first subquery db.test.distinct(‘a’, {…});
[1, 2, 3]
second subquery db.test.distinct(‘a’, {…});
[ 1, 5, 6 ]
(Date1 == null || Date1 &lt;= today) &amp;&amp; (Date2 == null || Date2 &lt;= today)
unwind
Date1 == null &amp;&amp; Date2 == null ||
Date1 == null &amp;&amp; Date2 &lt;= today ||
Date1 &lt;= today &amp;&amp; Date2 == null ||
Date1 &lt;= today &amp;&amp; Date2 &lt;= today ||
query
Skip code block
db.test.find(
{
$or :
[
{$and: [
{“Date1”: {“$exists”: false}},
{“Date2”: {“$exists”: false}}
]},
{$and: [
{“Date1”: {“$exists”: false}},
{“Date2”: {
“$exists”: true,
“$lte”: new Date(“2012-01-07T04:45:52.057Z”)}
}
]},
{$and: [
{“Date2”: {“$exists”: false}},
{“Date1”: {
“$exists”: true,
“$lte”: new Date(“2012-01-07T04:45:52.057Z”)}
}
]},
{$and: [
{“Date2”: {
“$exists”: true,
“$lte”: new Date(“2012-01-07T04:45:52.057Z”)}
},
{“Date1”: {
“$exists”: true,
“$lte”: new Date(“2012-01-07T04:45:52.057Z”)}
}
]}
]
})
&gt;[ 1 ]
</code></pre>
<p>this should work too (assume that ‘not exist’ and ‘null’ is the same)</p>
<pre><code>Skip code block
db.test.find(
{
$and :
[
{$or: [
{“Date1”: null},
{“Date1”: { “$lte”: new Date(“2012-01-07T04:45:52.057Z”)} }
]},
{$or: [
{“Date2”: null},
{“Date2”: { “$lte”: new Date(“2012-01-07T04:45:52.057Z”)} }
]}
]
}
)
</code></pre>
</div><hr><h3><p>mongodb: how to do backup of mongodb</p>
</h3><div><ul>
<li>I think someone has already suggested:<br>
1. stop the mongod<br>
2. backup the data directory<br>
Is it reliable, I mean, ensure 100% success to restore? And I can’t find which directory stores the data… any command can help me to find it?<br>
If mongod process exits cleanly (that is, no crashes or kill -9 stuff), then it is safe to copy data files somewhere.<br>
If your current installation breaks (for example, data corruption due to unclean shutdown), you can delete its files, copy that backup over and start mongod again.<br>
Default data directory is /data/db, but it may be set to another value in your config file. For example, I set it to /var/lib/mongodb.<br>
You can also use mongodump to do a backup from a live server (this may impact performance). Usemongorestore to restore backups made by mongodump.<br>
At IGN we do hot backups via mongodump running as an hourly cron job, and take filer snapshots (NetApp storage) on a half-hourly basis. If your system is not too write heavy and you can afford write blocks, try using fsync and lock to flush the writes to the disk and prevent further writes. This can be followed by mongodump and upon completion you can unlock the db. Please note that you’ve to be admin to do so.<br>
db.runCommand({fsync:1,lock:1})</li>
</ul>
</div><hr><h3><p>How to update date field in mongo console?</p>
</h3><div><ul>
<li>For example I want to update all records to</li>
</ul>
<p>‘2012-01-01’ ( “time” : ISODate(“2011-12-31T13:52:40Z”) ).</p>
<pre><code>db.test.update( { time : ‘2012-01-01’ }, false, true  )
return error:
Assert failed : need an object
Error(“Printing Stack Trace”)@:0
()@shell/utils.js:35
(“assert failed : need an object”)@shell/utils.js:46
(false,”need an object”)@shell/utils.js:54
([object Object],false,true)@shell/collection.js:189
@(shell):1
Wed Jan 11 17:52:35 uncaught exception: assert failed : need an object
</code></pre>
<p>You need to create a new ISODate object like this:</p>
<p>db.test.insert({“Time” : new ISODate(“2012-01-10”) });</p>
<p>This is true both for updates and for queries. Note that your query syntax is incorrect, it should be</p>
<pre><code>db.test.update({ criteria }, { newObj }, upsert, multi);
For example, to update all objects, consider
db.test.update( {}, { $set : { “time” : new ISODate(“2012-01-11T03:34:54Z”) } }, true, true);
Also note that this is very different from
db.test.update( {}, { “time” : new ISODate(“2012-01-11T03:34:54Z”) }, true, false);
</code></pre>
<p>because the latter will <strong>replace</strong> the object, rather than add a new field to the existing document or updating the existing field. In this example, I changed the last parameter to false, because multi updates only work with $ operators.</p>
</div><hr><h3><p>return query based on date</p>
</h3><div><ul>
<li>I have a data like this in mongodb</li>
</ul>
<p>{ “latitude” : “”, “longitude” : “”, “course” : “”, “battery” : “0”, “imei” : “0”, “altitude” : “F:3.82V”, “mcc” : “07”, “mnc” : “007B”, “lac” : “2A83”, “_id” : ObjectId(“4f0eb2c406ab6a9d4d000003”), “createdAt” : ISODate(“2012-01-12T20:15:31Z”) }</p>
<p>How to query db.gpsdatas.find({‘createdAt’: ??what here??}) so that it return me the above result from db?<br>
You probably want to make a range query, for example, all items created after a given date:</p>
<pre><code>db.gpsdatas.find({“createdAt” : { $gte : new ISODate(“2012-01-12T20:15:31Z”) }});
</code></pre>
<p>I’m using $gte (greater than or equals), because this is often used for date-only queries, where the time component is 00:00:00.<br>
If you really want to find a date that equals another date, the syntax would be</p>
<pre><code>db.gpsdatas.find({“createdAt” : new ISODate(“2012-01-12T20:15:31Z”) });
</code></pre>
</div><hr><h3><p>MongoDB query comparing 2 fields in same collection without $where</p>
</h3><div><ul>
<li>Does MongoDB supports comparing two fields in same collection by using native operators (not $where and JavaScript)? I already looked at similar questions and all answers used $where / JavaScript.<br>
MongoDB documentation clearly states that:<br>
JavaScript executes more slowly than the native operators listed on this page, but is very flexible.<br>
My primary concern is speed and I would like to use indexes if possible. So is comparing two fields in MongoDB possible without using JavaScript?<br>
This is not currently possible, but it will be possible through the new aggregation framework currently under development (2.1+). This aggregation framework is native and does not rely on relatively slow JavaScript execution paths.<br>
For more details check</li>
</ul>
<p>https://www.mongodb.org/display/DOCS/Aggregation+Framework and the progress at https://jira.mongodb.org/browse/SERVER-447</p>
</div><hr><h3><p>Upserts in mongodb when using custom _id values</p>
</h3><div><ul>
<li>
<p>I need to insert a document if it doesn’t exist. I know that the “upsert” option can do that, but I have some particular needs.<br>
First I need to create the document with its _id field only, but only if it doesn’t exist already. My _id field is a number generated by me (not an ObjectId). If I use the “upsert” option then I get “Mod on _id not allowed”</p>
<p>db.mycollection.update({ _id: id }, { _id: id }, { upsert: true });</p>
</li>
</ul>
<p>I know that we can’t use the _id in a $set.<br>
So, my question is: If there any way to a “create if doesn’t exists” atomically in mongodb?<br>
EDIT: As proposed by @Barrie this works (using nodejs and mongoose):</p>
<pre><code>var newUser = new User({ _id: id });
newUser.save(function (err) {
if (err &amp;&amp; err.code === 11000) {
console.log(‘If duplicate key the user already exists’, newTwitterUser);
return;
}
console.log(‘New user or err’, newTwitterUser);
});
</code></pre>
<p>But I still wonder if it is the best way to do it.<br>
You can just use insert(). If the document with the _id you specify already exists, the insert() will fail, nothing will be modified – so “create if it doesn’t exist” is what it’s already doing by default when you use insert() with a user-created _id.<br>
I had the same problem, but found a better solution for my needs. You can use that same query style if you simply remove the _id attribute from the update object. So if at first you get an error with this:</p>
<pre><code>db.mycollection.update({ _id: id }, {$set: { _id: id, name: ‘name’ }}, { upsert: true });
</code></pre>
<p>instead use this:</p>
<pre><code>db.mycollection.update({ _id: id }, {$set: { name: ‘name’ }}, { upsert: true });
</code></pre>
<p>This is better because it works for both insert and update.</p>
</div><hr><h3><p>How to list all collections in the mongo shell?</p>
</h3><div><ul>
<li>
<p>In the MongoDB shell, how do I list all collections for the current database that I’m using? I can’t seem to find it anywhere in the docs.<br>
You can do:</p>
<p>db.getCollectionNames()</p>
<blockquote>
<p>show collections</p>
</blockquote>
</li>
</ul>
<p>will list all the collections in the currently selected DB, as stated in the command line help (help).<br>
&gt; show tables<br>
It gives the same result as Cameron’s answer.<br>
Apart from the options suggested by other people:<br>
show collections &nbsp;//output every collection<br>
show tables<br>
db.getCollectionNames() //shows all collections as a list<br>
There is also another way which can be really handy if you want to know how each of the collections was created (for example it is a capped collection with a particular size)<br>
db.system.namespaces.find()<br>
To list all databases<br>
show dbs<br>
enters or uses given database<br>
use databasename<br>
To list all collections:<br>
show collections<br>
Output:</p>
<pre><code>collection1
collection2
system.indexes
</code></pre>
<p>(or)<br>
s</p>
<pre><code>how tables
//output
collection1
collection2
system.indexes
</code></pre>
<p>(or)</p>
<pre><code>db.getCollectionNames()
//output
[ “collection1”, “collection2”, “system.indexes” ]
</code></pre>
<p>To enter or use given collection<br>
use collectionname</p>
</div><hr><h3><p>How to remove one document by Id using the official CSharp driver for Mongo</p>
</h3><div><p>. can someone please show me if there is a better way to remove one document from a MongoDB using the standard 10gen driver for C# than what I have below:<br>
var query = Query.EQ(“_id”, a.Id);<br>
database.GetCollection(“Animal”).Remove(query);<br>
The above works, but seems dirty and like too much work to me. The “Save” command for instance takes an instance and updates it. Perhaps I’m too used to things like EF/LINQToSQL/NHib where I’d say something like Remove(item).<br>
Am I missing something?<br>
(also, I’m trying to use the official driver rather than NoRM which seems to be dead or Samus which seems equally out of date.)<br>
That’s the way you do it. I’m sure you know this, but if you want to put it on one line you could combine it so you don’t need to define a query variable:<br>
collection.Remove(Query.EQ(“_id”, a.Id));<br>
If the [id] is string, you must use ObjectId instance explicitly.<br>
var query = Query.EQ(“_id”, ObjectId.Parse(id));</p>
</div><hr><h3><p>Clone a collection in MongoDB</p>
</h3><div><ul>
<li>
<p>I want to clone a MongoDB collection and save it on the same server with a different name. So for example right now I have the following collections: demo1.categories, demo1.users and demo2.users.<br>
I want to have a “demo2.categories” which is identical to “demo1.categories”. (It just has a different name.)<br>
Yet again the MongoDB documentation comes to the rescue<br>
assuming that the collection actually is named “demo1.categories”:</p>
<p>db.demo1.categories.find().forEach( function(x){db.demo2.categories.insert(x)} );</p>
</li>
</ul>
<p>The most simple &amp; efficient way is by using copyTo(), so you can use:<br>
db.source.copyTo(“target”);<br>
&amp; if “target” doesn’t exist, it will be created<br>
<strong>— Update —</strong><br>
According to CopyTo Documentation, Because copyTo() uses eval internally, the copy operations will block all other operations on the mongod instance. So it shouldn’t be used on production environment.</p>
</div><hr><h3><p>File write operations in mongo script?</p>
</h3><div><ul>
<li>
<p>Is this possible to write the query result to the file from mongo js script. I have searched a lot, but I didn’t find any solution.<br>
ex:-</p>
<p>cursor = db.users.find();
while(cursor.hasNext()) {
cursor.next();
// writing the cursor output to file ????
}
You could use print and then redirect output:
script.js:
cursor = db.users.find();
while(cursor.hasNext()){
printjson(cursor.next());
}</p>
</li>
</ul>
<p>then run the script and redirect output to a file:</p>
<p>mongo –quiet script.js &gt; result.txt</p>
<p>https://www.mongodb.org/display/DOCS/Scripting+the+shell</p>
<p>paragraph “Differences between scripted and interactive/ Printing”.</p>
<pre><code>./mongo server.com/mydb –quiet –eval “db.users.find().forEach(printjson);” &gt; 1.txt
</code></pre>
<p>you can skip the while loop using forEach :</p>
<pre><code>db.users.find().forEach( function(user){ printjson(user) });
</code></pre>
<p>P.S: I would haved added this answer as a comment to @milan’s answer but don’t have enough reputation yet to comment :p</p>
</div><hr><h3><p>Do arrays stored in MongoDB keep their order?</p>
</h3><div><ul>
<li>Simple question, do arrays keep their order when stored in MongoDB?<br>
yep MongoDB keeps the order of the array.. just like Javascript engines..<br>
Yes, in fact from a quick google search on the subject, it seems that it’s rather difficult to re-order them:</li>
</ul>
<p>https://groups.google.com/group/mongodb-user/browse_thread/thread/1df1654889e664c1</p>
</div><hr><h3><p>MongoDB: update every document on one field</p>
</h3><div><p>I have a collected named foo hypothetically.<br>
Each instance of foo has a field called lastLookedAt which is a UNIX timestamp since epoch. I’d like to be able to go through the MongoDB client and set that timestamp for all existing documents (about 20,000 of them) to the current timestamp.<br>
What’s the best way of handling this?<br>
In the Mongo shell, or with any Mongodb client, you can do something like that:<br>
<strong>For Mongodb &lt; 2.2:</strong></p>
<pre><code>db.foo.update({}, {$set: {lastLookedAt: Date.now() / 1000}}, false, true)
</code></pre>
<p><strong>For Mongodb &gt;= 2.2:</strong></p>
<pre><code>db.foo.update({}, {$set: {lastLookedAt: Date.now() / 1000}}, { multi: true })
</code></pre>
<p>See https://www.mongodb.org/display/DOCS/Updating</p>
<p>1. {}is the condition (the empty condition matches any document)<br>
2. {$set: {lastLookedAt: Date.now()}}is what you want to do<br>
3. falseis for the “upsert” parameter (insert if not present, or else update – not what you want)<br>
4. true is for the “multi” parameter (update multiple records)</p>
</div><hr><h3><p>How to check if Mongodb is properly installed</p>
</h3><div><ul>
<li>I installed MongoDb yesterday on a Mac Snow Leopard and got the following error message<br>
Mongo::ConnectionFailure: Failed to connect to a master node at localhost:27017<br>
when trying to run some tests in Rails that used a mongodb.<br>
Another SO question mongo – ruby connection problem about the same error message had an answer that recommended removing the lock file<br>
sudo rm /var/lib/mongodb/mongod.lock<br>
but when I run that command i’m getting<br>
No such file or directory<br>
Any ideas how I can figure out how to get it working or see if it’s properly installed?<br>
The easiest way to run mongodb on Mac OS is:<br>
Download binary package from</li>
</ul>
<p>https://www.mongodb.org/downloads,</p>
<p>for me, I am using lastest 64 bit version</p>
<p>(https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-2.0.2.tgz</p>
<p>1. mkdir -p $HOME/opt<br>
2. cd $HOME/opt<br>
3. wget https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-2.0.2.tgzto download the latest (2.0.2 for now) 64 bit binary package for Mac OS<br>
4. tar xf mongodb-osx-x86_64-2.0.2.tgz -C $HOME/optto unpack the package, and it will be unpacked to $HOME/opt/mongodb-osx-x86_64-2.0.2<br>
5. mkdir -p $HOME/opt/mongodatato create the data directory for mongodb<br>
6. $HOME/opt/mongodb-osx-x86_64-2.0.2/bin/mongod –dbpath=$HOME/opt/mongodata –7. logpath=$HOME/opt/mongod.logto start the mongodb daemon</p>
<p>7. Then you can run $HOME/opt/mongodb-osx-x86_64-2.0.2/bin/mongo to connect to your local mongodb service</p>
<p>You can also have https://www.mongodb.org/display/DOCS/Quickstart+OS+X as additional reference</p>
</div><hr><h3><p>In MongoDB, how to filter by location, sort by another field and paginate the results correctly?</p>
</h3><div><p>When i don’t use pagination, everything works fine (i have only 3 records in this collection, so all of them are listed here):</p>
<pre><code>db.suppliers.find({location: {$near: [-23.5968323, -46.6782386]}},{name:1,badge:1}).sort({badge:-1})
{ “_id” : ObjectId(“4f33ff549112b9b84f000070”), “badge” : 3, “name” : “Dedetizadora Alvorada” }
{ “_id” : ObjectId(“4f33ff019112b9b84f00005b”), “badge” : 2, “name” : “Sampex Desentupidora e Dedetizadora” }
{ “_id” : ObjectId(“4f33feae9112b9b84f000046”), “badge” : 1, “name” : “Higitec Desentupimento e Dedetizao” }
But when i try to paginate from the first to the second page, one record doesn’t show up and one is repeated:
db.suppliers.find({location: {$near: [-23.5968323, -46.6782386]}},{name:1,badge:1}).sort({badge:-1}).skip(0).limit(2)
{ “_id” : ObjectId(“4f33ff549112b9b84f000070”), “badge” : 3, “name” : “Dedetizadora Alvorada” }
{ “_id” : ObjectId(“4f33feae9112b9b84f000046”), “badge” : 1, “name” : “Higitec Desentupimento e Dedetizao” }
db.suppliers.find({location: {$near: [-23.5968323, -46.6782386]}},{name:1,badge:1}).sort({badge:-1}).skip(2).limit(2)
{ “_id” : ObjectId(“4f33feae9112b9b84f000046”), “badge” : 1, “name” : “Higitec Desentupimento e Dedetizao” }
</code></pre>
<p>Am i doing something wrong or is this some kind of bug?<br>
<strong>edit</strong>:<br>
Here is a workaround for this. Basically you shouldn’t mix $near queries with sorting; use $within instead.<br>
There is an open issue regarding the same problem. Please have a look &amp; vote Geospatial result paging fails when sorting with additional keys</p>
</div><hr><h3><p>Add a new field to a collection with value of an existing field</p>
</h3><div><p>I’d like to add a new field to a collection, with the value of the new field set to the value of an existing field.<br>
Specifically, I’d like to go from this:</p>
<pre><code># db.foo.findOne()
{
“_id”     : ObjectId(“4f25c828eb60261eab000000”),
“created” : ISODate(“2012-01-29T16:28:56.232Z”),
“…”     : …
}
to this:
# db.foo.findOne()
{
“_id”      : ObjectId(“4f25c828eb60261eab000000”),
“created”  : ISODate(“2012-01-29T16:28:56.232Z”),
“event_ts” : ISODate(“2012-01-29T16:28:56.232Z”),  #same as created
“…”      : …
}
(New documents in this collection won’t all have this peculiar redundancy, but I want to do this for my existing documents)
function addEventTsField(){
db.foo.find().forEach(function(doc){
db.foo.update({_id:doc._id}, {$set:{“event_ts”:doc.created}});
});
}
Run from console:
addEventTsField();
</code></pre>
</div><hr><h3><p>Mongodb update the specific element from subarray</p>
</h3><div><p>I have a collection with a following schema:</p>
<pre><code>Skip code block
{
“_id” : 28,
“n” : [{
“a” : ObjectId(“4ef8466e46b3b8140e000000”),
“c” : 28,
“p” : [ObjectId(“4f00640646b3b88005000003”), ObjectId(“4f00640146b3b88005000002”), ObjectId(“4f00637d46b3b8cc0e000001”), ObjectId(“4f00638046b3b8cc0e000002”), ObjectId(“4f00638246b3b8cc0e000003”), ObjectId(“4f00631646b3b85002000001”), ObjectId(“4f00631846b3b85002000002”)],
“u” : 26
}, {
“a” : ObjectId(“4ef8466e46b3b8140e000000”),
“c” : 10,
“p” : [ObjectId(“4f00640146b3b88005000002”), ObjectId(“4f0063fd46b3b88005000001”)],
“u” : 26
}, {
“a” : ObjectId(“4ef8467846b3b8780d000001”),
“u” : 26,
“p” : [ObjectId(“4f00637b46b3b8cc0e000000”)],
“c” : 28
}, {
“a” : ObjectId(“4ef85a3e46b3b84408000000”),
“u” : 26,
“p” : [ObjectId(“4f00631046b3b85002000000”)],
“c” : 28
}]
}
</code></pre>
<p>I need to update one of the elements in the array in the document with _id = 28 but only if the a = to some value and c = some value</p>
<pre><code>Skip code block
db.coll.update({
‘_id’ : 28,
‘n.a’ : new ObjectId(‘4ef85a3e46b3b84408000000’),
‘n.c’ : 28
},
{
$push : {
‘n.$.p’ : ObjectId(“4b97e62bf1d8c7152c9ccb74”)
},
$set : {
‘n.$.t’ : ISODate(“2013-05-13T14:22:46.777Z”)
}
})
</code></pre>
<p>So basically I want to update specific element from array: and as far as one can see, this is the fourth element. The problem is that when the query is executing, it most likely updates the first element.<br>
How can I fix it?<br>
The problem in your code is dot-notation because When you specify the dot notation you assume that the filter criterias specified must match the single array element that satisfies all the criteria. But it doesnt. Dot notation on arrays may pickup any array element if any single criteria matches. Thats why you are getting the unexpected update.<br>
You have to use $elemMatch to match all the filters in the array element.</p>
<pre><code>Skip code block
db.coll.update({
‘_id’ : 28,
n: {
$elemMatch:{
a : new ObjectId(‘4ef85a3e46b3b84408000000’),
c : 28 }
}
},
{
$push : {
‘n.$.p’ : ObjectId(“4b97e62bf1d8c7152c9ccb74”)
},
$set : {
‘n.$.t’ : ISODate(“2013-05-13T14:22:46.777Z”)
}
})
and the output is
{
“a” : ObjectId(“4ef85a3e46b3b84408000000”),
“c” : 28,
“p” : [
ObjectId(“4f00631046b3b85002000000”),
ObjectId(“4b97e62bf1d8c7152c9ccb74”)
],
“t” : ISODate(“2013-05-13T14:22:46.777Z”),
“u” : 26
}
</code></pre>
</div><hr><h3><p>How can I rename a field for all documents in MongoDB?</p>
</h3><div><ul>
<li>
<p>Assuming I have a collection in MongoDB with 5000 records, each containing something similar to:</p>
<p>{
“occupation”:”Doctor”,
“name”: {
“first”:”Jimmy”,
“additional”:”Smith”
}</p>
</li>
</ul>
<p>Is there an easy way to rename the field “additional” to “last” in all documents? I saw the $rename operator in the documentation but I’m not really clear on how to specify a subfield.<br>
Not tested, but you can try:</p>
<pre><code>db.foo.update({}, {$rename:{“name.additional”:”name.last”}}, false, true);
If this does not work, maybe you have to use the former way:
remap = function (x) {
if (x.additional){
db.foo.update({_id:x._id}, {$set:{“name.last”:x.name.additional}, $unset:{“name.additional”:1}});
}
}
db.foo.find().forEach(remap);
please try db.collectionName.update({}, { $rename : { ‘name.additional’ : ‘name.last’ } }, { multi: true } )
</code></pre>
<p>and read this :)</p>
<p>https://docs.mongodb.org/manual/reference/operator/rename/#_S_rename</p>
</div><hr><h3><p>Mongodb field not null delete</p>
</h3><div><ul>
<li>How do I remove all documents in a collection where a field’s value isn’t null? Basically the MySql query version would be like this:<br>
// MySql query<br>
DELETE FROM companies WHERE createdBy != NULL<br>
// What I tried but did not work.<br>
$this-&gt;mongo-&gt;companies-&gt;remove(array(‘createdBy’ =&gt; true));<br>
I don’t even know if it is possible, if anyone could help me with this I would appreciate it<br>
Thanks :)<br>
You can do it easy via not equal operator:<br>
db.companies.find( { createdBy : { $ne : null } } );</li>
</ul>
</div><hr><h3><p>How can I see what ports mongo is listening on from mongo shell?</p>
</h3><div><ul>
<li>
<p>If I have a mongo instance running, how can I check what port numbers it is listening on from the shell? I thought that db.serverStatus() would do it but I don’t see it. I see this<br>
“connections” : {<br>
“current” : 3,<br>
“available” : 816<br>
Which is close… but no. Suggestions? I’ve read the docs and can’t seem to find any command that will do this.<br>
From the system shell you can use lsof (see Derick’s answer below) or netstat -an to view what a process is actually doing. However, assuming you only have access to the mongo shell (which your question title implies), then you can run the serverCmdLineOpts() command. That output will give you all the arguments passed on the command line (argv) and the ones from the config file (parsed) and you can infer the ports mongod is listening based on that information. Here’s an example:<br>
Skip code block</p>
<p>db.serverCmdLineOpts()
{
“argv” : [
“./mongod”,
“-replSet”,
“test”,
“–rest”,
“–dbpath”,
“/data/test/r1”,
“–port”,
“30001”
],
“parsed” : {
“dbpath” : “/data/test/r1”,
“port” : 30001,
“replSet” : “test”,
“rest” : true
},
“ok” : 1
}</p>
</li>
</ul>
<p>If you have not passed specific port options like the ones above, then the mongod will be listening on 27017 and 28017 (http console) by default. Note: there are a couple of other arguments that can alter ports without being explicit, see here:</p>
<p>https://docs.mongodb.org/manual/administration/security/#interfaces-and-port-numbers</p>
<p>You can do this from the Operating System shell by running:<br>
sudo lsof -iTCP -sTCP:LISTEN | grep mongo<br>
MongoDB only listens on one port by default (27017). If the –rest interface is active, port 28017 (27017+1000) will also be open handling web requests for details.<br>
MongoDB supports a getParameter command, but that only works if you’re already connected to the Database (at which point you already know the port).</p>
</div><hr><h3><p>mongodb indexing embedded fields (dot notation)</p>
</h3><div><ul>
<li>
<p>Let’s assume this is a document representing a customer.</p>
<p>{
company_name: ‘corporate ltd.’,
pocs: [
{name: ‘Paul’, email: ‘paul@corporate.com’},
{name: ‘Jessica’, email: ‘jessica@corporate.com’}
]
}</p>
</li>
</ul>
<p>I wanted to define a unique index for pocs.email So I issued the following command:</p>
<pre><code>db.things.ensureIndex({“pocs.email”: 1}, {unique: true})
</code></pre>
<p>The strange thing is that when trying to add another company with a poc having an email already exists in another company, mongo rejects that, respecting the unique index constraint.<br>
that is, the following cannot exists:</p>
<pre><code>Skip code block
{
company_name: ‘corporate ltd.’,
pocs: [
{name: ‘Paul’, email: ‘paul@corporate.com’},
{name: ‘Jessica’, email: ‘jessica@corporate.com’}
]
},
{
company_name: ‘contoso llc’,
pocs: [
{name: ‘Paul’, email: ‘paul@corporate.com’},
]
}
Which is fine. However, having duplicate poc within the same doc is possible, e.g.
{
company_name: ‘corporate ltd.’,
pocs: [
{name: ‘Paul’, email: ‘paul@corporate.com’},
{name: ‘Paul’, email: ‘paul@corporate.com’},
{name: ‘Jessica’, email: ‘jessica@corporate.com’}
]
},
</code></pre>
<p>see my cli commands sequence below:<br>
Skip code block</p>
<pre><code>&gt; version()
version: 2.0.2
&gt;
&gt; use test
switched to db test
&gt; db.test.ensureIndex({“poc.email”: 1}, {unique: true})
&gt;
&gt; db.test.insert({company: “contoso”, poc: [{email: ‘me@comapny.com’}]})
&gt; db.test.insert({company: “contoso”, poc: [{email: ‘me@comapny.com’}]})
E11000 duplicate key error index: test.test.$poc.email_1  dup key: { : “me@comapny.com” }
&gt; ({company: “contoso”, poc: [{email: ‘me.too@comapny.com’}, {email: ‘me.too@company.com’}]})
&gt;
&gt;
&gt; db.test.find()
{ “_id” : ObjectId(“4f44949685926af0ecf9295d”), “company” : “contoso”, “poc” : [ { “email” : “me@comapny.com” } ] }
{ “_id” : ObjectId(“4f4494b885926af0ecf9295f”), “company” : “contoso”, “poc” : [ { “email” : “me.too@comapny.com” }, { “email” : “me.too@company.com” } ] }
Moreover, this happens either at insert or at update.
&gt; db.test.update({“_id” : ObjectId(“4f44949685926af0ecf9295d”)}, {$push: { poc: {email: ‘me@company.com’}}})
&gt; db.test.find()
{ “_id” : ObjectId(“4f4494b885926af0ecf9295f”), “company” : “contoso”, “poc” : [ { “email” : “me.too@comapny.com” }, { “email” : “me.too@company.com” } ] }
{ “_id” : ObjectId(“4f44949685926af0ecf9295d”), “company” : “contoso”, “poc” : [        {      “email” : “me@comapny.com” },   {       “email” : “me@company.com” },   {      “email” : “me@company.com” } ] }
&gt;
</code></pre>
<p>Is this a <strong>bug</strong> or a <strong>by-design-feature</strong> I missed spotting in the documentation?<br>
There is an open issue regarding the same problem unique indexes not enforced within array of single document . You can vote for it.<br>
Also there is a nice workaround suggested by Kyle Banker in this similar post Unique indexes on embedded documents<br>
<strong>Update</strong><br>
This is not only related to the embedded fields, we can reproduce the same for array fields too.</p>
<pre><code>&gt;db.uniqqueTest.insert({a:[1],x:1})
&gt;db.uniqqueTest.createIndex({a:1}, {unique: true})
&gt; db.uniqqueTest.find()
{ “_id” : ObjectId(“4f44c6252434860b44986b02”), “a” : [ 1 ],”x”:1 }
and it throws an error if we try to create a new document with the same value (correct behavior )
&gt; db.uniqqueTest.insert({a:[1],x:3})
E11000 duplicate key error index: stack.uniqqueTest.$a_1  dup key: { : 1.0 }
But this works fine if we put the same value inside the array (no errors, silently accepts the duplicate value inside the array)
&gt; db.uniqqueTest.insert({a:[2],x:2})
&gt; db.uniqqueTest.update({x:2},{$push:{a:2}})
{ “_id” : ObjectId(“4f44c65f2434860b44986b05”), “a” : [ 2, 2 ], “x” : 2 }
But not for this
&gt; db.uniqqueTest.update({x:2},{$push:{a:1}])
E11000 duplicate key error index: stack.uniqqueTest.$a_1  dup key: { : 1.0 }
</code></pre>
</div><hr><h3><p>Updating a sub-document in mongodb?</p>
</h3><div><p>How do I target an subdocument in the authors array as shown below, in order to update it?</p>
<pre><code>collection.update({‘_id’: “4f44af6a024342300e000001”}, {$set: { ‘authors.?’ }} )
</code></pre>
<p>The document:</p>
<pre><code>{
_id:     “4f44af6a024342300e000001”,
title:   “A book”,
created: “2012-02-22T14:12:51.305Z”
authors: [{“_id”:”4f44af6a024342300e000002?}]
}
By specifying actual position of embedded document like this:
// update _id field of first author
collection.update({‘_id’: “4f44af6a024342300e000001”},
{$set: { ‘authors.0._id’: “1” }} )
Or via positional operator:
// update _id field of first matched by _id author
collection.update({‘_id’: “4f44af6a024342300e000001”,
//you should specify query for embedded document
‘authors._id’ : “4f44af6a024342300e000002” },
// you can update only one nested document matched by query
{$set: { ‘authors.$._id’: “1” }} )
</code></pre>
</div><hr><h3><p>Update MongoDB collection using $toLower</p>
</h3><div><p>I have an existing MongoDB collection containing user names. The user names contain both lower case and upper case letters. I want to update all the user names so they only contain lower case letters. I have tried this script, but it didn’t work</p>
<pre><code>db.myCollection.find().forEach(
function(e) {
e.UserName = $toLower(e.UserName);
db.myCollection.save(e);
}
)
Any information on getting this to work will be really appreciated, Scott
MongoDB does not have a concept of $toLower as a command. The solution is to run a big forloop over the data and issue the updates individually.
You can this in any driver or from the shell:
db.myCollection.find().forEach(
function(e) {
e.UserName = e.UserName.toLowerCase();
db.myCollection.save(e);
}
)
</code></pre>
<p>You can also replace the save with an atomic update:<br>
db.myCollection.update({_id: e._id}, {$set: {UserName: e.UserName.toLowerCase() } })<br>
Again, you could also do this from any of the drivers, the code will be very similar.<br>
EDIT: Remon brings up a good point. The $toLower command does exist as part of the aggregation framework, but this has nothing to do with updating. The documentation for updating is here.</p>
</div><hr><h3><p>Mongo ObjectIDs: Safe to use in the wild?</p>
</h3><div><p>I’m designing an API that interacts with MongoDB.<br>
Now the question is, if it is <strong>safe</strong> to use the raw ObjectID to query for objects etc. Could any security issues arise when using the OIDs directly (e.g. in queries), or should I encrypt/decrypt them before they leave my server environment?<br>
Look at BSON Object ID specification here and you will know <strong>if it is safe for you to use.</strong><br>
If you try to protect from users sending different URLs from scripts (fuskators) then it seems for me it has weak security. There won’t be too many ‘machine’, ‘pid’ part combinations. ‘time’ part can calculated if attacker can have an idea how data was inserted (especially if using batch). ‘inc’ – very weak.<br>
I won’t trust ObjectIDs as the only security.<br>
Please note there can’t be a right answer to the question “is it safe” in general. You must decide yourself.<br>
1. But keep in mind that such URL-based security will fall to dust when users will share URLs they visited. Even best your encryption won’t help.</p>
</div><hr><h3><p>In MongoDB, How to toggle a boolean field in one document with atomic operation?</p>
</h3><div><p>Is there any way to toggle the boolean field of ONE document in MongoDB with atomic operation? Say, (In python)</p>
<pre><code>cl.update({“_id”: …}, {“$toggle”: {“field”: 1}})
</code></pre>
<p>Right now, I don’t think it’s possible to do this with one operation. The bitwise operators (https://www.mongodb.org/display/DOCS/Updating#Updating-%24bit) don’t have a ‘$xor’ yet although I’ve a patch for it.<br>
Right now the workaround I think think of is by always using ‘$inc’:</p>
<pre><code>cl.update( { “_id”: …}, { ‘$inc’ : { ‘field’ : 1 } } );
</code></pre>
<p>Then instead of checking for true or false, you can do check whether an item is “true”:</p>
<pre><code>cl.find( { “_id”: …, ‘field’ : { ‘$mod’ : [ 2, 1 ] } );
</code></pre>
<p>IE, you using the modulo operator to see whether it’s even or uneven with even being “unset”, and uneven being “set”. If you want to have the oppposite behaviour (ie, find all items that don’t have the flag set), then use<br>
[ 2, 0 ];</p>
</div><hr><h3><p>Working with special characters in a Mongo collection</p>
</h3><div><p>I have a collection I’m unable to drop, I’m assuming that the “-” in its name is a special character. In MongoDB, what is the best way to escape special characters?</p>
<pre><code>&gt; db.tweets.drop();
true
BUT
&gt; db.tweets-old.drop();
ReferenceError: old is not defined (shell):1
</code></pre>
<p>I’ve tried to escape with quotes (both single and double) and a slash, but nothing works.<br>
The following works:</p>
<pre><code>db[“tweets-old”].drop();
</code></pre>
<p>It’s called the square bracket notation, which allows you to use special characters in property names.</p>
</div><hr><h3><p>Add new field to all documents in a nested array</p>
</h3><div><p>I have a database of person documents. Each has a field named photos, which is an array of photo documents. I would like to add a new ‘reviewed’ flag to each of the photo documents and initialize it to false.</p>
<p>This is the query I am trying to use:</p>
<pre><code>db.person.update({ “_id” : { $exists : true } }, {$set : {photos.reviewed : false} }, false, true)
</code></pre>
<p>However I get the following error:<br>
SyntaxError: missing : after property id (shell):1<br>
Is this possible, and if so, what am I doing wrong in my update?<br>
Here is a full example of the ‘person’ document:<br>
Skip code block</p>
<pre><code>{
“_class” : “com.foo.Person”,
“_id” : “2894”,
“name” : “Pixel Spacebag”,
“photos” : [
{
“_id” : null,
“thumbUrl” : “https://site.com/a_s.jpg”,
“fullUrl” : “https://site.com/a.jpg”
},
{
“_id” : null,
“thumbUrl” : “https://site.com/b_s.jpg”,
“fullUrl” : “https://site.com/b.jpg”
}]
}
</code></pre>
<p>Bonus karma for anyone who can tell me a cleaner why to update “all documents” without using the query { “_id” : { $exists : true } }<br>
Is this possible, and if so, what am I doing wrong in my update?<br>
No. In general MongoDB is only good at doing updates on top-level objects.<br>
The exception here is the $ positional operator. From the docs: Use this to find an array member and then manipulate it.<br>
However, in your case you want to modify all members in an array. So that is not what you need.<br>
Bonus karma for anyone who can tell me a cleaner why to update “all documents”<br>
Try db.coll.update(query, update, false, true), this will issue a “multi” update. That lasttrue is what makes it a multi.<br>
Is this possible,<br>
You have two options here:<br>
1. Write afor loop to perform the update. It will basically be a nested for loop, one to loop through the data, the other to loop through the sub-array. If you have a lot of data, you will want to write this is your driver of choice (and possibly multi-thread it).<br>
2. Write your code to handlereviewed as nullable. Write the data such that if it comes across a photo with reviewed undefined then it must be false. Then you can set the field appropriately and commit it back to the DB.<br>
Method #2 is something you should get used to. As your data grows and you add fields, it becomes difficult to “back-port” all of the old data. This is similar to the problem of issuing a schema change in SQL when you have 1B items in the DB.<br>
Instead just make your code resistant against the null and learn to treat it as a default.<br>
Again though, this is still not the solution you seek.</p>
</div><hr><h3><p>How to listen for changes to a MongoDB collection?</p>
</h3><div><p>I’m creating a sort of background job queue system with MongoDB as the data store. How can I “listen” for inserts to a MongoDB collection before spawning workers to process the job? Do I need to poll every few seconds to see if there are any changes from last time, or is there a way my script can wait for inserts to occur? This is a PHP project that I am working on, but feel free to answer in Ruby or language agnostic.<br>
What you are thinking of sounds a lot like triggers. MongoDB does not have any support for triggers, however some people have “rolled their own” using some tricks. The key here is the oplog.<br>
When you run MongoDB in a Replica Set, all of the MongoDB actions are logged to an operations log (known as the oplog). The oplog is basically just a running list of the modifications made to the data. Replicas Sets function by listening to changes on this oplog and then applying the changes locally.<br>
<strong>Does this sound familiar?</strong><br>
I cannot detail the whole process here, it is several pages of documentation, but the tools you need are available.<br>
First some write-ups on the oplog – Brief description – Layout of the local collection (which contains the oplog)<br>
You will also want to leverage tailable cursors. These will provide you with a way to listen for changes instead of polling for them. Note that replication uses tailable cursors, so this is a supported feature.<br>
MongoDB has what is called capped collections and tailable cursors that allows MongoDB to push data to the listeners.<br>
A capped collection is essentially a collection that is a fixed size and only allows insertions. Here’s what it would look like to create one:</p>
<pre><code>db.createCollection(“messages”, { capped: true, size: 100000000 })
</code></pre>
<p><strong>Ruby example of using tailable cursors:</strong></p>
<pre><code>coll = db.collection(‘my_collection’)
cursor = Mongo::Cursor.new(coll, :tailable =&gt; true)
loop do
if doc = cursor.next_document
puts doc
else
sleep 1
end
end
</code></pre>
<p><strong>Additional Resources:</strong><br>
Ruby/Node.js Tutorial which walks you through creating an application that listens to inserts in a MongoDB capped collection.<br>
An article talking about tailable cursors in more detail.<br>
PHP, Ruby, Python, and Perl examples of using tailable cursors.</p>
</div><hr><h3><p>MongoDB – Query on nested field with index</p>
</h3><div><p>I am trying to figure out how I must structure queries such that they will hit my index. I have documents structured like so:</p>
<pre><code>{ “attributes” : { “make” : “Subaru”, “color” : “Red” } }
</code></pre>
<p>With an index of: db.stuff.ensureIndex({“attributes.make”:1})<br>
What I’ve found is that querying using dot notation hits the index while querying with a document does not.<br>
Example:<br>
Skip code block</p>
<pre><code>db.stuff.find({“attributes.make”:”Subaru”}).explain()
{
“cursor” : “BtreeCursor attributes.make_1”,
“nscanned” : 2,
“nscannedObjects” : 2,
“n” : 2,
“millis” : 0,
“nYields” : 0,
“nChunkSkips” : 0,
“isMultiKey” : false,
“indexOnly” : false,
“indexBounds” : {
“attributes.make” : [
[
“Subaru”,
“Subaru”
]
]
}
}
</code></pre>
<p>vs<br>
Skip code block</p>
<pre><code>db.stuff.find({attributes:{make:”Subaru”}}).explain()
{
“cursor” : “BasicCursor”,
“nscanned” : 2,
“nscannedObjects” : 2,
“n” : 0,
“millis” : 1,
“nYields” : 0,
“nChunkSkips” : 0,
“isMultiKey” : false,
“indexOnly” : false,
“indexBounds” : {
}
}
</code></pre>
<p>Is there a way to get the document style query to hit the index? The reason is that when constructing queries from my persistent objects it’s much easier to serialize them out as documents as opposed to something using dot notation.<br>
I’ll also add that we’re using a home grown data mapper layer built w/ Jackson. Would using something like Morphia help with properly constructing these queries?<br>
Did some more digging and this thread explains what’s going with the sub-document query. My problem above was that to make the sub-document based query act like the dot-notation I needed to use elemMatch.</p>
<pre><code>Skip code block
db.stuff.find({“attributes”:{“$elemMatch” : {“make”:”Subaru”}}}).explain()
{
“cursor” : “BtreeCursor attributes.make_1”,
“nscanned” : 2,
“nscannedObjects” : 2,
“n” : 0,
“millis” : 2,
“nYields” : 0,
“nChunkSkips” : 0,
“isMultiKey” : false,
“indexOnly” : false,
“indexBounds” : {
“attributes.make” : [
[
“Subaru”,
“Subaru”
]
]
}
}
</code></pre>
</div><hr><h3><p>Save Subset of MongoDB Collection to Another Collection</p>
</h3><div><p>I have a set like so</p>
<pre><code>{date: 20120101}
{date: 20120103}
{date: 20120104}
{date: 20120005}
{date: 20120105}
</code></pre>
<p>How do I save a subset of those documents with the date ‘20120105’ to another collection?<br>
<strong>i.e</strong> db.subset.save(db.full_set.find({date: “20120105”}));<br>
Here’s the shell version:</p>
<pre><code>db.full_set.find({date:”20120105?}).forEach(function(doc){
db.subset.insert(doc);
});
</code></pre>
<p>There’s no direct equivalent of SQL’s insert into … select from ….<br>
You have to take care of it yourself. Fetch documents of interest and save them to another collection.<br>
You can do it in the shell, but I’d use a small external script in Ruby. Something like this:<br>
require ‘mongo’</p>
<pre><code>db = Mongo::Connection.new.db(‘mydb’)
source = db.collection(‘source_collection’)
target = db.collection(‘target_collection’)
source.find(date: “20120105”).each do |doc|
target.insert doc
end
</code></pre>
<p>Actually, there is an equivalent of SQL’s insert into … select from in MongoDB. First, you convert multiple documents into an array of documents; then you insert the array into the target collection</p>
<p>db.subset.insert(db.full_set.find({date:”20120105?}).toArray())</p>
</div><hr><h3><p>What characters are NOT allowed in MongoDB field names?</p>
</h3><div><p>I figured out that of course . and SPACE aren’t allowed. Are there other forbidden characters ?<br>
You can use any (UTF8) character in the field name which aren’t special (contains “.”, or starts with “$”).</p>
<p>https://jira.mongodb.org/browse/SERVER-3229<br>
https://stackoverflow.com/a/7976235/311220</p>
<p>It’s generally best to stick with lowercase alphanumeric with underscores though.</p>
</div><hr><h3><p>Is MongoDB somehow limited to a single core?</p>
</h3><div><p>Perhaps I have misconfigured MongoDB somehow, but even under heavy load I don’t see it using more than one core. For example, top is currently showing:<br>
Skip code block</p>
<pre><code>Tasks: 145 total,   1 running, 144 sleeping,   0 stopped,   0 zombie
Cpu0  :  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu1  :  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu2  :  0.0%us,  0.0%sy,  0.0%ni,100.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu3  :100.0%us,  0.0%sy,  0.0%ni,  0.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:  41182768k total, 40987476k used,   195292k free,   109956k buffers
Swap:  2097144k total,  1740288k used,   356856k free, 28437928k cached
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
16297 mongod    15   0  521g  18g  18g S 99.8 47.2   2929:32 mongod
1 root      15   0 10372  256  224 S  0.0  0.0   0:03.39 init
</code></pre>
<p>Is there something I can do to get Mongo to use the other cores more effectively? If it’s relevant, I currently have a big M/R running which seems to have put a lot of read queries in “waiting” mode.<br>
MongoDB can saturate all cores on a multi-core machine for read operations, but for write operations and map-reduce MongoDB can only utilize a single core per mongod process.<br>
The limitation for single-core MapReduce is due to the Javascript interpreter that MongoDB utilizes. This is something that is supposed to be fixed in the future but in the interim you can use Hadoop to execute the MapReduce and store the result set in your MongoDB database.<br>
Another option which has seen mixed results is to run a single mongod process for every core on the instance this will not increase performance for a single database unless they are configured to run in a sharded setup.</p>
</div><hr><h3><p>Mongo count really slow when there are millions of records</p>
</h3><div><pre><code>//FAST
db.datasources.find().count()
12036788
//SLOW
db.datasources.find({nid:19882}).count()
10161684
</code></pre>
<p>Index on nid<br>
Any way to make the second query faster? (It is taking about 8 seconds)<br>
Count queries, indexed or otherwise, are slow due to the fact that MongoDB still has to do a full b-tree walk to find the appropriate number of documents that match your criteria. The reason for this is that the MongoDB b-tree structure is not “counted” meaning each node does not store information about the amount of elements in the node/subtree.<br>
The issue is reported here https://jira.mongodb.org/browse/SERVER-1752 and there is currently no workaround to improve performance other than manually maintaining a counter for that collection which obviously comes with a few downsides.<br>
Also note that the db.col.count() version (so no criteria) can take a big shortcut and doesn’t actually perform a query hence it’s speed. That said it does not always report the same value as a count query would that should return all elements (it won’t be in sharded environments with high write throughput for example). Up for debate whether or not that’s a bug. I think it is.<br>
Note that in 2.3+ a significant optimization was introduced that should (and does) improve performance of counts on indexed fields.</p>
<p>See: https://jira.mongodb.org/browse/SERVER-7745</p>
</div><hr><h3><p>MongoDB not equal to</p>
</h3><div><p>I’m trying to display a query in MongoDB where a text field is not ” (blank)</p>
<pre><code>{ ‘name’ : { $not : ” }}
</code></pre>
<p>However I get the error invalid use of $not<br>
I’ve looked over the documentation but the examples they use are for complicated cases (with regexp and $not negating another operator).<br>
How would I do the simple thing I’m trying to do?<br>
Use $ne — $not should be followed by the standard operator:<br>
An examples:<br>
use test<br>
switched to db test</p>
<pre><code>db.test.insert({author : ‘me’, post: “”})
db.test.insert({author : ‘you’, post: “how to query”})
db.test.find({‘post’: {$ne : “”}})
{ “_id” : ObjectId(“4f68b1a7768972d396fe2268”), “author” : “you”, “post” : “how to query” }
And now $not:
db.test.find({‘post’: {$not: {$ne : “”}}})
{ “_id” : ObjectId(“4f68b19c768972d396fe2267”), “author” : “me”, “post” : “” }
</code></pre>
<p>Use $ne instead of $not</p>
<p><strong>https://docs.mongodb.org/manual/reference/operator/ne/#op._S_ne</strong><br>
db.collections.find({“name”: {$ne: “”}});</p>
<p>If you want to do multiple $ne then do</p>
<pre><code>db.users.find({name : {$nin : [“mary”, “dick”, “jane”]}})
</code></pre>
</div><hr><h3><p>Multiple $elemMatch expressions for matching array values using $all in MongoDB?</p>
</h3><div><p>In the answer to a question I found a interesting solution for searching array values using $elemMatch.<br>
If we have the following documents in our collection:</p>
<pre><code>{
foo : [ { bar : “xy”, baz : 1 },
{ bar : “a”, baz : 10 } ]
},
{
foo : [ { bar : “xy”, baz : 5 },
{ bar : “b”, baz : 50 } ]
}
</code></pre>
<p>The following query will match only the first document:</p>
<pre><code>db.test.find({
foo : { “$all” : [ { “$elemMatch” : { bar : “xy”, baz : 1} }, { “$elemMatch” : { bar : “a”, baz: 10 } } ] }
});
</code></pre>
<p>I tried it with several other examples and it really works. But the official documentation for $alloperator doesn’t say anything about combining these two queries.<br>
Is this the intended behavior or a bug? Or is this just a problem that the documentation does not cover this use case?<br>
This is the intended behavior. The documentation doesn’t cover this use case and we are working on it to make it better. Its difficult, however, to document every possible query combination.</p>
</div><hr><h3><p>How to remove duplicate entries from an array?</p>
</h3><div><p>How to remove duplicate entries from an array?<br>
In below example “Algorithms in C++” is added twice.<br>
$unset modifier removes a particular field but how to remove an entry from a field?</p>
<pre><code>&gt; db.users.find()
{ “_id” : ObjectId(“4f6cd3c47156522f4f45b26f”),
“favorites” : { “books” : [ “Algorithms in C++”,
“The Art of Computer Programmning”,
“Graph Theory”,
“Algorithms in C++” ] },
“name” : “robert” }
</code></pre>
<p>What you have to do is use map reduce to detect and count duplicate tags .. then use $set to replace the entire books based on { “_id” : ObjectId(“4f6cd3c47156522f4f45b26f”),<br>
This has been discussed sevel times here .. please seee<br>
Removing duplicate records using MapReduce<br>
Fast way to find duplicates on indexed column in mongodb</p>
<p>https://csanz.posterous.com/look-for-duplicates-using-mongodb-mapreduce<br>
https://www.mongodb.org/display/DOCS/MapReduce</p>
<p>How to remove duplicate record in MongoDB by MapReduce?<br>
Thanks :)<br>
As of MongoDB 2.2 you can use the aggregation framework with an $unwind, $group and$project stage to achieve this:</p>
<pre><code>db.users.aggregate([{$unwind: ‘$favorites.books’},
{$group: {_id: ‘$_id’,
books: {$addToSet: ‘$favorites.books’},
name: {$first: ‘$name’}}},
{$project: {‘favorites.books’: ‘$books’, name: ‘$name’}}
])
</code></pre>
<p>Note the need for the $project to rename the favorites field, since $group aggregate fields cannot be nested.</p>
</div><hr><h3><p>Order of $lt and $gt in MongoDB range query</p>
</h3><div><p>Today I have noticed that the order in which the $lt and $gt operators are given seem to matter in MongoDB 2.0.2.<br>
I have a database of games. “player” is an array of two strings representing both players, “endedAtMS” is a timestamp when the game has ended. I have created this index:<br>
db.games.ensureIndex({player:1,endedAtMS:-1})<br>
To get 30 of my games which were finished in a certain time range, ordered by the time the games where finished, I do:</p>
<pre><code>Skip code block
db.games.find({ “player” : “Stefan” ,
“endedAtMS” : { “$lt” : 1321284969946 ,
“$gt” : 1301284969946}}).
sort({endedAtMS:-1}).
limit(30).
explain()
{
“cursor” : “BtreeCursor player_1_endedAtMS_-1”,
“nscanned” : 30,
“nscannedObjects” : 30,
“n” : 30,
“millis” : 0,
“nYields” : 0,
“nChunkSkips” : 0,
“isMultiKey” : true,
“indexOnly” : false,
“indexBounds” : {
“player” : [
[
“Stefan”,
“Stefan”
]
],
“endedAtMS” : [
[
1321284969946,
-1.7976931348623157e+308
]
]
}
}
</code></pre>
<p>All seems to work fine. However when I change the order of $lt and $gt in the query above I get this:</p>
<pre><code>Skip code block
db.games.find({ “player” : “Stefan” ,
“endedAtMS” : { “$gt”:1301284969946,
“$lt” : 1321284969946}}).
sort({endedAtMS:-1}).
limit(30).
explain()
{
“cursor” : “BtreeCursor player_1_endedAtMS_-1”,
“nscanned” : 126,
“nscannedObjects” : 126,
“n” : 30,
“millis” : 1,
“nYields” : 0,
“nChunkSkips” : 0,
“isMultiKey” : true,
“indexOnly” : false,
“indexBounds” : {
“player” : [
[
“Stefan”,
“Stefan”
]
],
“endedAtMS” : [
[
1.7976931348623157e+308,
1301284969946
]
]
}
}
</code></pre>
<p>As you can see 126 docs need to be scanned to get the 30 docs for the result. If you take a look at the indexBounds in the explain output it seems that only the first operator is used to limit the search space in the index.<br>
What do I miss? Why is Mongo only using one operator to limit the search space?<br>
This is a known issue. The short answer is that it has to do with the fact that a multikey index is used (“player” is an array), and the index cannot be constrained on both upper and lower bounds.<br>
This is explained in more detail in the Jira case: https://jira.mongodb.org/browse/SERVER-4155 – “Index bound incorrect?”<br>
There is an open Jira ticket to improve this behavior: https://jira.mongodb.org/browse/SERVER-4180 – “Wrong indexbounds picked for a date range query (regression)” which is slated to be released in version 2.1.2 (this version is subject to change). Please vote for it!</p>
</div><hr><h3><p>Foreign key like relationship in Mongo DB</p>
</h3><div><p>How can I implement a foreign key like relationship in Mongo DB?<br>
hiya see this: MongoDB normalization, foreign key and joining &amp;&amp;</p>
<p>further ===&gt;https://books.google.com/books/about/Document_Design_for_MongoDB.html?id=TbIHkgEACAAJ&amp;redir_esc=y</p>
<p>hope it helps! cheerios!<br>
MongoDB doesn’t support server side foreign key relationships, normalization is also discouraged. You should embed your child object within parent objects if possible, this will increase performance and make foreign keys totally unnecessary. That said it is not always possible, so there is a special construct called DBRef which allows to reference objects in a different collection. This may be then not so speedy because DB has to make additional queries to read objects but allows for kind of foreign key reference.<br>
Still you will have to handle your references manually. Only while looking up your DBRef you will see if it exists, the DB will not go through all the documents to look for the references and remove them if the target of the reference doesn’t exist any more. But I think removing all the references after deleting the book would require a single query per collection, no more, so not that difficult really.</p>
<p><strong>Edit update</strong></p>
<p>https://levycarneiro.com/tag/mongodb/</p>
<p>levycarneiro.com/tag/mongodb [quote] So you create 4 collections: Clients, Suppliers, Employees and Contacts. You connect them all together via a db reference. This acts like a foreign key. But, this is not the mongoDB way to do things. Performance will penalized. [unquote]</p>
</div><hr><h3><p>How to get a specific embedded document inside a MongoDB collection?</p>
</h3><div><p>I have a collection Notebook which has embedded array document called Notes. The sample<br>
document looks like as shown below.</p>
<pre><code>Skip code block
{
“_id” : ObjectId(“4f7ee46e08403d063ab0b4f9”),
“name” : “MongoDB”,
“notes” : [
{
“title” : “Hello MongoDB”,
“content” : “Hello MongoDB”
},
{
“title” : “ReplicaSet MongoDB”,
“content” : “ReplicaSet MongoDB”
}
]
}
</code></pre>
<p>I want to find out only note which has title “Hello MongoDB”. I am not getting what should<br>
be the query. Can anyone help me.<br>
I don’t believe what you are asking is possible, at least without some map-reduce maybe?<br>
See here: Filtering embedded documents in MongoDB<br>
That answer suggests you change your schema, to better suit how you’d like to work with the data.<br>
You can use a either “dot notation” or $elemMatch to get back the correct, document that has the matching “note title” …<br>
&gt;</p>
<pre><code> db.collection.find({ “notes.title” : “Hello MongoDB”}, { “notes.title” : 1?});
or …
&gt; db.collection.find({ “notes” : { “$elemMatch” : { “title” : “Hello MongoDB”} }});
</code></pre>
<p>But you will get back the whole array, not just the array element that caused the match.<br>
Also, something to think about … with your current setup it woud be hard to do any operations on the items in the array.<br>
If you don’t change your schema (as the answer linked to suggests) … I would consider adding “ids” to each element in the array so you can do things like delete it easily if needed.<br>
You can do this with mongo version higher 2.2<br>
the query like this:</p>
<pre><code>db.coll.find({ ‘notes.title’: ‘Hello MongoDB’ }, {‘notes.$’: 1});
</code></pre>
<p>you can try with $elemMatch like Justin Jenkins</p>
</div><hr><h3><p>can you have mongo $push prepend instead of append?</p>
</h3><div><p>I’d like to have push add at the beginning of my set rather than appended to the back when I do a mongo $push.<br>
Is it possible to do an atomic push update that adds it as the first element rather than the last?<br>
A similar question was asked a few days ago. Unfortunately, the short answer is, “no”, but there is an open request for this feature.<br>
https://jira.mongodb.org/browse/SERVER-2191 – “$push() to front of array”<br>
There is some more information as well as a possible work-around on the other thread: “Use MongoDB array as stack” – Use MongoDB array as stack<br>
Hopefully the above will be useful and help you to find an acceptable work-around.<br>
Use negative index with $set for prepend, tested in mongo v2.2:</p>
<pre><code>Skip code block
&gt; db.test.insert({‘array’: [4, 5, 6]})
&gt; db.test.find()
{ “_id” : ObjectId(“513ad0f8afdfe1e6736e49eb”),
“array” : [ 4, 5, 6 ] }
//prepend 3
&gt; db.test.update({“_id” : ObjectId(“513ad0f8afdfe1e6736e49eb”)},
{‘$set’: {‘array.-1’:     3}})
&gt; db.test.find()
{ “_id” : ObjectId(“513ad0f8afdfe1e6736e49eb”),
“array” : [ 3, 4, 5, 6 ] }
//prepend 2
&gt; db.test.update({“_id” : ObjectId(“513ad0f8afdfe1e6736e49eb”)},
{‘$set’: {‘array.-1’:     2}})
&gt; db.test.find()
{ “_id” : ObjectId(“513ad0f8afdfe1e6736e49eb”),
“array” : [ 2, 3, 4, 5, 6 ] }
//prepend 1
&gt; db.test.update({“_id” : ObjectId(“513ad0f8afdfe1e6736e49eb”)},
{‘$set’: {‘array.-1’:     1}})
&gt; db.test.find()
{ “_id” : ObjectId(“513ad0f8afdfe1e6736e49eb”),
“array” : [ 1, 2, 3, 4, 5, 6 ] }
</code></pre>
<p>As of MongoDB v2.5.3, there is a new $position operator that you can include along with the$each operator as part of your $push query to specify the location in the array at which you would like to insert a value.<br>
Here’s an example from the docs page to add the elements 20 and 30 at the array index of 2::</p>
<pre><code>db.students.update( { _id: 1 },
{ $push: { scores: {
$each: [ 20, 30 ],
$position: 2
}
}
}
)
</code></pre>
<p>Reference: https://docs.mongodb.org/master/reference/operator/update/position/#up._S_position</p>
</div><hr><h3><p>How can I create unique IDs for embedded documents in MongoDB?</p>
</h3><div><p>So I need to reference particular subdocuments uniquely from items in my collection. For instance:</p>
<pre><code>User = {
‘name’: ‘jim’,
‘documents: [
{‘id’: 0001, ‘title’: “My document”},
{‘id’: 0002, ‘title’: “My second document!”},
]
}
</code></pre>
<p>So I need to be able to auto-create IDs for new documents, preferably not at the application level (since there will be race conditions in the actual development scenario).<br>
Is there a way to use mongo’s autogenerated ObjectId (used in the _id field at the collection level), or something similar?<br>
Yes, using mongo’s ObjectId is the way to go. The only thing is: you have to generate them yourself, in the application code. They are meant to be globally unique, different workers won’t generate two identical ObjectIds, so there’s no race condition in that sense.<br>
All official drivers should provide a way to generate ObjectId. Here’s how it is in Ruby:</p>
<pre><code>oid = BSON::ObjectId.new
All drivers have functionality for generating ObjectIds.
In the shell you just do new ObjectId():
&gt; db.test.insert({x:new ObjectId()});
&gt; db.test.find();
{ “_id” : ObjectId(“4f88592a06c05e4de90d0bc1”), “x” : ObjectId(“4f88592a06c05e4de90d0bc0”) }
</code></pre>
<p>In Java it’s new ObjectId() as well. See the API docs for your driver to see the specific syntax.</p>
</div><hr><h3><p>Deleting a key/value from existing MongoDB entry</p>
</h3><div><p>I need to delete a certain key and value from every entry in a particular collection. I’ve looked into remove and that seems to be for only entire entries. Looking at update, I don’t believe updating a particular key with null or an empty string would achieve what I’m trying to do. I’m very much a beginner with mongodb, so please excuse my ignorance.<br>
Long story short, how can I turn</p>
<pre><code>{
“_id” : 1234,
“name” : “Chris”,
“description” : “Awesome”
}
into
{
“_id” : 1234,
“name” : “Chris”
}
</code></pre>
<p>without deleting the entry and creating a new one, or using any non-mongodb commands? Thanks!<br>
Try $unset in a call to update().<br>
In other words,</p>
<pre><code>db.collection_name.update({ _id: 1234 }, { $unset : { description : 1} });
</code></pre>
<p>should work. Link.</p>
</div><hr><h3><p>Problems with Mongo value-in-array query: $not operator doesn’t work, and ObjectIds cannot be selected</p>
</h3><div><p>I am trying to select a document which does NOT contain a value in a document’s array.<br>
I’m having two problems, which I’ll present separately:</p>
</div><hr><h3><p>Why does this not work?</p>
</h3><div><p>(2) I cannot get the value in array query to work if the array values are ObjectIds:</p>
<pre><code>{ _id: Object(“000000000000000000000000”), mylist: [ ObjectId(“111111111111111111111111”) ] }
The following does NOT retrieve this document:
myCol.find({mylist:ObjectId(“111111111111111111111111”)})
Can someone suggest what I might be doing wrong?
There is no $not that works like, you want $ne for simple cases like yours:
db.myCol.find({ mylist: { $ne: ‘orange’ } })
</code></pre>
<p>Your second should (and does) work fine for me, perhaps you’re using the wrong number of ones.</p>
</div><hr><h3><p>Updating a document field in mongo based on another field’s value</p>
</h3><div><p>Suppose I have two fields F1 and F2. I want to update F1 to become F1 + “, ” + F2. Can I do so with a single update command in mongo?<br>
No, you can’t do that. You can’t use expressions in mongodb updates. The only way is to fetch this document to the client, compose new field value there and issue a prepared update statement.</p>
</div><hr><h3><p>mongodb map reduce to get uniques by date/day</p>
</h3><div><p>trying to group by date and number</p>
<pre><code>my document
{ “_id” : ObjectId(“4f956dee76ddb26752026e8f”), “request” : “default”, “options” : “1”, “keyword” : “somekey”, “number” : “5b234b79-4d70-437e-8eef-32a2941af40a”, “date” : “20120423200446”, “time” : 1335193066 }
my query
map = “function() { var date = new Date(this.time * 1000); var key = date.getFullYear() + date.getMonth() + date.getDate(); emit({day : key, number: this.number}, {count: 1}); }”
reduce = “function(key, values) { var count = 0; values.forEach(function(v) { count += v[‘count’]; }); return {count: count}; }”
db.txtweb.mapReduce(map, reduce, {out: “pageview_results”});
my error
</code></pre>
<p>uncaught exception: map reduce failed:{ “errmsg” : “ns doesn’t exist”, “ok” : 0 }<br>
I cannot figure out whats wrong, but I think it is do something with the date functionality.<br>
Any ideas.<br>
ns doesn’t exist means that you’re accessing a non-existent database or collection. Check their names<br>
Script below group this.amount by day (without time)</p>
<pre><code>Skip code block
db.payments.mapReduce(
function() {
var k = clone(this.payment_time);
k.setMinutes(0);
k.setSeconds(0);
k.setMilliseconds(0);
emit(k, this.amount);
},
function (key, vals) {
var total = 0;
for (var i = 0; i &lt; vals.length; i++) {
total += vals[i];
}
return total;
},
{
out : {merge : “resultName” }
}
);
}
};
</code></pre>
</div><hr><h3><p>mongo – how to query a nested json</p>
</h3><div><p>I am a complete mongo newbie. I am using mongo hub for mac. I need to query the for following json –</p>
<pre><code> {“_id” : ObjectId( “abcd” ),
“className” : “com.myUser”,
“reg” : 12345,
“test” : [
{ “className” : “com.abc”,
“testid” : “pqrs” } ] }
</code></pre>
<p>and find records where testid is pqrs. How would I go about doing that?<br>
You can type {‘test.testid’: ‘pqrs’} in the query field of Mongo Hub.</p>
</div><hr><h3><p>Mongodb find a document with all subdocuments satisfying a condition</p>
</h3><div><p>I have Game collection in my DB:</p>
<pre><code>var game = {
players: [{username:”user1?, status:”played”},
{username:”user2?, status:”accepted”}]
}
</code></pre>
<p>As far as I understand query like this: db.games.find({“players.status”:”played”}) will give me all games where at least one player has status “played”. How can I find games with ALL players having status “played”?<br>
If you only have one other status than “played” use the query:</p>
<pre><code>db.games.find({“players.status”:{$ne:”accepted”}})
</code></pre>
<p>You can adjust the query to handle more status values, as long as they are all known at the time of the query.</p>
</div><hr><h3><p>MongoDB – Update an object in nested Array</p>
</h3><div><p>Assume we have the following collection, which I have few questions about:</p>
<pre><code>Skip code block
{
“_id” : ObjectId(“4faaba123412d654fe83hg876”),
“user_id” : 123456,
“total” : 100,
“items” : [
{
“item_name” : “my_item_one”,
“price” : 20
},
{
“item_name” : “my_item_two”,
“price” : 50
},
{
“item_name” : “my_item_three”,
“price” : 30
}
]
}
</code></pre>
<p>1 – I want to increase the price for “item_name”:”my_item_two” <strong>and if it doesn’t exists</strong>, it should be appended to the “items” array.<br>
2 – How can I update two fields at the same time. For example, increase the price for “my_item_three” and at the same time increase the “total” (with the same value).<br>
I prefer to do this on the MongoDB side, otherwise I have to load the document in client-side (Python) and construct the updated document and replace it with the existing one in MongoDB.<br>
<strong>UPDATE</strong> This is what I have tried and works fine <strong>IF THE Object Exists :</strong><br>
db.test_invoice.update({user_id : 123456 , “items.item_name”:”my_item_one”} , {$inc: {“items.$.price”: 10}})<br>
But if the key doesn’t exist it does nothing. Also it only updates the nested object. There is no way with this command to update the “total” field as well.<br>
For question #1, let’s break it into two parts. First, increment any document that has “items.item_name” equal to “my_item_two”. For this you’ll have to use the positional “$” operator. Something like:</p>
<pre><code>db.bar.update( {user_id : 123456 , “items.item_name” : “my_item_two” } ,
{$inc : {“items.$.price” : 1} } ,
false ,
true);
</code></pre>
<p>Note that this will only increment the first matched subdocument in any array (so if you have another document in the array with “item_name” equal to “my_item_two”, it won’t get incremented). But this might be what you want.<br>
The second part is trickier. We can push a new item to an array without a “my_item_two” as follows:</p>
<pre><code>db.bar.update( {user_id : 123456, “items.item_name” : {$ne : “my_item_two” }} ,
{$addToSet : {“items” : {‘item_name’ : “my_item_two” , ‘price’ : 1 }} } ,
false ,
true);
For your question #2, the answer is easier. To increment the total and the price of item_three in any document that contains “my_item_three,” you can use the $inc operator on multiple fields at the same time. Something like:
db.bar.update( {“items.item_name” : {$ne : “my_item_three” }} ,
{$inc : {total : 1 , “items.$.price” : 1} ,
false ,
true);
</code></pre>
</div><hr><h3><p>To what extent are ‘lost data’ criticisms still valid of MongoDB?</p>
</h3><div><p>I’m referring to the following</p>
<p>https://pastebin.com/raw.php?i=FD3xe6Jt</p>
<p>Which, if still valid would be worrying to some extent. The article primarily references v1.6 and v1.8 and since then v2 has been released. Are the shortcomings discussed in the article still outstanding as of the current release?<br>
That particular post was debunked, point by point by the MongoDB CTO and co-founder, Eliot Horowitz, here:</p>
<p>https://news.ycombinator.com/item?id=3202959</p>
<p>There is also a good summary here:</p>
<p>https://www.betabeat.com/2011/11/10/the-trolls-come-out-for-10gen/</p>
<p>The short version is, it looks like this was basically someone trolling for attention (successfully), with no solid evidence or corroboration. There have been genuine incidents in the past, which have been dealt with as the product evolved (see the introduction of journaling in 1.8 for example) or as more specific bugs were found and fixed.<br>
<strong>Disclaimer</strong>: I do work for MongoDB (formerly 10gen), and love the fact that philnate got here and refuted this independently first – that probably says more about the product than anything else :)<br>
<strong>Update: August 19th 2013</strong><br>
I’ve seen quite a bit of activity on this answer recently, which I assume is related to the announcement of the bug in SERVER-10478 – it is most certainly an edge case, but I would still recommend anyone using sharding with large documents to upgrade ASAP to v2.2.6 and v2.4.6 which include the fix for this issue.<br>
Never heard of those severe problems in recent versions. What you need to consider is that MongoDB has no decade of development as relational Systems in the back. Further it may be true that MongoDB doesn’t offer that much functionality to avoid data loss at all. But even with relational Systems you won’t be ever sure that you’ll never loose any data. It highly depends on your system configuration (so with Replication and manual data backups you should be quite safe).<br>
As a general guideline to avoid Beta Bugs or bugs from early versions, avoid to use fresh versions in productions (there’s a reason why debian is so popular for servers). If MongoDB would suffer such severe problems (all the time) the list of users would be smaller:https://www.mongodb.org/display/DOCS/Production+Deployments Additionally I don’t really trust this pastebin message, why is this published anonymously? Is this person company shamed to tell that they used mongodb, do they fear 10gen? Where a links to those Bug reports (or did 10gen delete them from JIRA?)<br>
So lets talk shortly about those points:<br>
1. Yep MongoDB operates normally in fire and forget mode. But you can modify this bevavior with several options: https://www.mongodb.org/display/DOCS/getLastError+Command. So only because MongoDB defaults to it, it doesn’t mean you can’t change it to your needs. But you need to live less performance if you don’t fire and forget within your app, as you’re adding a roundtrip.<br>
2. Never heard of such problems, except those caused to own failure…but that can happen with relational systems as well. I guess this point only talks about Master-Slave Replication. Replica-Sets are much never and stable. Some links from the web where other dbms caused data loss due to malfunction as well: https://blog.lastinfirstout.net/2010/04/bit-by-bug-data-loss-running-oracle-on.html https://dbaspot.com/oracle-server/430465-parallel-cause-data-lost-another-oracle-bug.html https://bugs.mysql.com/bug.php?id=18014 (Those posted links aren’t in any favor of a given system or should imply anything else than showing that there are bugs in other systems as well, who can cause data loss.)<br>
3. Yes actually there’s Locking at instance level, I don’t think that in sharded environment this is a global one, I think this will be at instance level for each shard separate, as there’s no need to lock other instances as there are no consistency checks needed. The upcoming Version 2.2 will lock at DB Level, tickets for Collection Level and maybe extend or document exists as well (https://jira.mongodb.org/browse/SERVER-4328). But locking at deeper levels may affect the actual performance of MongoDB, as a lock management is expensive.<br>
4. Moving chunks shouldn’t cause much problems as rebalancing should take a few chunks from each node and move them to the new one. It never should cause ping/pong of chunks nor does rebalancing start just because of a difference of one or two chunks. What can be problematic is when your shard key is choosen wrong. So you may end up with all new entries inserted to one node rather than all. So you would see more often rebalancing which can cause problems, but that would be not due to mongo rather than your poorly choosen shardkey.<br>
5. Can’t comment on this one<br>
6. Not 100% sure, but I think Replicasets where introduced in 1.6, so as told earlier never use the latest version for production, except you can live with loss of data. As with every new feature there’s the possibility of bugs. Even extensive testing may not reveal all problems. Again always run some manual backup for gods sake, except you can live with data loss.<br>
7. Can’t comment on this. But in reality software may contain severe bugs. Many games suffer those problems as well and there are other areas as well where banana software was quite well known or is. Can’t Comment about something concrete as this was before my MongoDB time.<br>
8. Replication can cause such problems. Depending on the replication strategy this may be a problem and another system may fit better. But without a really really write intensive workload you may not encounter such problems. Indeed it may be problematic to have 3 replicas polling changes from one master. You could cure the problem by adding more shards.<br>
As a general conclusion: Yeah it may be that those problems were existent, but MongoDB did much in this direction and further I doubt that other DBMS never had the one or other problem itself. Just take traditional relational dbms, would those scale well to web-scale there would be no need for Systems like MongoDB, HBase and what else. You can’t get a system which fits all needs. So you have to live with the downsides of one or try to build a combined system of multiple to get what you need.<br>
Disclaimer: I’m not affiliated with MongoDB or 10gen, I’m just working with MongoDB and telling my opinion about it.<br>
I can’t speak for every case, only my own. However I don’t work for 10gen or its competitors, and I have lost data when using MongoDB, so here goes.<br>
The main criticisms of Mongo around the last time I used it (2010) were:<br>
1. Supposedly stable versions of Mongo had major data-losing bugs that weren’t made explicit to users. Eg, prior to 1.8 non-clustered configurations were likely to lose data. This was documented by Mongo, but not to the extent a data losing bug in a stable-versioned DB would normally be.<br>
The main defence of that criticism was:<br>
2. Users were informed of this danger, albeit not so explicitly. Users should read all the documentation before they begin.<br>
In my own case, I was using 1.7 in a single server configuration but aware of the risk. I shut down the DB to take a back up. The act of shutting down the DB itself lost my data, 10gen assisted (for free) but were unable to recover the data.</p>
</div><hr><h3><p>Mongo DB Delete a field and value</p>
</h3><div><p>In mongo shell how would I delete all occurrences of “id” : “1” the value of the field is always different. Would I use the $unset operator? Would that delete the value and the field?<br>
You’re saying remove all occurrences of the field, right? If so, then it should be like this:</p>
<pre><code>db.collection.update(
{ id: { $exists: true } },  // criteria
{ $unset: { id: 1 } },      // modifier
false,                      // no need to upsert
true                        // multi-update
);
</code></pre>
</div><hr><h3><p>Checking if a field contains a string</p>
</h3><div><p>I’m looking for an operator, which allows me to check, if the value of a field contains a certain string.<br>
Something like:</p>
<pre><code>db.users.findOne({$contains:{“username”:”son”}})
</code></pre>
<p>Is that possible?<br>
You can do it with the following code.</p>
<pre><code>db.users.findOne({“username” : {$regex : “.*son.*”}});
</code></pre>
<p>As Mongo shell support regex, that’s completely possible.</p>
<pre><code>db.users.findOne({“username” : /.*son.*/});
</code></pre>
<p>If we want the query to be case-insensitive, we can use “i” option, like shown below:</p>
<pre><code>db.users.findOne({“username” : /.*son.*/i});
</code></pre>
<p>See: https://www.mongodb.org/display/DOCS/Advanced+Queries#AdvancedQueries-RegularExpressions<br>
https://www.mongodb.org/display/DOCS/SQL+to+Mongo+Mapping+Chart<br>
https://php.net/manual/en/mongo.sqltomongo.php</p>
<pre><code>MySQL
SELECT * FROM users WHERE username LIKE “%Son%”
MongoDB
db.users.find({username:/Son/})
</code></pre>
</div><hr><h3><p>What’s the fastest way to copy a collection within the same database?</p>
</h3><div><p>I want to copy a collection within the <strong>same</strong> database and give it a different name – basically take a snapshot.<br>
What’s the best way to do this? Is there a command, or do I have to copy each record in turn?<br>
I’m aware of the cloneCollection command, but it seems to be for copying to another server only.<br>
I’m also aware of mongoimport and mongoexport, but as I’m doing this via PHP I’d prefer not to make calls out to the shell.<br>
You have a few options, but the fastest is:<br>
mongoexport -d db -c sourcecollection | mongoimport -d db -c targetcollection –drop<br>
or in php:</p>
<pre><code>`mongoexport -d db -c sourcecollection | mongoimport -d db -c targetcollection –drop`;
</code></pre>
<p>after that you have</p>
<pre><code>mongo db &lt; script.js
</code></pre>
<p>where, as shown in the mongo docs, script.js contains something like:</p>
<pre><code>db.myoriginal.find().forEach( function(x){db.mycopy.insert(x)} );
</code></pre>
<p>The slowest (by an order of magnitude or more) way to copy a collection will be to use the native php driver – simply because of moving information around. But you could issue the above mongo query if you absolutely want to avoid cli calls using the db execute function.</p>
</div><hr><h3><p>mongodb: upserting: only set value if document is being inserted</p>
</h3><div><p>Considering a simple mongo document structure:<br>
{ _id, firstTime, lastTime }<br>
The client needs to insert a document with a known ID, or update an existing document. The ‘lastTime’ should always be set to some latest time. For the ‘firstTime’, if a document is being inserted, then the ‘firstTime’ should be set to current time. However, if the document is already created, then ‘firstTime’ remain unchanged. I would like to do it purely with upserts (to avoid look ups).</p>
<p>I’ve crawled the https://www.mongodb.org/display/DOCS/Updating,</p>
<p>but I just don’t see how that particular operation can be done.<br>
I don’t believe this is something unreasonable, there are $push and $addToSet operations that effectively do that on array fields, just nothing that would do the same on simple fields. It’s like there should be something like $setIf operation.<br>
I ran into the exact same problem and there was no simple solution for &lt;2.4 however since 2.4 the <strong>$setOnInsert</strong> operator let’s you do exactly that.</p>
<pre><code>db.collection.update( ,
{ $setOnInsert: { “firstTime”: } },
{ upsert: true }
)
</code></pre>
<p>See the 2.4 release notes of setOnInsert for more info.</p>
</div><hr><h3><p>Change collection name in mongodb</p>
</h3><div><p>Changing the name of a collection in mongodb can be achieved by copy the documents in the collection to a new one and delete the original.<br>
But is there a simpler way to change the name of a collection in mongodb?<br>
db.oldname.renameCollection(“newname”)<br>
Really? No google search?</p>
<p>https://www.mongodb.org/display/DOCS/renameCollection+Command</p>
<p>&gt; db.oldname.renameCollection(“newname”)</p>
</div><hr><h3><p>what’s the diff between findAndModify and update in MongoDB?</p>
</h3><div><p>I’m a little bit confused by the findAndModify method in MongoDB. What’s the advantage of it over update method? For me, it seems that it just returns the item first and then update it.But Why do I need to return the item first? I read the <strong>MongoDB: the definitive guide</strong> and it says that It is handy for manipulating queues and performing other operations that need get-and-set style atomicity. But I didn’t understand how it achieves this. Can somebody explain this to me?<br>
If you fetch an item and then update it, there may be an update by another thread between those two steps. If you update an item first and then fetch it, there may be another update in-between and you will get back a different item than what you updated.<br>
Doing it “atomically” means you are guaranteed that you are getting back the exact same item you are updating – i.e. no other operation can happen in between.<br>
findAndModify returns the document, update does not.<br>
If I understood Dwight Merriman (one of the original authors of mongoDB) correctly, using update to modify a single document i.e.(“multi”:false} is also atomic. Currently, it should also be faster than doing the equivalent update using findAndModify.<br>
One useful class of use cases is counters and similar cases. For example, take a look at this code (one of the MongoDB tests): find_and_modify4.js.<br>
Thus, with findAndModify you increment the counter and get its incremented value in one step. Compare: if you (A) perform this operation in two steps and somebody else (B) does the same operation between your steps then A and B may get the same last counter value instead of two different (just one example of possible issues).</p>
</div><hr><h3><p>Getting an error, “Error: couldn’t connect to server 127.0.0.1 shell/mongo.js” &amp; when trying to run mongodb on mac osx lion</p>
</h3><div><p>I am using Mac OS X Lion and i just did a fresh install of MongoDB using macports and when i try to run mongodb for the first time i get the following error<br>
MongoDB shell version: 2.0.5<br>
connecting to: test<br>
Fri Jun &nbsp;1 11:20:33 Error: couldn’t connect to server 127.0.0.1 shell/mongo.js:84<br>
exception: connect failed<br>
can anybody please help with this? thanks<br>
when i run mongod i get:</p>
<pre><code>Skip code block
hisham-agil:~ hisham$ mongod
mongod –help for help and startup options
Fri Jun  1 11:24:47 [initandlisten] MongoDB starting : pid=53452 port=27017 dbpath=/data/db/ 64-bit host=hisham-agil.local
Fri Jun  1 11:24:47 [initandlisten] db version v2.0.5, pdfile version 4.5
Fri Jun  1 11:24:47 [initandlisten] git version: nogitversion
Fri Jun  1 11:24:47 [initandlisten] build info: Darwin gamma.local 11.3.0 Darwin Kernel Version 11.3.0: Thu Jan 12 18:48:32 PST 2012; root:xnu-1699.24.23~1/RELEASE_I386 i386 BOOST_LIB_VERSION=1_49
Fri Jun  1 11:24:47 [initandlisten] options: {}
Fri Jun  1 11:24:47 [initandlisten] exception in initAndListen: 10296 dbpath (/data/db/) doesnot exist, terminating
Fri Jun  1 11:24:47 dbexit:
Fri Jun  1 11:24:47 [initandlisten] shutdown: going to close listening sockets…
Fri Jun  1 11:24:47 [initandlisten] shutdown: going to flush diaglog…
Fri Jun  1 11:24:47 [initandlisten] shutdown: going to close sockets…
Fri Jun  1 11:24:47 [initandlisten] shutdown: waiting for fs preallocator…
Fri Jun  1 11:24:47 [initandlisten] shutdown: lock for final commit…
Fri Jun  1 11:24:47 [initandlisten] shutdown: final commit…
Fri Jun  1 11:24:47 [initandlisten] shutdown: closing all files…
Fri Jun  1 11:24:47 [initandlisten] closeAllFiles() finished
Fri Jun  1 11:24:47 dbexit: really exiting now
</code></pre>
<p>You’re running the mongo client without starting the server first. Try running mongod first.<br>
You’ll have to specify where the mongo “workspace” is using the –dbpath switch, such as mongod –dbpath /mongo/db. The specified folder should exist.<br>
By default mongod will try to use the directory /data/db for the database files.<br>
In your case that directory does not exist.<br>
Before starting mongod you should create those directories and make sure they are writable by the same user that is running mongod process.</p>
</div><hr><h3><p>MongoDB – how to query for a nested item inside a collection?</p>
</h3><div><p>I have some data that looks like this:</p>
<pre><code>Skip code block
[
{
“_id” : ObjectId(“4e2f2af16f1e7e4c2000000a”),
“advertisers” : [
{
“created_at” : ISODate(“2011-07-26T21:02:19Z”),
“category” : “Infinity Pro Spin Air Brush”,
“updated_at” : ISODate(“2011-07-26T21:02:19Z”),
“lowered_name” : “conair”,
“twitter_name” : “”,
“facebook_page_url” : “”,
“website_url” : “”,
“user_ids” : [ ],
“blog_url” : “”,
},
</code></pre>
<p>and I was thinking that a query like this would give the id of the advertiser:</p>
<pre><code>var start  = new Date(2011, 1, 1);
&gt; var end  = new Date(2011, 12, 12);
&gt; db.agencies.find( { “created_at” : {$gte : start , $lt : end} } , { _id : 1 , program_ids: 1 , advertisers { name : 1 }  } ).limit(1).toArray();
</code></pre>
<p>But my query didn’t work. Any idea how I can add the fields inside the nested elements to my list of fields I want to get?<br>
Thanks!<br>
Use dot notation (e.g. advertisers.name) to query and retrieve fields from nested objects:</p>
<pre><code>db.agencies.find( { “advertisers.created_at” : {$gte : start , $lt : end} } , { _id : 1 , program_ids: 1 , “advertisers.name”: 1 }  } ).limit(1).toArray();
</code></pre>
<p>Reference: Retrieving a Subset of Fields and Dot Notation</p>
</div><hr><h3><p>How do I abort a query in mongo javascript shell</p>
</h3><div><p>Executing queries in the Javascript shell of Mongo feels a lot like executing commands right in the bash shell. Because of this, my fingers keep trying to Ctrl+C my way out of a command that I want to “abort” and land back at the command prompt. Unfortunately, in the mongo shell at 2.0.4, when I Ctrl+C, it drops me out of the javascript shell, rather than just aborting the command and giving me the command prompt.<br>
Is there a way in the javascript shell to abandon the current command without executing it and land back at the command prompt?<br>
What I’ve always naturally done is type a ( and then immediately hit enter three times. The shell will assume you are just hitting enter to break up your command, but if you hit enter 2 more times it will exit back to the shell. It’s wonky, but it works.</p>
</div><hr><h3><p>Where does mongodb stand in the CAP theorem?</p>
</h3><div><p>Everywhere I look, I see that MongoDB is CP. But when I dig in I see it is eventually consistent. Is it CP when you use safe=true? If so, does that mean that when I write with safe=true, all replicas will be updated before getting the result?<br>
MongoDB is strongly consistent by default – if you do a write and then do a read, assuming the write was successful you will always be able to read the result of the write you just read. This is because MongoDB is a single-master system and all reads go to the primary by default. If you optionally enable reading from the secondaries then MongoDB becomes eventually consistent where it’s possible to read out-of-date results.<br>
MongoDB also gets high-availability through automatic failover in replica sets: https://www.mongodb.org/display/DOCS/Replica+Sets<br>
This should help answer the question, along with other NoSQL and other persistent storage systems.</p>
</div><hr><h3><p>MongoDB: BIllions of documents in a collection</p>
</h3><div><p>I need to load 6.6 billion bigrams into a collection but I can’t find any information on the best way to do this.<br>
Loading that many documents onto a single primary key index would take forever but as far as I’m aware mongo doesn’t support the equivalent of partitioning?<br>
Would sharding help? Should I try and split the data set over many collections and build that logic into my application?<br>
It’s hard to say what the optimal bulk insert is — this party depends on the size of the objects you’re inserting and other immeasurable factors. You could try a few ranges and see what gives you the best performance. As an alternative, some people like using mongoimport, which is pretty fast, but your import data needs to be json or csv. There’s obviously mongodrestore, if the data is in BSON format.<br>
Mongo can easily handle billions of documents and can have billions of documents in the one collection but remember that the maximum document size is 16mb. There are many folk with billions of documents in MongoDB and there’s lots of discussions about it on the MongoDB Google User Group. Here’s a document on using a large number of collections that you may like to read, if you change your mind and want to have multiple collections instead. The more collections you have, the more indexes you will have also, which probably isn’t what you want.<br>
Here’s a presentation from Craigslist on inserting billions of documents into MongoDB and the guy’s blogpost.<br>
It does look like sharding would be a good solution for you but typically sharding is used for scaling across multiple servers and a lot of folk do it because they want to scale their writes or they are unable to keep their working set (data and indexes) in RAM. It is perfectly reasonable to start off with a single server and then move to a shard or replica-set as your data grows or you need extra redundancy and resilience.<br>
However, there are other users use multiple mongods to get around locking limits of a single mongod with lots of writes. It’s obvious but still worth saying but a multi-mongod setup is more complex to manage than a single server. If your IO or cpu isn’t maxed out here, your working set is smaller than RAM and your data is easy to keep balanced (pretty randomly distributed), you should see improvement (with sharding on a single server). As a FYI, there is potential for memory and IO contention. With 2.2 having improved concurrency with db locking, I suspect that there will be much less of a reason for such a deployment.<br>
You need to plan your move to sharding properly, i.e. think carefully about choosing your shard key. If you go this way then it’s best to pre-split and turn off the balancer. It will be counter-productive to be moving data around to keep things balanced which means you will need to decide up front how to split it. Additionally, it is sometimes important to design your documents with the idea that some field will be useful for sharding on, or as a primary key.<br>
Here’s some good links –<br>
1. Choosing a Shard Key<br>
2. Blog post on shard keys<br>
3. Overview presentation on sharding<br>
4. Presentation on Sharding Best Practices<br>
You can absolutely shard data in MongoDB (which partitions across N servers on the shard key). In fact, that’s one of it’s core strengths. There is no need to do that in your application.<br>
For most use cases, I would strongly recommend doing that for 6.6 billion documents. In my experience, MongoDB performs better with a number of mid-range servers rather than one large one.</p>
</div><hr><h3><p>Why are key names stored in the document in MongodDB</p>
</h3><div><p>I’m curious about this quote from Kyle Banker’s MongoDB In Action:<br>
Its important to consider the length of the key names you choose, since key names are stored in the documents themselves. This contrasts with an RDBMS, where column names are always kept separate from the rows they refer to. So when using BSON, if you can live with dob in place of date_of_birth as a key name, youll save 10 bytes per document. That may not sound like much, but once you have a billion such documents, youll have saved nearly 10 GB of storage space just by using a shorter key name. This doesnt mean you should go to unreasonable lengths to ensure small key names; be sensible. But if you expect massive amounts of data, economizing on key names will save space.<br>
I am interested in the reason why this is not optimized on the database server side. Would a in-memory lookup table with all key names in the collection be too much of a performance penalty that is not worth the potential space savings?<br>
What you are referring to is often called “key compression”*. There are several reasons why it hasn’t been implemented:<br>
1. If you want it done, you can currently do it at the Application/ORM/ODM level quite easily.<br>
2. It’s not necessarily a performance** advantage in all cases think collections with lots of key names, and/or key names that vary wildly between documents.<br>
3. It might not provide a measurable performance** advantage at all until you have millions of documents.<br>
4. If the server does it, the full key names still have to be transmitted over the network.<br>
5. If compressed key names are transmitted over the network, then readabilityreally suffers using the javascript console.<br>
6. Compressing the entire JSON document might offer an even better performance advantage.<br>
Like all features, there’s a cost benefit analysis for implementing it, and (at least so far) other features have offered more “bang for the buck”.<br>
Full document compression is being considered for a future MongoDB version.<br>
* An in-memory lookup table for key names is basically a special case of LZW style compression that’s more or less what most compression algorithms do.<br>
** Compression provides both a space advantage and a performance advantage. Smaller documents means that more documents can be read per IO, which means that in a system with fixed IO, more documents per second can be read.<br>
I believe one of the original reasons behind storing the key names with the documents is to allow a more easily scalable schema-less database. Each document is self-contained to a greater extent, in that if you move the document to another server (for example, via replication or sharding) you can index the contents of the document without having to reference separate or centralized metadata such as a mapping of key names to more compact key IDs.<br>
Since there is no enforced schema for a MongoDB collection, the field names can potentially be different for every document in the same collection. In a sharded environment, inserts to each shard are (intentionally) independent so at a document level the raw data could end up differing unless the key mapping was able to be consistent per shard.<br>
Depending on your use case, the key names may or may not consume a significant amount of space relative to the accompanying data. You could always workaround the storage concern from the application / ODM implementation by mapping YourFriendlyKeyNames to shorter DB key equivalents.<br>
There is an open MongoDB Jira issue and some further discussion to have the server tokenize field names, which you can vote on to help prioritize including this feature in a future release.<br>
MongoDB’s current design goals include performance with dynamic schemas, replication &amp; high availability, auto-sharding, and in-place updates .. with one potential tradeoff being some extra disk usage.</p>
</div><hr><h3><p>How can I copy collection to another database in MongoDB?</p>
</h3><div><p>Is there some simple way to fulfill this?<br>
At the moment there is no command in MongoDB that would do this. Please note the JIRA ticket with related feature request: https://jira.mongodb.org/browse/SERVER-732.<br>
You could do something like:<br>
db..find().forEach(function(d){ db.getSiblingDB(‘’)[‘’].insert(d); });<br>
Please note that with this, the two databases would need to share the same mongod for this to work.<br>
Besides this, you can do a mongodump of a collection from one database and then mongorestore the collection to the other database.<br>
The best way is to do a mongodump then mongorestore.<br>
You can select the collection via:<br>
mongodump -d some_database -c some_collection<br>
[Optionally, zip the dump (zip some_database.zip some_database/* -r) and scp it elsewhere]<br>
Then restore it:<br>
mongorestore -d some_other_db -c some_or_other_collection dump/some_collection.bson<br>
Existing data in some_or_other_collection will be preserved. That way you can “append” a collection from one database to another.<br>
Prior to version 2.4.3, you will also need to add back your indexes after you copy over your data. Starting with 2.4.3, this process is automatic, and you can disable it with –noIndexRestore.<br>
I would abuse the connect function in mongo cli mongo doc. so that means you can start one or more connection. if you want to copy customer collection from test to test2 in same server. first you start mongo shell<br>
use test<br>
var db2 = connect(‘localhost:27017/test2’)<br>
do a normal find and copy the first 20 record to test2.<br>
db.customer.find().limit(20).forEach(function(p) { db2.customer.insert(p); });<br>
or filter by some criteria<br>
db.customer.find({“active”: 1}).forEach(function(p) { db2.customer.insert(p); });<br>
just change the localhost to IP or hostname to connect to remote server. I use this to copy test data to a test database for testing.<br>
Actually, there is a command to move a collection from one database to another. It’s just not called “move” or “copy”.<br>
To copy a collection, you can clone it on the same db, then move the clone.<br>
To clone:</p>
<pre><code>&gt; use db1
&gt; db.source_collection.find().forEach( function(x){db.collection_copy.insert(x)} );
To move:
&gt; use admin
switched to db admin
&gt; db.runCommand({renameCollection: ‘db1.source_collection, to: ‘db2.target_collection’}) // who’d think rename could move?
The other answers are better for copying the collection, but this is especially useful if you’re looking to move it.
I’d usually do:

use sourcedatabase;
var docs=db.sourcetable.find();
use targetdatabase;
docs.forEach(function(doc) { db.targettable.insert(doc); });
</code></pre>
</div><hr><h3><p>In Mongo what is the difference between sharding and replication?</p>
</h3><div><p>Replication seems to be a lot simpler than sharding, unless I am missing the benefits of what sharding is actually trying to achieve. Don’t they both provide horizontal scaling?<br>
In the context of scaling MongoDB:<br>
replicationcreates additional copies of the data and allows for automatic failover to another node. 1. Replication may help with horizontal scaling of reads if you are OK to read data that potentially isn’t the latest.<br>
2. sharding allows for horizontal scaling of data writes by partitioning data across multiple servers using a shard key. It’s important to choose a good shard key. For example, a poor choice of shard key could lead to “hot spots” of data only being written on a single shard.<br>
A sharded environment does add more complexity because MongoDB now has to manage distributing data and requests between shards — additional configuration and routing processes are added to manage those aspects.<br>
Replication and sharding are typically combined to created a sharded cluster where each shard is supported by a replica set.<br>
From a client application point of view you also have some control in relation to the replication/sharding interaction, in particular:<br>
1. Read preferences<br>
2. Write concerns<br>
Replication is a mostly traditional master/slave setup, data is synced to backup members and if the primary fails one of them can take its place. It is a reasonably simple tool. It’s primarily meant for redundancy, although you can scale reads by adding replica set members. That’s a little complicated, but works very well for some apps.<br>
Sharding sits on top of replication, usually. “Shards” in MongoDB are just replica sets with something called a “router” in front of them. Your application will connect to the router, issue queries, and it will decide which replica set (shard) to forward things on to. It’s significantly more complex than a single replica set because you have the router and config servers to deal with (these keep track of what data is stored where).<br>
If you want to scale Mongo horizontally, you’d shard. 10gen likes to call the router/config server setup auto-sharding. It’s possible to do a more ghetto form of sharding where you have the app decide which DB to write to as well.</p>
</div><hr><h3><p>What does Mongo sort on when no sort order is specified?</p>
</h3><div><p>When we run a Mongo find() query without any sort order specified, what does the database internally use to sort the results?<br>
According to the documentation on the mongo website:<br>
When executing a find() with no parameters, the database returns objects in forward natural order.<br>
For standard tables, natural order is not particularly useful because, although the order is often close to insertion order, it is not guaranteed to be. However, for Capped Collections, natural order is guaranteed to be the insertion order. This can be very useful.<br>
However for standard collections (non capped collections), what field is used to sort the results? Is it the <strong>_id</strong> field or something else?<br>
<strong>Edit:</strong><br>
Basically, I guess what I am trying to get at is that if I execute the following search query:<br>
db.collection.find({“x”:y}).skip(10000).limit(1000);<br>
At two different points in time: <strong>t1</strong> and <strong>t2</strong>, will I get different result sets:<br>
1. When there have been no additional writes between t1 &amp; t2?<br>
2. When there have been new writes between t1 &amp; t2?<br>
3. There are new indexes that have been added between t1 &amp; t2?<br>
I have run some tests on a temp database and the results I have gotten are the same (<strong>Yes</strong>) for all the 3 cases – but I wanted to be sure and I am certain that my test cases weren’t very thorough.<br>
By definition the sort <strong>defaults to undefined</strong>, and so is the return order of documents. If there is no query then it will use the natural order. The results are returned in the <strong>order they are found,</strong> which may coincide with insertion order (but isn’t guaranteed to be) or the order of the index(es) used.<br>
Some examples that will affect storage (natural) order:<br>
1. if documents are updated and don’t fit in their currently allocated space, they will be moved<br>
new documents may be inserted in available gaps created by deleted or moved documents<br>
2. If an index is used, docs will be returned in the order they are found. If more than one index is used then the order depends internally on which index first identified the document during the de-duplication process.<br>
If you <strong>want a specific order</strong> then you <strong>must</strong> include a sort with your query.<br>
The exception noted for capped collections’ natural order is because documents can’t move and are stored in insertion order. The ordering is part of the capped collection feature that ensures the oldest documents “age out” first. Additionally, documents cannot be deleted or moved in a capped collection (see Usage and Restrictions for more info).</p>
</div><hr><h3><p>How to reclaiming deleted space without `db.repairDatabase()`?</p>
</h3><div><p>I want to shrink data files size by reclaiming deleted space, but I can’t run db.repairDatabase(), because free disk space is not enough.<br>
The original answer to this question is here: Reducing MongoDB database file size<br>
There really is nothing outside of repair that will reclaim space. The compact should allow you to go much longer on the existing space. Otherwise, you will have to migrate to a bigger drive.<br>
One way to do this is to use an off-line secondary from your Replica Set. This should give you a whole maintenance window to migrate, repair, move back and bring back up.<br>
If you are not running a Replica Set, it’s time to look at doing just that.<br>
You could run the compact command on a single collection, or one by one in all the collections you want to shrink.<br>
https://www.mongodb.org/display/DOCS/Compact+Command<br>
db.runCommand( { compact : ‘mycollectionname’ } )<br>
As noted in comments, I was mistaken, compact does not actually reclaim disk space, it only defragments and rebuilds collection indexes.<br>
Instead though, you could use “–repairpath” option if you have another drive available which has available freespace.<br>
For example:<br>
mongod –dbpath /data/db –repair –repairpath /data/db0<br>
Shown here: https://docs.mongodb.org/manual/tutorial/recover-data-following-unexpected-shutdown/</p>
</div><hr><h3><p>creating a different database for each collection in MongoDB 2.2</p>
</h3><div><p>MongoDB 2.2 has a write lock per database as opposed to a global write lock on the server in previous versions. So would it be ok if i store each collection in a separate database to effectively have a write lock per collection.(This will make it look like MyISAM’s table level locking). Is this approach faulty?<br>
There’s a key limitation to the locking and that is the local database. That database includes a theoplog collection which is used for replication.<br>
If you’re running in production, you should be running with Replica Sets. If you’re running with Replica Sets, you need to be aware of the write lock effect on that database.<br>
Breaking out your 10 collections into 10 DBs is useless if they all block waiting for the oplog.<br>
Before taking a large step to re-write, please ensure that the oplog will not cause issues.<br>
Also, be aware that MongoDB implements DB-level security. If you’re using any security features, you are now creating more DBs to secure.</p>
</div><hr><h3><p>How to stop mongo DB in one command</p>
</h3><div><p>I need to be able to start/stop MongoDB on the cli. It is quite simple to start:<br>
./mongod<br>
But to stop mongo DB, I need to run open mongo shell first and then type two commands:<br>
$ ./mongo<br>
use admin<br>
db.shutdownServer()<br>
So I don’t know how to stop mongo DB in one line. Any help?<br>
Starting and Stopping MongoDB is covered in the MongoDB manual. This section of the manual explains the various options of stopping MongoDB through the shell, cli, drivers etc. It also details the risks of incorrectly stopping MongoDB (such as data corruption) and talks about the different kill signals.<br>
Additionally, if you have installed MongoDB using a package manager for Ubuntu or Debian then you can stop mongod as follows:</p>
<p>1. Upstart:sudo service mongodb stop<br>
2. Sysvinit:sudo /etc/init.d/mongodb stop</p>
<p>Or on Red Hat based systems:<br>
1. service mongod stop<br>
Or on Windows if you have installed as a service named MongoDB:<br>
1. net stop MongoDB<br>
To learn more about the problems of an unclean shutdown, how to best avoid such a scenario and what to do in the event of an unclean shutdown, please see: Recover Data after an Unexpected Shutdown.<br>
If you literally want a one line equivalent to the commands in your original question, you could alias:<br>
mongo –eval “db.getSiblingDB(‘admin’).shutdownServer()”<br>
Mark’s answer on starting and stopping MongoDB via services is the more typical (and recommended) administrative approach.</p>
<pre><code>mongod –dbpath /path/to/your/db –shutdown
</code></pre>
<p>More info at official: https://docs.mongodb.org/manual/tutorial/manage-mongodb-processes/</p>
</div><hr><h3><p>MongoDB select count(distinct x) on an indexed column – count unique results for large data sets</p>
</h3><div><p>I have gone through several articles and examples, and have yet to find an efficient way to do this SQL query in MongoDB (where there are millions of &nbsp;documents)<br>
<strong>First attempt</strong></p>
<pre><code>(e.g. from this almost duplicate question – Mongo equivalent of SQL’s SELECT DISTINCT?)
db.myCollection.distinct(“myIndexedNonUniqueField”).length
Obviously I got this error as my dataset is huge
Thu Aug 02 12:55:24 uncaught exception: distinct failed: {
“errmsg” : “exception: distinct too big, 16mb cap”,
“code” : 10044,
“ok” : 0
}
</code></pre>
<p><strong>Second attempt</strong><br>
I decided to try and do a group<br>
db.myCollection.group({key: {myIndexedNonUniqueField: 1},<br>
initial: {count: 0},<br>
reduce: function (obj, prev) { prev.count++;} } );<br>
But I got this error message instead:<br>
exception: group() can’t handle more than 20000 unique keys<br>
<strong>Third attempt</strong></p>
<p>I haven’t tried yet but there are several suggestions that involve mapReduce<br>
e.g.<br>
1. this onehow to do distinct and group in mongodb? (not accepted, answer author / OP didn’t test it)<br>
2. this oneMongoDB group by Functionalities (seems similar to Second Attempt)<br>
3. this onehttps://blog.emmettshear.com/post/2010/02/12/Counting-Uniques-With-MongoDB<br>
4. this one https://groups.google.com/forum/?fromgroups#!topic/mongodb-user/trDn3jJjqtE<br>
5. this onehttps://cookbook.mongodb.org/patterns/unique_items_map_reduce/</p>
<p><strong>Also</strong><br>
It seems there is a pull request on GitHub fixing the .distinct method to mention it should only return a count, but it’s still open: https://github.com/mongodb/mongo/pull/34<br>
But at this point I thought it’s worth to ask here, what is the latest on the subject? Should I move to SQL or another NoSQL DB for distinct counts? or is there an efficient way?<br>
<strong>Update:</strong><br>
This comment on the MongoDB official docs is not encouraging, is this accurate?</p>
<p>https://www.mongodb.org/display/DOCS/Aggregation#comment-430445808</p>
<p><strong>Update2:</strong><br>
Seems the new Aggregation Framework answers the above comment… (MongoDB 2.1/2.2 and above, development preview available, not for production)<br>
https://docs.mongodb.org/manual/applications/aggregation/</p>
<ol>
<li>
<p>The easiest way to do this is via the aggregation framework. This takes two “$group” commands: the first one groups by distinct values, the second one counts all of the distinct values</p>
<p>Skip code block
pipeline = [
{ $group: { _id: “$myIndexedNonUniqueField”}  },
{ $group: { _id: 1, count: { $sum: 1 } } }
];
//
// Run the aggregation command
//
R = db.runCommand(
{
“aggregate”: “myCollection” ,
“pipeline”: pipeline
}
);
printjson(R);</p>
</li>
<li>
<p>If you want to do this with Map/Reduce you can. This is also a two-phase process: in the first phase we build a new collection with a list of every distinct value for the key. In the second we do a count() on the new collection.</p>
<p>Skip code block
var SOURCE = db.myCollection;
var DEST = db.distinct
DEST.drop();
map = function() {
emit( this.myIndexedNonUniqueField , {count: 1});
}
reduce = function(key, values) {
var count = 0;
values.forEach(function(v) {
count += v[‘count’];        // count each distinct value for lagniappe
});
return {count: count};
};
//
// run map/reduce
//
res = SOURCE.mapReduce( map, reduce,
{ out: ‘distinct’,
verbose: true
}
);
print( “distinct count= ” + res.counts.output );
print( “distinct count=”, DEST.count() );</p>
</li>
</ol>
<p>Note that you cannot return the result of the map/reduce inline, because that will potentially overrun the 16MB document size limit. You can save the calculation in a collection and then count() the size of the collection, or you can get the number of results from the return value of mapReduce().</p>
<pre><code>db.myCollection.aggregate(
{$group : {_id : “$myIndexedNonUniqueField”} },
{$group: {_id:1, count: {$sum : 1 }}});
straight to result:
db.myCollection.aggregate(
{$group : {_id : “$myIndexedNonUniqueField”} },
{$group: {_id:1, count: {$sum : 1 }}})
.result[0].count;
</code></pre>
</div><hr><h3><p>MongoDB: Find Subdocument in Array Matching Parameters</p>
</h3><div><p>In MongoDB I would like to find a document based on the values of a subdocument meeting certain parameters. Specifically I have a document structured like this:</p>
<pre><code>Skip code block
{
name: “test”,
data: [{
name: “test1”,
start: 0,
end: 2
},
{
name: “test2”,
start: 15
end: 18
}]
}
</code></pre>
<p>How can I tell MongoDB to only return my document if the start time for a data subdocument is less than 5 and the end time for the same subdocument is greater than 5? Currently, if I do</p>
<pre><code>db.foo.findOne({
‘data.start’: { $lte: 5 },
‘data.end’: { $gte: 5 }
})
it will return my document always because 5 is greater than 0 and less than 18. How can I tell MongoDB to only return my document if 5 (or whatever value) is greater than 0 and less than 2 OR greater than 15 and less than 18?
You want to use $elemMatch.
db.foo.findOne({ data: { $elemMatch : {
start: { $lte: 5 },
end: { $gte: 5 }
}}
})
</code></pre>
</div><hr><h3><p>How to efficiently perform “distinct” with multiple keys?</p>
</h3><div><p>For example, there is a collection like this:</p>
<pre><code>{market: ‘SH’, code: ‘000001’, date: ‘2012-01-01’, price: 1000}
{market: ‘SZ’, code: ‘000001’, date: ‘2012-01-01’, price: 1000}
{market: ‘SH’, code: ‘000001’, date: ‘2012-01-02’, price: 1000}
{market: ‘SZ’, code: ‘000001’, date: ‘2012-01-02’, price: 1000}
{market: ‘SH’, code: ‘000002’, date: ‘2012-01-03’,price: 1000}
</code></pre>
<p>…<br>
This collection contains tens of millions documents.<br>
I want to call distinct with two keys:</p>
<pre><code>collection.distinct(‘market’, ‘code’);
</code></pre>
<p>and get result :</p>
<pre><code>[{market: ‘SH’, code:’000001'}, {market: ‘SZ’, code:’000001'}, {market: ‘SH’, code:’000002'}]
</code></pre>
<p>As native distinct command accept only one key, I try to implement it by using map-reduce. But map-reduce is far too slow to native distinct. In my one-key distinct test, map-reduce spend about ten times longer than native distinct.<br>
Is there a efficient way to implement multikey distinct?<br>
If you are willing to wait for the upcoming 2.2 release of MongoDB, you can run this query efficiently using the aggregation framework:</p>
<pre><code>collection = db.tb;
result = collection.aggregate(
[
{“$group”: { “_id”: { market: “$market”, code: “$code” } } }
]
);
printjson(result);
</code></pre>
<p>On a million-record collection on my test machine, this ran in 4 seconds, while the map/reduce version took over a minute.</p>
</div><hr><h3><p>MongoDB: Trade-offs of dropping a collection vs. removing all of its documents</p>
</h3><div><p>What are the trade-offs of dropping a MongoDB collection vs. removing all of its documents (assuming the collection will be re-created immediately)?<br>
If you go through a remove all the documents from a collection, then you’ll be doing a lot more work (freeing the document’s storage, clearing the index entries that point to the document, and so on). If you instead just drop the collection, it’ll just be reclaiming the extents that the collection and its indexes use.<br>
One other difference is that dropping the collection will also remove the collection’s indexes.<br>
A benefit of simply dropping a collection is that it is much faster than removing all of a collection’s documents. If your collection will be “re-created immediately” anyway (assuming that includes index re-creation), then this is probably the most-attractive option.<br>
The authors of the book MongoDB: The Definitive Guide (Kristina Chodorow and Michael Dirolf) ran an experiment where they provided a Python script which timed a drop vs. a remove of 1000000 records. The results came in at 46.08 seconds for the remove and .01 seconds for the drop. Now while the exact times may differ based-on hardware and other factors, it nonetheless illustrates the point that the drop is significantly faster.<br>
reference: Chodorow K., Dirolf M. (2010). MongoDB: The Definitive Guide. O’Reilly Media, Inc. Sebastapol, CA., pp.25</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-vs-mysql">MongoDB Vs MySQL - Which Is A Better Database?</a></strong></p>
</div><hr><h3><p>MongoDB : find value in Array with multiple criteria</p>
</h3><div><p>I have the following documents:</p>
<pre><code>{_id : 1, numbers : [-1000, 1000]}
{_id : 2, numbers : [5]}
</code></pre>
<p>I’m trying to get a query that will find a document that has a value in the numbers array that is between -10 and 10 (in this case, _id : 2). However, when I try the following:</p>
<pre><code>db.foo.find({numbers : $and : [{$gt : -10},{$lt : 10}]})
</code></pre>
<p>it returns all documents. Is this possible to do without map-reduce? Thanks, -JWW<br>
You can use $elemMatch to check if an element in an array matches a specified match expression.<br>
In this case, you can use it to get a document whose numbers array has an element that is between -10 and 10:</p>
<pre><code>db.foo.find( { numbers : { $elemMatch : { $gt : -10 , $lt : 10 } } } );
</code></pre>
<p>This will just return the _id : 2 document.</p>
</div><hr><h3><p>MongoDB 2.1 Aggregate Framework Sum of Array Elements matching a name</p>
</h3><div><p>This is a question about the best way to add up a series of data in an array where I have to match another element. I’m trying to use the 2.2 Aggregation framework and it’s possible I can do this with a simple group.<br>
So for a given set of documents I’m trying to get an output like this;</p>
<pre><code>Skip code block
{
“result” : [
{
“_id” : null,
“numberOf”: 2,
“Sales” : 468000,
“profit” : 246246,
}
],
“ok” : 1
}
Now, I originally had a list of documents, containing values assigned to named properties, eg;
Skip code block
[
{
_id : 1,
finance: {
sales: 234000,
profit: 123123,
}
}
,
{
_id : 2,
finance: {
sales: 234000,
profit: 123123,
}
}
]
</code></pre>
<p>This was easy enough to add up, but the structure didn’t work for other reasons. For instance, there are may other columns like “finance” and I want to be able to index them without creating thousands of indexes, so I need to convert to a structure like this;</p>
<pre><code>Skip code block
[
{
_id : 1,
finance: [
{
“k”: “sales”,
“v”: {
“description”:”sales over the year”,
v: 234000,
}
},
{
“k”: “profit”,
“v”: {
“description”:”money made from sales”,
v: 123123,
}
}
]
}
,
{
_id : 2,
finance: [
{
“k”: “sales”,
“v”: {
“description”:”sales over the year”,
v: 234000,
}
},
{
“k”: “profit”,
“v”: {
“description”: “money made from sales”,
v: 123123,
}
}
]
}
]
</code></pre>
<p>I can index finance.k if I want, but then I’m struggling to build an aggregate query to add up all the numbers matching a particular key. This was the reason I originally went for named properties, but this really needs to work in a situation whereby there are thousands of “k” labels.<br>
Does anyone know how to build an aggregate query for this using the new framework? I’ve tried this;</p>
<pre><code>Skip code block
db.projects.aggregate([
{
$match: {
// QUERY
$and: [
// main query
{},
]
}
},
{
$group: {
_id: null,
“numberOf”: { $sum: 1 },
“sales”:    { $sum: “$finance.v.v” },
“profit”:   { $sum: “$finance.v.v” },
}
},
])
but I get;
{
“errmsg” : “exception: can’t convert from BSON type Array to double”,
“code” : 16005,
“ok” : 0
}
** For extra kudos, I’ll need to be able to do this in a MapReduce query as well.
You can use the aggregation framework to get sales and profit and any other value you may be storing in your key/value pair representation.
For your example data:
Skip code block
var pipeline = [
{
“$unwind” : “$finance”
},
{
“$group” : {
“_id” : “$finance.k”,
“numberOf” : {
“$sum” : 1
},
“total” : {
“$sum” : “$finance.v.v”
}
}
}
]
R = db.tb.aggregate( pipeline );
printjson(R);
{
“result” : [
{
“_id” : “profit”,
“numberOf” : 2,
“total” : 246246
},
{
“_id” : “sales”,
“numberOf” : 2,
“total” : 468000
}
],
“ok” : 1
}
</code></pre>
<p>If you have additional k/v pairs then you can add a match which only passes through k values in [“sales”,”profit”].<br>
You will have to use ‘$unwind” to break out the values in the array, which will mean that you can’t get the sum of the sales and the profit in a single aggregation command. Given that, the query itself is easy:</p>
<pre><code>Skip code block
var pipeline = [
{“$unwind”: “$finance” } ,
{“$match”: {“finance.k”: “sales”} },
{ $group:
{ _id: null,
numberOf: { “$sum”: 1 },
sales: {“$sum”: “$finance.v.v” }
}
}
];
R = db.tb.aggregate( pipeline );
printjson(R);
{
“result” : [
{
“_id” : null,
“numberOf” : 2,
“sales” : 236340
}
],
“ok” : 1
}
You can run a similar query for profit, just substitute “profit” for “sales” in the “$match” operator.
Oh, and here’s the map/reduce example:
Skip code block
map = function() {
var ret = { sales: 0.0 , profit: 0.0, count: 1 };
// iterate over ‘finance[]’ array
this.finance.forEach( function (i) {
if ( i.k == “sales” ) ret.sales =  i.v.v ;
if ( i.k == “profit” ) ret.profit =  i.v.v ;
} );
emit( 1, ret );
}
reduce = function(key, values) {
var ret = { sales: 0.0 , profit: 0.0, count: 0 };
values.forEach(function(v) {
ret.sales += v.sales;
ret.profit += v.profit;
ret.count += v.count;
});
return ret;
};
//
// run map/reduce
//
res = SOURCE.mapReduce( map, reduce );
</code></pre>
</div><hr><h3><p>Select * group by in mongo aggregation</p>
</h3><div><p>I am trying to do something that I think is quite simple. Suppose I have a series of records in mongo that have a common key, and variable number of attributes. I want to select all attributes and group by name across the records. For example</p>
<p>Tried</p>
<pre><code>DB.data.aggregate({ $group : { _id : “$Name” } })
</code></pre>
<p>Unfortunately I get back all the names as records but not the union of all the possible attributes.<br>
If you want to combine the attributes, you’ll need to add those to the group. For example, using$addToSet to find the unique values of the x,y,z attributes grouped by each name:</p>
<pre><code>db.data.aggregate(
{ $group : {

{ Name: George, x: 5, y: 3 }
{ Name: George, z: 9 }
{ Name: Rob, x: 12, y: 2 }
I would like to produce a CSV that looks like this:
Name     X   Y   Z
George   5   3   9
Rob      12  2

_id : “$Name”,
x: { $addToSet: “$x” },
y: { $addToSet: “$y” },
z: { $addToSet: “$z” },
}}
)
Returns:
Skip code block
{
“result” : [
{
“_id” : “Rob”,
“x” : [
12
],
“y” : [
2
],
“z” : [ ]
},
{
“_id” : “George”,
“x” : [
5
],
“y” : [
3
],
“z” : [
9
]
}
],
“ok” : 1
}
</code></pre>
</div><hr><h3><p>Creating custom Object ID in MongoDB</p>
</h3><div><p>I am creating a service for which I will use MongoDB as a storage backend. The service will produce a hash of the user input and then see if that same hash (+ input) already exists in our dataset.</p>
<p>The hash will be unique yet random ( = non-incremental/sequential), so my question is:<br>
Is it -legitimate- to use a random value for an Object ID? Example:<br>
$object_id = new MongoId(HEX-OF-96BIT-HASH);</p>
<p>Or will MongoDB treat the ObjectID differently from other server-produced ones, since a “real” ObjectID also contains timestamps, machine_id, etc?<br>
What are the pros and cons of using a ‘random’ value? I guess it would be statistically slower for the engine to update the index on inserts when the new _id’s are not in any way incremental – am I correct on that?<br>
Yes it is perfectly fine to use a random value for an object id, if some value is present in _id field of a document being stored, it is treated as objectId.<br>
Since _id field is always indexed, and primary key, you need to make sure that different objectid is generated for each object. There are some guidelines to optimize user defined object ids :</p>
<p>https://www.mongodb.org/display/DOCS/Optimizing+Object+IDs#OptimizingObjectIDs-Usethecollections%27naturalprimarykey%27intheidfield.</p>
<p>Whether it is good or bad depends upon it’s uniqueness. Of course the ObjectId provided by MongoDB is quite unique so this is a good thing. So long as you can replicate that uniqueness then you should be fine.<br>
There are no inherent risks/performance loses by using your own ID. I guess using it in string form might use up more index/storage/querying power but there you are using it in MongoID (ObjectId) form which should preserve the strengths of not storing it in a simple string.<br>
While any values, including hashes, can be used for the _id field, I would recommend against using random values for two reasons:<br>
1. You may need to develop a collision-management strategy in the case you produce identical random values for two different objects. In the question, you imply that you’ll generate IDs using a some type of a hash algorithm. I would not consider these values “random” as they are based on the content you are digesting with the hash. The probability of a collision then is a function of the diversity of content and the hash algorithm. If you are using something like MD5 or SHA-1, I wouldn’t worry about the algorithm, just the content you are hashing. If you need to develop a collision-management strategy then you definitely should not use random or hash-based IDs as collision management in a clustered environment is complicated and requires additional queries.<br>
2. Random values as well as hash values are purposefully meant to be dispersed on the number line. That (a) will require more of the B-tree index to be kept in memory at all times and (b) may cause variable insert performance due to B-tree rebalancing. MongoDB is optimized to handle ObjectIDs, which come in ascending order (with one second time granularity). You’re likely better off sticking with them.</p>
</div><hr><h3><p>How to resolve error :dbpath (/data/db/) does not exist permanently in MongoDB</p>
</h3><div><p>I have installed mongodb in my Ubuntu 10.04.<br>
I know that when it comes to start the mongodb server with the command “mongod“,then it expects /data/db folder and it can be easily resolved by creating “/data/db/”. One more way is to provide your own path using mongod –dbpath “path”,when we intend to give our own custom path for db.<br>
But while going through https://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/link i found that there is a configuration file.<br>
I made the following changes to it.</p>
<pre><code># mongodb.conf
dbpath=/EBS/Work/mongodb/data/db/
logpath=/EBS/Work/mongodb/mongodb.log
logappend=true
</code></pre>
<p>But still when I try to start the server with “<strong>mongod</strong>” it throws the same <strong>error i.e error :dbpath (/data/db/) does not exist</strong> . I wanted to know that how can I permanently redirect my dbpath to my own custom folder cause everytime you don’t want to type the path using “mongod –dbpath path”.Rather we look to make some changes in configuration file.<br>
Assuming you have followed the instructions to install a packaged version of MongoDB from 10gen, you should be starting and stopping mongod using service.<br>
To start mongod:<br>
sudo service mongodb start<br>
To stop mongod:<br>
sudo service mongodb stop<br>
If you use the service command to start and stop, it should be using the configuration file:/etc/mongodb.conf.<br>
<strong>Starting mongod from the command line</strong><br>
If you run mongod directly instead of using the service definition, you will also have to specify a configuration file as a command line parameter if you want one to be used:<br>
mongod –config /etc/mongodb.conf<br>
here is how i solve this problem. followed their offcial Doc . HERE. long story short , I created a directory inside /srv and excuted the command mongod –dbpath /srv/mongodb/ RAN like a champ.</p>
<pre><code>Skip code block
~$ mongod
Tue Jun  3 20:27:39.564 [initandlisten] MongoDB starting : pid=5380 port=27017 dbpath=/srv/mongodb/ 64-bit host= -SVE1411EGXB
Tue Jun  3 20:27:39.564 [initandlisten] db version v2.4.10
Tue Jun  3 20:27:39.564 [initandlisten] git version: e3d78955d181e475345ebd60053a4738a4c5268a
Tue Jun  3 20:27:39.564 [initandlisten] build info: Linux ip-10-2-29-40 2.6.21.7-2.ec2.v1.2.fc8xen #1 SMP Fri Nov 20 17:48:28 EST 2009 x86_64 BOOST_LIB_VERSION=1_49
Tue Jun  3 20:27:39.564 [initandlisten] allocator: tcmalloc
Tue Jun  3 20:27:39.564 [initandlisten] options: { dbpath: “/srv/mongodb/” }
Tue Jun  3 20:27:39.565 [initandlisten] exception in initAndListen: 10296
*********************************************************************
ERROR: dbpath (/srv/mongodb/) does not exist.
Create this directory or give existing directory in –dbpath.
See https://dochub.mongodb.org/core/startingandstoppingmongo
*********************************************************************
, terminating
Tue Jun  3 20:27:39.565 dbexit:
Tue Jun  3 20:27:39.565 [initandlisten] shutdown: going to close listening sockets…
Tue Jun  3 20:27:39.565 [initandlisten] shutdown: going to flush diaglog…
Tue Jun  3 20:27:39.565 [initandlisten] shutdown: going to close sockets…
Tue Jun  3 20:27:39.565 [initandlisten] shutdown: waiting for fs preallocator…
Tue Jun  3 20:27:39.565 [initandlisten] shutdown: lock for final commit…
Tue Jun  3 20:27:39.565 [initandlisten] shutdown: final commit…
Tue Jun  3 20:27:39.565 [initandlisten] shutdown: closing all files…
Tue Jun  3 20:27:39.565 [initandlisten] closeAllFiles() finished
Tue Jun  3 20:27:39.565 dbexit: really exiting now
~$ mongod –dbpath /srv/mongodb/
Tue Jun  3 20:27:55.616 [initandlisten] MongoDB starting : pid=5445 port=27017 dbpath=/srv/mongodb/ 64-bit host= -SVE1411EGXB
Tue Jun  3 20:27:55.616 [initandlisten] db version v2.4.10
Tue Jun  3 20:27:55.616 [initandlisten] git version: e3d78955d181e475345ebd60053a4738a4c5268a
Tue Jun  3 20:27:55.616 [initandlisten] build info: Linux ip-10-2-29-40 2.6.21.7-2.ec2.v1.2.fc8xen #1 SMP Fri Nov 20 17:48:28 EST 2009 x86_64 BOOST_LIB_VERSION=1_49
Tue Jun  3 20:27:55.616 [initandlisten] allocator: tcmalloc
Tue Jun  3 20:27:55.616 [initandlisten] options: { dbpath: “/srv/mongodb/” }
Tue Jun  3 20:27:55.617 [initandlisten] exception in initAndListen: 10296
~$ sudo service mongodb start
start: Job is already running: mongodb
~$ sudo service mongodb stop
mongodb stop/waiting
~$ cd /srv/
~$~$/srv$ ls
~$ /srv$ mkdir mongodb
mkdir: cannot create directory mongodb: Permission denied
~$ cd –  /srv
~$ sudo chgrp   /srv
~$ sudo chmod 775 /srv
~$ cd /srv/
/srv$ ls
/srv$ mkdir mongodb
/srv$ ls mongodb
/srv$ cd
~$ mongod –dbpath /srv/mongodb/
Tue Jun  3 20:40:57.457 [initandlisten] MongoDB starting : pid=6018 port=27017 dbpath=/srv/mongodb/ 64-bit host= -SVE1411EGXB
Tue Jun  3 20:40:57.457 [initandlisten] db version v2.4.10
Tue Jun  3 20:40:57.457 [initandlisten] git version: e3d78955d181e475345ebd60053a4738a4c5268a
Tue Jun  3 20:40:57.457 [initandlisten] build info: Linux ip-10-2-29-40 2.6.21.7-2.ec2.v1.2.fc8xen #1 SMP Fri Nov 20 17:48:28 EST 2009 x86_64 BOOST_LIB_VERSION=1_49
Tue Jun  3 20:40:57.457 [initandlisten] allocator: tcmalloc
Tue Jun  3 20:40:57.457 [initandlisten] options: { dbpath: “/srv/mongodb/” }
Tue Jun  3 20:40:57.520 [initandlisten] journal dir=/srv/mongodb/journal
Tue Jun  3 20:40:57.521 [initandlisten] recover : no journal files present, no recovery needed
Tue Jun  3 20:41:00.545 [initandlisten] preallocateIsFaster=true 36.86
Tue Jun  3 20:41:03.489 [initandlisten] preallocateIsFaster=true 35.06
Tue Jun  3 20:41:07.456 [initandlisten] preallocateIsFaster=true 34.44
Tue Jun  3 20:41:07.456 [initandlisten] preallocateIsFaster check took 9.935 secs
Tue Jun  3 20:41:07.456 [initandlisten] preallocating a journal file /srv/mongodb/journal/prealloc.0
Tue Jun  3 20:41:10.009 [initandlisten]         File Preallocator Progress: 985661440/1073741824    91%
Tue Jun  3 20:41:22.273 [initandlisten] preallocating a journal file /srv/mongodb/journal/prealloc.1
Tue Jun  3 20:41:25.009 [initandlisten]         File Preallocator Progress: 933232640/1073741824    86%
Tue Jun  3 20:41:37.119 [initandlisten] preallocating a journal file /srv/mongodb/journal/prealloc.2
Tue Jun  3 20:41:40.093 [initandlisten]         File Preallocator Progress: 1006632960/1073741824   93%
Tue Jun  3 20:41:52.450 [FileAllocator] allocating new datafile /srv/mongodb/local.ns, fillingwith zeroes…
Tue Jun  3 20:41:52.450 [FileAllocator] creating directory /srv/mongodb/_tmp
Tue Jun  3 20:41:52.503 [FileAllocator] done allocating datafile /srv/mongodb/local.ns, size: 16MB,  took0.022 secs
Tue Jun  3 20:41:52.517 [FileAllocator] allocating new datafile /srv/mongodb/local.0, filling with zeroes…
Tue Jun  3 20:41:52.537 [FileAllocator] done allocating datafile /srv/mongodb/local.0, size: 64MB,  took0.02 secs
Tue Jun  3 20:41:52.538 [websvr] admin web console waiting for connections on port 28017
Tue Jun  3 20:41:52.538 [initandlisten] waiting for connections on port 27017
</code></pre>
</div><hr><h3><p>install mongodb-10gen failed with apt-get</p>
</h3><div><p>Install mongodb-10gen as</p>
<p>https://docs.mongodb.org/manual/tutorial/install-mongodb-on-debian/but got error below:</p>
<p>dpkg: error processing /var/cache/apt/archives/mongodb-10gen_2.2.0_amd64.deb (–unpack):</p>
<p>trying to overwrite ‘/usr/bin/mongoimport’, which is also in package mongodb-clients 1:1.4.4-3<br>
configured to not write apport reports<br>
dpkg-deb: subprocess paste killed by signal (Broken pipe)<br>
Errors were encountered while processing:</p>
<pre><code>/var/cache/apt/archives/mongodb-10gen_2.2.0_amd64.deb
</code></pre>
<p>E: Sub-process /usr/bin/dpkg returned an error code (1)<br>
A bug here https://jira.mongodb.org/browse/SERVER-6910<br>
apt-get remove mongodb-clients first, and then the installation of mongodb-10gen should work.</p>
</div><hr><h3><p>Mongodb Explain for Aggregation framework</p>
</h3><div><p>Is there an explain function for the Aggregation framework in MongoDB? I can’t see it in the documentation.<br>
If not is there some other way to check, how a query performs within the aggregation framework?<br>
I know with find you just do<br>
db.collection.find().explain()<br>
But with the aggregation framework I get an error</p>
<pre><code>Skip code block
db.collection.aggregate(
{ $project : { “Tags._id” : 1 }},
{ $unwind : “$Tags” },
{ $match: {$or: [{“Tags._id”:”tag1?},{“Tags._id”:”tag2?}]}},
{
$group:
{
_id : { id: “$_id”},
“count”: { $sum:1 }
}
},
{ $sort: {“count”:-1}}
).explain()
</code></pre>
<p>There isn’t an explain() feature for the Aggregation Framework as at MongoDB 2.2.0, however you should read up on the documentation regarding Optimizing Performance.<br>
The following pipeline operators take advantage of an index when they occur at the beginning of the pipeline:</p>
<pre><code>$match $sort $limit $skip
</code></pre>
<p>The above operators can also use an index when placed before the following aggregation operators:<br>
$project $unwind $group<br>
So for your specific example, the pipeline will execute faster if you add an initial $match at the beginning to reduce the number of documents that need to be projected/unwound for the subsequent$match.<br>
Update<br>
MongoDB 2.6 (which is currently a Release Candidate) now includes an explain option for the aggregation pipeline.</p>
<pre><code>Skip code block
db.collection.aggregate([
{ $project : { “Tags._id” : 1 }},
{ $unwind : “$Tags” },
{ $match: {$or: [{“Tags._id”:”tag1?},{“Tags._id”:”tag2?}]}},
{ $group: {
_id : “$_id”,
count: { $sum:1 }
}},
{$sort: {“count”:-1}}
],
{
explain:true
}
)
</code></pre>
<p>Starting with version 2.6.x mongodb allows users to do explain with aggregation framework.<br>
All you need to do is to add explain : true</p>
<pre><code>db.records.aggregate(
[ …your pipeline…],
{ explain: true }
)
</code></pre>
<p>Thanks to Rafa, I know that it was possible to do even in 2.4, but only through runCommand(). But now you can use aggregate as well.</p>
<p><strong>Related Page:&nbsp;<a href="../../mongodb-aggregate">MongoDB Aggregate</a></strong></p>
</div><hr><h3><p>Run script against replica set in MongoDB</p>
</h3><div><p>I have replica set of 3 nodes and I want to run a cleanup script against it every end of day. What I would do if there was only single node would be a simple bash script:<br>
~/mongo/bin/mongo host:port cleanupScript.js<br>
But since I want to run the same script against replica-set I can’t use this approach. I would need to somehow find which node is primary and run the script against that node.<br>
So the question: Is there a way how to run the script against whole replica set and let the mongoprocess pick the primary node and execute on it?<br>
Thanks!<br>
The mongo shell can connect directly to a replica set – this works with 2.4 (current), 2.2 (previous) and 2.0 (the version before that).<br>
Assuming you have a replica set called myrs and your hosts are host1:27017, etc. use the following syntax:<br>
mongo -host myrs/host1:27017<br>
The shell will figure out the rest, including connecting to the primary and if the primary steps down or goes away it will reconnect to the new primary once it’s elected.<br>
Unfortunately, the ‘mongo’ shell does not support making connections to a replica set: only to individual nodes. You have two choices if you want to do this:<br>
1. Use a different language, which supports making a connection to a replica set. (PHP, Python, Perl, Java and Ruby all support this.)<br>
2. Have a driver script that runs an ‘rs.status()’ command, parses the output of that command, and determines the current primary. If it’s not the node you’ve connected to, then re-connect to the correct primary node<br>
I wish I had a better answer for you.<br>
I normally set priority for a node in replicaset. This gives me freedom to chose which node should get read and write load.<br>
In your case, I think, if you set priority for the nodes then you can always run your script against the highest priority node as that node will be primary almost all the time.<br>
Setting priority is quite simple and straight forward. You can check this link https://docs.mongodb.org/manual/tutorial/force-member-to-be-primary/<br>
I hope this will solve your problem.<br>
OKAY…. Probably this is what you need..</p>
<pre><code>#!/bin/bash
PRIMARY=`~/mongo/bin/mongo localhost:27017 –eval “printjson(rs.isMaster())” | grep “primary” | cut -d””” -f4`
echo “$PRIMARY”
~/mongo/bin/mongo “$PRIMARY” cleanupScript.js
</code></pre>
<p>Run this on any node and it will give you the “server:port” of the primary. Give full path to the mongo executable.. just to avoid errors.<br>
PS: the whole command is in the backticks. Somehow those are not visible so thought of telling you.</p>
</div><hr><h3><p>Couldn’t connect to server 127.0.0.1:27017</p>
</h3><div><p>I’m getting the following error:</p>
<pre><code>alex@alex-K43U:/$ mongo
MongoDB shell version: 2.2.0
connecting to: test
Thu Oct 11 11:46:53 Error: couldn’t connect to server 127.0.0.1:27017 src/mongo/shell/mongo.js:91
exception: connect failed
alex@alex-K43U:/$
</code></pre>
<p>This is what happens when I try to start mongodb:<br>
* Starting database mongodb &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [fail]<br>
I already tried mongo –repair<br>
I made chown and chmod to var, lib, and data/db and log mongodb.<br>
Not sure what else to do. Any suggestions?<br>
<strong>mongodb.log:</strong><br>
Skip code block</p>
<pre><code>***** SERVER RESTARTED *****
Thu Oct 11 08:29:40
Thu Oct 11 08:29:40 warning: 32-bit servers don’t have journaling enabled by default. Please use –journal if you want durability.
Thu Oct 11 08:29:40
Thu Oct 11 08:29:41 [initandlisten] MongoDB starting : pid=1052 port=27017 dbpath=/var/lib/mongodb 32-bit host=alex-K43U
Thu Oct 11 08:29:41 [initandlisten]
Thu Oct 11 08:29:41 [initandlisten] ** NOTE: when using MongoDB 32 bit, you are limited to about 2 gigabytes of data
Thu Oct 11 08:29:41 [initandlisten] **       see https://blog.mongodb.org/post/137788967/32-bit-limitations
Thu Oct 11 08:29:41 [initandlisten] **       with –journal, the limit is lower
Thu Oct 11 08:29:41 [initandlisten]
Thu Oct 11 08:29:41 [initandlisten] db version v2.2.0, pdfile version 4.5
Thu Oct 11 08:29:41 [initandlisten] git version: f5e83eae9cfbec7fb7a071321928f00d1b0c5207
Thu Oct 11 08:29:41 [initandlisten] build info: Linux domU-12-31-39-01-70-B4 2.6.21.7-2.fc8xen #1 SMP Fri Feb 15 12:39:36 EST 2008 i686 BOOST_LIB_VERSION=1_49
Thu Oct 11 08:29:41 [initandlisten] options: { config: “/etc/mongodb.conf”, dbpath: “/var/lib/mongodb”, logappend: “true”, logpath: “/var/log/mongodb/mongodb.log” }
Thu Oct 11 08:29:41 [initandlisten] Unable to check for journal files due to: boost::filesystem::basic_directory_iterator constructor: No such file or directory: “/var/lib/mongodb/journal”
**************
Unclean shutdown detected.
Please visit https://dochub.mongodb.org/core/repair for recovery instructions.
*************
Thu Oct 11 08:29:41 [initandlisten] exception in initAndListen: 12596 old lock file, terminating
Thu Oct 11 08:29:41 dbexit:
Thu Oct 11 08:29:41 [initandlisten] shutdown: going to close listening sockets…
Thu Oct 11 08:29:41 [initandlisten] shutdown: going to flush diaglog…
Thu Oct 11 08:29:41 [initandlisten] shutdown: going to close sockets…
Thu Oct 11 08:29:41 [initandlisten] shutdown: waiting for fs preallocator…
Thu Oct 11 08:29:41 [initandlisten] shutdown: closing all files…
Thu Oct 11 08:29:41 [initandlisten] closeAllFiles() finished
Thu Oct 11 08:29:41 dbexit: really exiting now
EDIT:
I removed the lock then did mongod repair and got this error:
Thu Oct 11 12:05:37 [initandlisten] exception in initAndListen: 10309 Unable to create/openlock file: /data/db/mongod.lock errno:13 Permission denied Is a mongod instance already running?, terminating
so I did it with sudo:
Skip code block
alex@alex-K43U:~$ sudo mongod –repair
Thu Oct 11 12:05:42
Thu Oct 11 12:05:42 warning: 32-bit servers don’t have journaling enabled by default. Please use –journal if you want durability.
Thu Oct 11 12:05:42
Thu Oct 11 12:05:42 [initandlisten] MongoDB starting : pid=5129 port=27017 dbpath=/data/db/ 32-bit host=alex-K43U
Thu Oct 11 12:05:42 [initandlisten]
Thu Oct 11 12:05:42 [initandlisten] ** NOTE: when using MongoDB 32 bit, you are limited to about 2 gigabytes of data
Thu Oct 11 12:05:42 [initandlisten] **       see https://blog.mongodb.org/post/137788967/32-bit-limitations
Thu Oct 11 12:05:42 [initandlisten] **       with –journal, the limit is lower
Thu Oct 11 12:05:42 [initandlisten]
Thu Oct 11 12:05:42 [initandlisten] db version v2.2.0, pdfile version 4.5
Thu Oct 11 12:05:42 [initandlisten] git version: f5e83eae9cfbec7fb7a071321928f00d1b0c5207
Thu Oct 11 12:05:42 [initandlisten] build info: Linux domU-12-31-39-01-70-B4 2.6.21.7-2.fc8xen #1 SMP Fri Feb 15 12:39:36 EST 2008 i686 BOOST_LIB_VERSION=1_49
Thu Oct 11 12:05:42 [initandlisten] options: { repair: true }
Thu Oct 11 12:05:42 [initandlisten] Unable to check for journal files due to: boost::filesystem::basic_directory_iterator constructor: No such file or directory: “/data/db/journal”
Thu Oct 11 12:05:42 [initandlisten] finished checking dbs
Thu Oct 11 12:05:42 dbexit:
Thu Oct 11 12:05:42 [initandlisten] shutdown: going to close listening sockets…
Thu Oct 11 12:05:42 [initandlisten] shutdown: going to flush diaglog…
Thu Oct 11 12:05:42 [initandlisten] shutdown: going to close sockets…
Thu Oct 11 12:05:42 [initandlisten] shutdown: waiting for fs preallocator…
Thu Oct 11 12:05:42 [initandlisten] shutdown: closing all files…
Thu Oct 11 12:05:42 [initandlisten] closeAllFiles() finished
Thu Oct 11 12:05:42 [initandlisten] shutdown: removing fs lock…
Thu Oct 11 12:05:42 dbexit: really exiting now
</code></pre>
<p>But still having the same problem.<br>
The log indicates that mongodb is terminating because there is an old lock file.<br>
If you are not and were not running with journaling, remove the lock file, run repair, and start mongodb again.<br>
If you are or were running with journaling turned on, see the relevant Mongo DB docs. Note that they say “If you are running with Journaling you should not do a repair to recover to a consistent state.” So if you were journaling, the repair may have made things worse.<br>
Skip code block<br>
<strong>Step 1:</strong> Remove lock file.<br>
sudo rm /var/lib/mongodb/mongod.lock<br>
<strong>Step 2:</strong> Repair mongodb.<br>
mongod –repair<br>
<strong>Step 3:</strong> start mongodb.<br>
sudo start mongodb<br>
or<br>
sudo service mongodb start<br>
<strong>Step 4</strong>: Check status of mongodb.<br>
sudo status mongodb<br>
or<br>
sudo service mongodb status<br>
<strong>Step 5:</strong> Start mongo console.<br>
mongo<br>
Did you run mongod before running mongo?<br>
I followed installation instructions for mongodb from https://docs.mongodb.org/manual/tutorial/install-mongodb-on-os-x/ and I had the same error as you only when I ran mongo before actually running the mongo process with mongod. I thought installing mongodb would also launch it but you need to launch it manually with mongod before you do anything else that needs mongodb.<br>
try<br>
sudo service mongodb start<br>
I solved my problem by this</p>
</div><hr><h3><p>Operate on all databases from the mongo shell</p>
</h3><div><p>We have a system with many different mongo databases. I regularly want to write ad-hoc queries that will apply to all (or a subset) of them, without having a priori knowledge of what databases are there.<br>
I can do show dbs, which will visually print a list, but is there a way to do something like:</p>
<pre><code>var db_list = listDatabases();
for (i = 0; i &lt; db_list.length; i++) {
do_something(db_list[i])
}
My problem with show dbs is that it doesn’t capture any return values, so I can’t do anything productive with the output.
You can use the ‘listDatabases’ admin command for that:
var db_list = db.adminCommand(‘listDatabases’);
That returns an object that looks like this:
Skip code block
{
“databases” : [
{
“name” : “test”,
“sizeOnDisk” : 2097152000,
“empty” : false
},
{
“name” : “local”,
“sizeOnDisk” : 1,
“empty” : true
}
],
“totalSize” : 8487174144,
“ok” : 1
}
</code></pre>
</div><hr><h3><p>I accidentally named a collection “stats” in MongoDB and now cannot rename it</p>
</h3><div><p>Oops.<br>
I use mongoose, and accidentally created a collection “stats”. I didn’t realize this was going to be an issue until a few weeks later, so I now need to rename (rather than just delete) the collection…<br>
However, my attempts have hit a predictable problem:</p>
<pre><code>PRIMARY&gt; db.stats.find();
</code></pre>
<p>Thu Oct 18 10:39:43 TypeError: db.stats.find is not a function (shell):1</p>
<pre><code>PRIMARY&gt; db.stats.renameCollection(‘statssnapshots’);
Thu Oct 18 10:39:45 TypeError: db.stats.renameCollection is not a function (shell):1
Try db[“stats”].find() and db[“stats”].renameCollection(‘statssnapshots’).
You could also do db.getCollection(“stats”).find().
</code></pre>
</div><hr><h3><p>Set max on mongo capped collection</p>
</h3><div><p>I have an existing collection that I need to convert into a Capped Collection using the method listed:</p>
<pre><code>&gt; db.runCommand({“convertToCapped”: “mycoll”, size: 100000});
However, the max field is not accepted as a parameter
&gt; db.mycol1.convertToCapped
function (bytes) {
if (!bytes) {
throw “have to specify # of bytes”;
}
return this._dbCommand({convertToCapped: this._shortName, size: bytes});
}
</code></pre>
<p>Any idea how to set this?<br>
max is only an option in the createCollection method, not convertToCapped:<br>
db.createCollection(“mycoll”, {capped:true, size:100000, max:100});<br>
There’s a cloneCollectionAsCapped, but it doesn’t look like there’s a max doc option there either:</p>
<p>https://docs.mongodb.org/manual/reference/command/cloneCollectionAsCapped/</p>
<p>You may need to create a new capped collection with the max parameter and transfer data and indices from the existing collection. See https://learnmongo.com/posts/easily-move-documents-between-collections-or-databases/</p>
</div><hr><h3><p>Does MongoDB reuse deleted space?</p>
</h3><div><p>First off, I know about this question:<br>
Auto compact the deleted space in mongodb?<br>
My question is not about shrinking DB file sizes though, but more about the reuse of deleted space. Say I have 100K documents in a collection, I then delete 50K of those. Will Mongo reuse the space within its data file that the deleted documents have freed? Or are they simply “marked” as deleted?<br>
I don’t care so much about the actual size of the file on disk, its more about “does it just grow and grow”.<br>
When documents are deleted the space left behind is put into a free list, yes. However, to use the space there will need to be similarly sized documents inserted later, and MongoDB will need to find an appropriate space for that document within a certain time frame (once it times out looking at the list, it will just append) otherwise the space re-use is not going to happen very often. This deletion is done within the data files, so there is no disk space reclamation happening here – all of this is done internally within the existing data files.<br>
If you subsequently do a repair, or resync a secondary from scratch, the data files are rewritten and the space on disk will be reclaimed (any padding on docs is also removed). This is where you will see actual space reclamation on-disk. For any other actions (compact included) the on disk usage will not change and may even increase.<br>
With 2.2 you can now use the collMod command and the use PowersOf2Sizes option to make the re-use of deleted space more likely. This means that the initial space allocation for a document is a bit less efficient (512 bytes for a 400 byte doc for example) but means that when a new doc is inserted it is more likely to be able to re-use that space. If you are deleting (or growing and hence moving) documents a lot, then this will be more efficient in the long term.<br>
For anyone that is interested, one of the people that wrote a lot of the storage code (Mathias Stearn) has a great presentation about the storage internals, which can be found here</p>
</div><hr><h3><p>Can not delete collection from mongodb</p>
</h3><div><p>Can not delete the collection from the shell,<br>
The thing that the collection is available and my php script is accessing it (selecting|updating)<br>
But when I used:<br>
db._registration.drop()<br>
it gives me an error:<br>
Date, JS Error: TypeErrorL db._registration has no properties (shell): 1<br>
The problem is not with deleting the collection. The problem is with accessing the collection. So you would not be able to update, find or do anything with it from the shell. As it was pointed in mongodb JIRA, this is a bug when a collection has characters like _, – or .<br>
Nevertheless this type of names for collections is acceptable, but it cause a problem in shell.<br>
You can delete it in shell with this command:</p>
<pre><code>db.getCollection(“_registration”).drop()
</code></pre>
<p>but I would rather rename it (of course if it is possible and will not end up with a lot of changing).</p>
</div><hr><h3><p>explain() in Mongodb: differences between “nscanned” and “nscannedObjects”</p>
</h3><div><p>I cannot get the exact difference between “nscanned” and “nscannedObjects” in the Mongodb’s explain query output.<br>
On MongoDB Explain documentation I can read:<br>
<strong>nscanned</strong> Number of items (documents or index entries) examined. Items might be objects or index keys. If a “covered index” is involved, nscanned may be higher than nscannedObjects.<br>
<strong>nscannedObjects</strong> Number of documents scanned.<br>
What’s the different between these two fields? And more specific what does exactly mean when I have a query, which uses a BtreeCursor (an index), and these two fields have two different</p>
<pre><code>values, for example:
{
“cursor” : “BtreeCursor a_1_b_1”,
“isMultiKey” : false,
“n” : 5,
“nscannedObjects” : 5,
“nscanned” : 9,
(…)
}
</code></pre>
<p>I know what a “covered index” is. I would like to understand exactly what the query did in the example above. Did it pass through (“scanned”) 9 elements (nscanned = 9), where all of them are index entries and read (“examined”) the value of only 5 of them (nscannedObjects = 5) to produce the result set?<br>
This means that :<br>
The query returned 5 documents – n<br>
scanned 9 documents from the index – nscanned<br>
and then read 5 full documents from the collection – nscannedObjects<br>
Similar example is given at :</p>
<p>https://docs.mongodb.org/manual/core/read-operations/#measuring-index-use</p>
</div><hr><h3><p>MongoDb Database vs Collection</p>
</h3><div><p>I am designing a system with MongoDb (64 bit version) to handle a large amount of users (around 100,000) and each user will have large amounts of data (around 1 million records).<br>
What is the best strategy of design?<br>
Dump all records in single collection<br>
Have a collection for each user<br>
Have a database for each user.<br>
Many Thanks,<br>
So you’re looking at somewhere in the region of 100 billion records (1 million records * 100,000 users).<br>
The preferred way to deal with large amounts of data is to create a sharded cluster that splits the data out over several servers that are presented as single logical unit via the mongo client.<br>
Therefore the answer to your question is put all your records in a single sharded collection.<br>
The number of shards required and configuration of the cluster is related to the size of the data and other factors such as the quantity and distribution of reads and writes. The answers to those questions are probably very specific to your unique situation, so I won’t attempt to guess them.<br>
I’d probably start by deciding how many shards you have the time and machines available to set up and testing the system on a cluster of that many machines. Based on the performance of that, you can decide whether you need more or fewer shards in your cluster</p>
</div><hr><h3><p>MongoDB upsert – insert or update</p>
</h3><div><p>I can’t find this in the documentation in any of the obvious places. I’d like to know if it is possible to know if mongo executed an insert or update in the upsert operation? Thanks.<br>
Yes there is, on a safe call (or getLastError) the update function will return an array with an upsert field and a updatedExisting field.<br>
You can read the PHP version of this here:</p>
<p><strong>https://php.net/manual/en/mongocollection.insert.phptowards</strong></p>
<p>the bottom.<br>
As it says within the documentation on upserted:<br>
If an upsert occured, this field will contain the new record’s _id field. For upserts, either this field or updatedExisting will be present (unless an error occurred).<br>
So upserted contains the _id of the new record if a insert was done or it will incrementupdatedExisting if it updated a record.<br>
I am sure a similar thing appears in all drivers.<br>
<strong>Edit</strong><br>
It will actually be a boolean in the updatedExisting field of true or false<br>
For reference only, in node.js:</p>
<pre><code>collection.update( source, target, { upsert: true }, function(err, result, upserted) {
…
});
For reference only, in node.js using Mongoose 3.6:
model.update( findquery, updatequery, { upsert: true }, function(err, numberAffected, rawResponse) {
…
});
Where rawResponse looks like this when it has updated an existing document:
{ updatedExisting: true,
n: 1,
connectionId: 222,
err: null,
ok: 1 }
And it looks like this when it has created a new document:
{ updatedExisting: false,
upserted: 51eebc080eb3e2208a630d8e,
n: 1,
connectionId: 222,
err: null,
(Both cases would return numberAffected = 1)
</code></pre>
</div><hr><h3><p>Fastest way to remove duplicate documents in mongodb</p>
</h3><div><p>I have approximately 1.7M documents in mongodb (in future 10m+). Some of them represent duplicate entry which I do not want. Structure of document is something like this:</p>
<pre><code>{
_id: 14124412,
nodes: [
12345,
54321
],
name: “Some beauty”
}
</code></pre>
<p>Document is duplicate if it has at <strong>least one node same</strong> as another document with <strong>same name</strong>. What is the fastest way to remove duplicates?<br>
Assuming you want to permanently delete docs that contain a duplicate name + nodes entry from the collection, you can add a unique index with the dropDups: true option:<br>
db.test.ensureIndex({name: 1, nodes: 1}, {unique: true, dropDups: true})<br>
As the docs say, use extreme caution with this as it will delete data from your database. Back up your database first in case it doesn’t do exactly as you’re expecting.</p>
</div><hr></body></html>