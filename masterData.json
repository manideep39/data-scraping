{
  "questions": [
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function sayHi() {\n      console.log(name);\n      console.log(age);\n      var name = 'Lydia';\n      let age = 21;\n    }\n    \n    sayHi();",
      "explanation": "Within the function, we first declare the `name` variable with the `var` keyword. This means that the variable gets hoisted (memory space is set up during the creation phase) with the default value of `undefined`, until we actually get to the line where we define the variable. We haven't defined the variable yet on the line where we try to log the `name` variable, so it still holds the value of `undefined`.\n\nVariables with the `let` keyword (and `const`) are hoisted, but unlike `var`, don't get _initialized_. They are not accessible before the line we declare (initialize) them. This is called the \"temporal dead zone\". When we try to access the variables before they are declared, JavaScript throws a `ReferenceError`.",
      "options": [
        { "text": "`Lydia` and `undefined`", "correct": false },
        { "text": "`Lydia` and `ReferenceError`", "correct": false },
        { "text": "`ReferenceError` and `21`", "correct": false },
        { "text": "`undefined` and `ReferenceError`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    for (var i = 0; i < 3; i++) {\n      setTimeout(() => console.log(i), 1);\n    }\n    \n    for (let i = 0; i < 3; i++) {\n      setTimeout(() => console.log(i), 1);\n    }",
      "explanation": "Because of the event queue in JavaScript, the `setTimeout` callback function is called _after_ the loop has been executed. Since the variable `i` in the first loop was declared using the `var` keyword, this value was global. During the loop, we incremented the value of `i` by `1` each time, using the unary operator `++`. By the time the `setTimeout` callback function was invoked, `i` was equal to `3` in the first example.\n\nIn the second loop, the variable `i` was declared using the `let` keyword: variables declared with the `let` (and `const`) keyword are block-scoped (a block is anything between `{ }`). During each iteration, `i` will have a new value, and each value is scoped inside the loop.",
      "options": [
        { "text": "`0 1 2` and `0 1 2`", "correct": false },
        { "text": "`0 1 2` and `3 3 3`", "correct": false },
        { "text": "`3 3 3` and `0 1 2`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const shape = {\n      radius: 10,\n      diameter() {\n        return this.radius * 2;\n      },\n      perimeter: () => 2 * Math.PI * this.radius,\n    };\n    \n    console.log(shape.diameter());\n    console.log(shape.perimeter());",
      "explanation": "Note that the value of `diameter` is a regular function, whereas the value of `perimeter` is an arrow function.\n\nWith arrow functions, the `this` keyword refers to its current surrounding scope, unlike regular functions! This means that when we call `perimeter`, it doesn't refer to the shape object, but to its surrounding scope (window for example).\n\nThere is no value `radius` on that object, which returns `NaN`.",
      "options": [
        { "text": "`20` and `62.83185307179586`", "correct": false },
        { "text": "`20` and `NaN`", "correct": true },
        { "text": "`20` and `63`", "correct": false },
        { "text": "`NaN` and `63`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    +true;\n    !'Lydia';",
      "explanation": "The unary plus tries to convert an operand to a number. `true` is `1`, and `false` is `0`.\n\nThe string `'Lydia'` is a truthy value. What we're actually asking, is \"is this truthy value falsy?\". This returns `false`.",
      "options": [
        { "text": "`1` and `false`", "correct": true },
        { "text": "`false` and `NaN`", "correct": false },
        { "text": "`false` and `false`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "Which one is true?\n    const bird = {\n      size: 'small',\n    };\n    \n    const mouse = {\n      name: 'Mickey',\n      small: true,\n    };",
      "explanation": "In JavaScript, all object keys are strings (unless it's a Symbol). Even though we might not _type_ them as strings, they are always converted into strings under the hood.\n\nJavaScript interprets (or unboxes) statements. When we use bracket notation, it sees the first opening bracket `[` and keeps going until it finds the closing bracket `]`. Only then, it will evaluate the statement.\n\n`mouse[bird.size]`: First it evaluates `bird.size`, which is `\"small\"`. `mouse[\"small\"]` returns `true`\n\nHowever, with dot notation, this doesn't happen. `mouse` does not have a key called `bird`, which means that `mouse.bird` is `undefined`. Then, we ask for the `size` using dot notation: `mouse.bird.size`. Since `mouse.bird` is `undefined`, we're actually asking `undefined.size`. This isn't valid, and will throw an error similar to `Cannot read property \"size\" of undefined`.",
      "options": [
        { "text": "`mouse.bird.size` is not valid", "correct": true },
        { "text": "`mouse[bird.size]` is not valid", "correct": false },
        { "text": "`mouse[bird[\"size\"]]` is not valid", "correct": false },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    let c = { greeting: 'Hey!' };\n    let d;\n    \n    d = c;\n    c.greeting = 'Hello';\n    console.log(d.greeting);",
      "explanation": "In JavaScript, all objects interact by _reference_ when setting them equal to each other.\n\nFirst, variable `c` holds a value to an object. Later, we assign `d` with the same reference that `c` has to the object.\n\n![](https://i.imgur.com/ko5k0fs.png)\n\nWhen you change one object, you change all of them.",
      "options": [
        { "text": "`Hello`", "correct": true },
        { "text": "`Hey!`", "correct": false },
        { "text": "`undefined`", "correct": false },
        { "text": "`ReferenceError`", "correct": false },
        { "text": "`TypeError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    let a = 3;\n    let b = new Number(3);\n    let c = 3;\n    \n    console.log(a == b);\n    console.log(a === b);\n    console.log(b === c);",
      "explanation": "`new Number()` is a built-in function constructor. Although it looks like a number, it's not really a number: it has a bunch of extra features and is an object.\n\nWhen we use the `==` operator, it only checks whether it has the same _value_. They both have the value of `3`, so it returns `true`.\n\nHowever, when we use the `===` operator, both value _and_ type should be the same. It's not: `new Number()` is not a number, it's an **object**. Both return `false.`",
      "options": [
        { "text": "`true` `false` `true`", "correct": false },
        { "text": "`false` `false` `true`", "correct": false },
        { "text": "`true` `false` `false`", "correct": true },
        { "text": "`false` `true` `true`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    class Chameleon {\n      static colorChange(newColor) {\n        this.newColor = newColor;\n        return this.newColor;\n      }\n    \n      constructor({ newColor = 'green' } = {}) {\n        this.newColor = newColor;\n      }\n    }\n    \n    const freddie = new Chameleon({ newColor: 'purple' });\n    console.log(freddie.colorChange('orange'));",
      "explanation": "The `colorChange` function is static. Static methods are designed to live only on the constructor in which they are created, and cannot be passed down to any children. Since `freddie` is a child, the function is not passed down, and not available on the `freddie` instance: a `TypeError` is thrown.",
      "options": [
        { "text": "`orange`", "correct": false },
        { "text": "`purple`", "correct": false },
        { "text": "`green`", "correct": false },
        { "text": "`TypeError`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    let greeting;\n    greetign = {}; // Typo!\n    console.log(greetign);",
      "explanation": "It logs the object, because we just created an empty object on the global object! When we mistyped `greeting` as `greetign`, the JS interpreter actually saw this as `global.greetign = {}` (or `window.greetign = {}` in a browser).\n\nIn order to avoid this, we can use `\"use strict\"`. This makes sure that you have declared a variable before setting it equal to anything.",
      "options": [
        { "text": "`{}`", "correct": true },
        {
          "text": "`ReferenceError: greetign is not defined`",
          "correct": false
        },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What happens when we do this?\n    function bark() {\n      console.log('Woof!');\n    }\n    \n    bark.animal = 'dog';",
      "explanation": "This is possible in JavaScript, because functions are objects! (Everything besides primitive types are objects)\n\nA function is a special type of object. The code you write yourself isn't the actual function. The function is an object with properties. This property is invocable.",
      "options": [
        { "text": "", "correct": true },
        {
          "text": "`SyntaxError`. You cannot add properties to a function this way.",
          "correct": false
        },
        { "text": "`\"Woof\"` gets logged.", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function Person(firstName, lastName) {\n      this.firstName = firstName;\n      this.lastName = lastName;\n    }\n    \n    const member = new Person('Lydia', 'Hallie');\n    Person.getFullName = function() {\n      return `${this.firstName} ${this.lastName}`;\n    };\n    \n    console.log(member.getFullName());",
      "explanation": "In JavaScript, functions are objects, and therefore, the method `getFullName` gets added to the constructor function object itself. For that reason, we can call `Person.getFullName()`, but `member.getFullName` throws a `TypeError`.\n\nIf you want a method to be available to all object instances, you have to add it to the prototype property:\n\n    Person.prototype.getFullName = function() {\n      return `${this.firstName} ${this.lastName}`;\n    };",
      "options": [
        { "text": "`TypeError`", "correct": true },
        { "text": "`SyntaxError`", "correct": false },
        { "text": "`Lydia Hallie`", "correct": false },
        { "text": "`undefined` `undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    Person.prototype.getFullName = function() {\n      return `${this.firstName} ${this.lastName}`;\n    };",
      "explanation": "For `sarah`, we didn't use the `new` keyword. When using `new`, `this` refers to the new empty object we create. However, if you don't add `new`, `this` refers to the **global object**!\n\nWe said that `this.firstName` equals `\"Sarah\"` and `this.lastName` equals `\"Smith\"`. What we actually did, is defining `global.firstName = 'Sarah'` and `global.lastName = 'Smith'`. `sarah` itself is left `undefined`, since we don't return a value from the `Person` function.",
      "options": [
        {
          "text": "`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` and `undefined`",
          "correct": true
        },
        {
          "text": "`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` and `Person {firstName: \"Sarah\", lastName: \"Smith\"}`",
          "correct": false
        },
        {
          "text": "`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` and `{}`",
          "correct": false
        },
        {
          "text": "`Person {firstName: \"Lydia\", lastName: \"Hallie\"}` and `ReferenceError`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What are the three phases of event propagation?\n    function Person(firstName, lastName) {\n      this.firstName = firstName;\n      this.lastName = lastName;\n    }\n    \n    const lydia = new Person('Lydia', 'Hallie');\n    const sarah = Person('Sarah', 'Smith');\n    \n    console.log(lydia);\n    console.log(sarah);",
      "explanation": "During the **capturing** phase, the event goes through the ancestor elements down to the target element. It then reaches the **target** element, and **bubbling** begins.\n\n![](https://i.imgur.com/N18oRgd.png)",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "All object have prototypes.\n    function sum(a, b) {\n      return a + b;\n    }\n    \n    sum(1, '2');",
      "explanation": "All objects have prototypes, except for the **base object**. The base object is the object created by the user, or an object that is created using the `new` keyword. The base object has access to some methods and properties, such as `.toString`. This is the reason why you can use built-in JavaScript methods! All of such methods are available on the prototype. Although JavaScript can't find it directly on your object, it goes down the prototype chain and finds it there, which makes it accessible for you.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    let number = 0;\n    console.log(number++);\n    console.log(++number);\n    console.log(number);",
      "explanation": "JavaScript is a **dynamically typed language**: we don't specify what types certain variables are. Values can automatically be converted into another type without you knowing, which is called _implicit type coercion_. **Coercion** is converting from one type into another.\n\nIn this example, JavaScript converts the number `1` into a string, in order for the function to make sense and return a value. During the addition of a numeric type (`1`) and a string type (`'2'`), the number is treated as a string. We can concatenate strings like `\"Hello\" + \"World\"`, so what's happening here is `\"1\" + \"2\"` which returns `\"12\"`.",
      "options": [
        { "text": "`NaN`", "correct": false },
        { "text": "`TypeError`", "correct": false },
        { "text": "`\"12\"`", "correct": true },
        { "text": "`3`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function getPersonInfo(one, two, three) {\n      console.log(one);\n      console.log(two);\n      console.log(three);\n    }\n    \n    const person = 'Lydia';\n    const age = 21;\n    \n    getPersonInfo`${person} is ${age} years old`;",
      "explanation": "The **postfix** unary operator `++`:\n\n1.  Returns the value (this returns `0`)\n2.  Increments the value (number is now `1`)\n\nThe **prefix** unary operator `++`:\n\n1.  Increments the value (number is now `2`)\n2.  Returns the value (this returns `2`)\n\nThis returns `0 2 2`.",
      "options": [
        { "text": "`1` `1` `2`", "correct": false },
        { "text": "`1` `2` `2`", "correct": false },
        { "text": "`0` `2` `2`", "correct": true },
        { "text": "`0` `1` `2`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function checkAge(data) {\n      if (data === { age: 18 }) {\n        console.log('You are an adult!');\n      } else if (data == { age: 18 }) {\n        console.log('You are still an adult.');\n      } else {\n        console.log(`Hmm.. You don't have an age I guess`);\n      }\n    }\n    \n    checkAge({ age: 18 });",
      "explanation": "If you use tagged template literals, the value of the first argument is always an array of the string values. The remaining arguments get the values of the passed expressions!",
      "options": [
        {
          "text": "`\"Lydia\"` `21` `[\"\", \" is \", \" years old\"]`",
          "correct": false
        },
        {
          "text": "`[\"\", \" is \", \" years old\"]` `\"Lydia\"` `21`",
          "correct": true
        },
        {
          "text": "`\"Lydia\"` `[\"\", \" is \", \" years old\"]` `21`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function getAge(...args) {\n      console.log(typeof args);\n    }\n    \n    getAge(21);",
      "explanation": "When testing equality, primitives are compared by their _value_, while objects are compared by their _reference_. JavaScript checks if the objects have a reference to the same location in memory.\n\nThe two objects that we are comparing don't have that: the object we passed as a parameter refers to a different location in memory than the object we used in order to check equality.\n\nThis is why both `{ age: 18 } === { age: 18 }` and `{ age: 18 } == { age: 18 }` return `false`.",
      "options": [
        { "text": "`You are an adult!`", "correct": false },
        { "text": "`You are still an adult.`", "correct": false },
        { "text": "`Hmm.. You don't have an age I guess`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function getAge() {\n      'use strict';\n      age = 21;\n      console.log(age);\n    }\n    \n    getAge();",
      "explanation": "The rest parameter (`...args`) lets us \"collect\" all remaining arguments into an array. An array is an object, so `typeof args` returns `\"object\"`",
      "options": [
        { "text": "`\"number\"`", "correct": false },
        { "text": "`\"array\"`", "correct": false },
        { "text": "`\"object\"`", "correct": true },
        { "text": "`\"NaN\"`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const sum = eval('10*10+5');",
      "explanation": "With `\"use strict\"`, you can make sure that you don't accidentally declare global variables. We never declared the variable `age`, and since we use `\"use strict\"`, it will throw a reference error. If we didn't use `\"use strict\"`, it would have worked, since the property `age` would have gotten added to the global object.",
      "options": [
        { "text": "`21`", "correct": false },
        { "text": "`undefined`", "correct": false },
        { "text": "`ReferenceError`", "correct": true },
        { "text": "`TypeError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the value of sum?\n    sessionStorage.setItem('cool_secret', 123);",
      "explanation": "`eval` evaluates codes that's passed as a string. If it's an expression, like in this case, it evaluates the expression. The expression is `10 * 10 + 5`. This returns the number `105`.",
      "options": [
        { "text": "`105`", "correct": true },
        { "text": "`\"105\"`", "correct": false },
        { "text": "`TypeError`", "correct": false },
        { "text": "`\"10*10+5\"`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "How long is cool\\_secret accessible?\n    var num = 8;\n    var num = 10;\n    \n    console.log(num);",
      "explanation": "The data stored in `sessionStorage` is removed after closing the _tab_.\n\nIf you used `localStorage`, the data would've been there forever, unless for example `localStorage.clear()` is invoked.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": true },
        { "text": "", "correct": false },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const obj = { 1: 'a', 2: 'b', 3: 'c' };\n    const set = new Set([1, 2, 3, 4, 5]);\n    \n    obj.hasOwnProperty('1');\n    obj.hasOwnProperty(1);\n    set.has('1');\n    set.has(1);",
      "explanation": "With the `var` keyword, you can declare multiple variables with the same name. The variable will then hold the latest value.\n\nYou cannot do this with `let` or `const` since they're block-scoped.",
      "options": [
        { "text": "`8`", "correct": false },
        { "text": "`10`", "correct": true },
        { "text": "`SyntaxError`", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const obj = { a: 'one', b: 'two', a: 'three' };\n    console.log(obj);",
      "explanation": "All object keys (excluding Symbols) are strings under the hood, even if you don't type it yourself as a string. This is why `obj.hasOwnProperty('1')` also returns true.\n\nIt doesn't work that way for a set. There is no `'1'` in our set: `set.has('1')` returns `false`. It has the numeric type `1`, `set.has(1)` returns `true`.",
      "options": [
        { "text": "`false` `true` `false` `true`", "correct": false },
        { "text": "`false` `true` `true` `true`", "correct": false },
        { "text": "`true` `true` `false` `true`", "correct": true },
        { "text": "`true` `true` `true` `true`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    for (let i = 1; i < 5; i++) {\n      if (i === 3) continue;\n      console.log(i);\n    }",
      "explanation": "If you have two keys with the same name, the key will be replaced. It will still be in its first position, but with the last specified value.",
      "options": [
        { "text": "`{ a: \"one\", b: \"two\" }`", "correct": false },
        { "text": "`{ b: \"two\", a: \"three\" }`", "correct": false },
        { "text": "`{ a: \"three\", b: \"two\" }`", "correct": true },
        { "text": "`SyntaxError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "The JavaScript global execution context creates two things for you: the global object, and the \"this\" keyword.\n    String.prototype.giveLydiaPizza = () => {\n      return 'Just give Lydia pizza already!';\n    };\n    \n    const name = 'Lydia';\n    \n    name.giveLydiaPizza();",
      "explanation": "The base execution context is the global execution context: it's what's accessible everywhere in your code.",
      "options": [
        { "text": "", "correct": true },
        { "text": "", "correct": false },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const a = {};\n    const b = { key: 'b' };\n    const c = { key: 'c' };\n    \n    a[b] = 123;\n    a[c] = 456;\n    \n    console.log(a[b]);",
      "explanation": "The `continue` statement skips an iteration if a certain condition returns `true`.",
      "options": [
        { "text": "`1` `2`", "correct": false },
        { "text": "`1` `2` `3`", "correct": false },
        { "text": "`1` `2` `4`", "correct": true },
        { "text": "`1` `3` `4`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const foo = () => console.log('First');\n    const bar = () => setTimeout(() => console.log('Second'));\n    const baz = () => console.log('Third');\n    \n    bar();\n    foo();\n    baz();",
      "explanation": "`String` is a built-in constructor, which we can add properties to. I just added a method to its prototype. Primitive strings are automatically converted into a string object, generated by the string prototype function. So, all strings (string objects) have access to that method!",
      "options": [
        { "text": "`\"Just give Lydia pizza already!\"`", "correct": true },
        { "text": "`TypeError: not a function`", "correct": false },
        { "text": "`SyntaxError`", "correct": false },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    \n      \n        \n          Click!",
      "explanation": "Object keys are automatically converted into strings. We are trying to set an object as a key to object `a`, with the value of `123`.\n\nHowever, when we stringify an object, it becomes `\"[object Object]\"`. So what we are saying here, is that `a[\"[object Object]\"] = 123`. Then, we can try to do the same again. `c` is another object that we are implicitly stringifying. So then, `a[\"[object Object]\"] = 456`.\n\nThen, we log `a[b]`, which is actually `a[\"[object Object]\"]`. We just set that to `456`, so it returns `456`.",
      "options": [
        { "text": "`123`", "correct": false },
        { "text": "`456`", "correct": true },
        { "text": "`undefined`", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    \n      \n        Click here!",
      "explanation": "We have a `setTimeout` function and invoked it first. Yet, it was logged last.\n\nThis is because in browsers, we don't just have the runtime engine, we also have something called a `WebAPI`. The `WebAPI` gives us the `setTimeout` function to start with, and for example the DOM.\n\nAfter the _callback_ is pushed to the WebAPI, the `setTimeout` function itself (but not the callback!) is popped off the stack.\n\n![](https://i.imgur.com/X5wsHOg.png)\n\nNow, `foo` gets invoked, and `\"First\"` is being logged.\n\n![](https://i.imgur.com/Pvc0dGq.png)\n\n`foo` is popped off the stack, and `baz` gets invoked. `\"Third\"` gets logged.\n\n![](https://i.imgur.com/WhA2bCP.png)\n\nThe WebAPI can't just add stuff to the stack whenever it's ready. Instead, it pushes the callback function to something called the _queue_.\n\n![](https://i.imgur.com/NSnDZmU.png)\n\nThis is where an event loop starts to work. An **event loop** looks at the stack and task queue. If the stack is empty, it takes the first thing on the queue and pushes it onto the stack.\n\n![](https://i.imgur.com/uyiScAI.png)\n\n`bar` gets invoked, `\"Second\"` gets logged, and it's popped off the stack.",
      "options": [
        { "text": "`First` `Second` `Third`", "correct": false },
        { "text": "`First` `Third` `Second`", "correct": true },
        { "text": "`Second` `First` `Third`", "correct": false },
        { "text": "`Second` `Third` `First`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What is the event.target when clicking the button?\n    const person = { name: 'Lydia' };\n    \n    function sayHi(age) {\n      return `${this.name} is ${age}`;\n    }\n    \n    console.log(sayHi.call(person, 21));\n    console.log(sayHi.bind(person, 21));",
      "explanation": "The deepest nested element that caused the event is the target of the event. You can stop bubbling by `event.stopPropagation`",
      "options": [
        { "text": "`div`", "correct": false },
        { "text": "`div`", "correct": false },
        { "text": "`button`", "correct": true },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "When you click the paragraph, what's the logged output?\n    function sayHi() {\n      return (() => 0)();\n    }\n    \n    console.log(typeof sayHi());",
      "explanation": "If we click `p`, we see two logs: `p` and `div`. During event propagation, there are 3 phases: capturing, target, and bubbling. By default, event handlers are executed in the bubbling phase (unless you set `useCapture` to `true`). It goes from the deepest nested element outwards.",
      "options": [
        { "text": "`p` `div`", "correct": true },
        { "text": "`div` `p`", "correct": false },
        { "text": "`p`", "correct": false },
        { "text": "`div`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    0;\n    new Number(0);\n    ('');\n    (' ');\n    new Boolean(false);\n    undefined;",
      "explanation": "With both, we can pass the object to which we want the `this` keyword to refer to. However, `.call` is also _executed immediately_!\n\n`.bind.` returns a _copy_ of the function, but with a bound context! It is not executed immediately.",
      "options": [
        { "text": "`undefined is 21` `Lydia is 21`", "correct": false },
        { "text": "`function` `function`", "correct": false },
        { "text": "`Lydia is 21` `Lydia is 21`", "correct": false },
        { "text": "`Lydia is 21` `function`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    console.log(typeof typeof 1);",
      "explanation": "The `sayHi` function returns the returned value of the immediately invoked function expression (IIFE). This function returned `0`, which is type `\"number\"`.\n\nFYI: there are only 7 built-in types: `null`, `undefined`, `boolean`, `number`, `string`, `object`, and `symbol`. `\"function\"` is not a type, since functions are objects, it's of type `\"object\"`.",
      "options": [
        { "text": "`\"object\"`", "correct": false },
        { "text": "`\"number\"`", "correct": true },
        { "text": "`\"function\"`", "correct": false },
        { "text": "`\"undefined\"`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "Which of these values are falsy?\n    const numbers = [1, 2, 3];\n    numbers[10] = 11;\n    console.log(numbers);",
      "explanation": "There are 8 falsy values:\n\n*   `undefined`\n*   `null`\n*   `NaN`\n*   `false`\n*   `''` (empty string)\n*   `0`\n*   `-0`\n*   `0n` (BigInt(0))\n\nFunction constructors, like `new Number` and `new Boolean` are truthy.",
      "options": [
        { "text": "`0`, `''`, `undefined`", "correct": true },
        {
          "text": "`0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`",
          "correct": false
        },
        {
          "text": "`0`, `''`, `new Boolean(false)`, `undefined`",
          "correct": false
        },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    (() => {\n      let x, y;\n      try {\n        throw new Error();\n      } catch (x) {\n        (x = 1), (y = 2);\n        console.log(x);\n      }\n      console.log(x);\n      console.log(y);\n    })();",
      "explanation": "`typeof 1` returns `\"number\"`. `typeof \"number\"` returns `\"string\"`",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "(empty string)", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "(BigInt(0))", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    [[0, 1], [2, 3]].reduce(\n      (acc, cur) => {\n        return acc.concat(cur);\n      },\n      [1, 2],\n    );",
      "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \"empty slots\". These actually have the value of `undefined`, but you will see something like:\n\n`[1, 2, 3, 7 x empty, 11]`\n\ndepending on where you run it (it's different for every browser, node, etc.)",
      "options": [
        { "text": "`\"number\"`", "correct": false },
        { "text": "`\"string\"`", "correct": false },
        { "text": "`\"object\"`", "correct": true },
        { "text": "`\"undefined\"`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    !!null;\n    !!'';\n    !!1;",
      "explanation": "The `catch` block receives the argument `x`. This is not the same `x` as the variable when we pass arguments. This variable `x` is block-scoped.\n\nLater, we set this block-scoped variable equal to `1`, and set the value of the variable `y`. Now, we log the block-scoped variable `x`, which is equal to `1`.\n\nOutside of the `catch` block, `x` is still `undefined`, and `y` is `2`. When we want to `console.log(x)` outside of the `catch` block, it returns `undefined`, and `y` returns `2`.",
      "options": [
        { "text": "`[1, 2, 3, 7 x null, 11]`", "correct": true },
        { "text": "`[1, 2, 3, 11]`", "correct": false },
        { "text": "`[1, 2, 3, 7 x empty, 11]`", "correct": false },
        { "text": "`SyntaxError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "Everything in JavaScript is either a...\n    setInterval(() => console.log('Hi'), 1000);",
      "explanation": "JavaScript only has primitive types and objects.\n\nPrimitive types are `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, and `symbol`.\n\nWhat differentiates a primitive from an object is that primitives do not have any properties or methods; however, you'll note that `'foo'.toUpperCase()` evaluates to `'FOO'` and does not result in a `TypeError`. This is because when you try to access a property or method on a primitive like a string, JavaScript will implicitly wrap the primitive type using one of the wrapper classes, i.e. `String`, and then immediately discard the wrapper after the expression evaluates. All primitives except for `null` and `undefined` exhibit this behaviour.",
      "options": [
        { "text": "`1` `undefined` `2`", "correct": true },
        { "text": "`undefined` `undefined` `undefined`", "correct": false },
        { "text": "`1` `1` `2`", "correct": false },
        { "text": "`1` `undefined` `undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    [...'Lydia'];",
      "explanation": "`[1, 2]` is our initial value. This is the value we start with, and the value of the very first `acc`. During the first round, `acc` is `[1,2]`, and `cur` is `[0, 1]`. We concatenate them, which results in `[1, 2, 0, 1]`.\n\nThen, `[1, 2, 0, 1]` is `acc` and `[2, 3]` is `cur`. We concatenate them, and get `[1, 2, 0, 1, 2, 3]`",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": true },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function* generator(i) {\n      yield i;\n      yield i * 2;\n    }\n    \n    const gen = generator(10);\n    \n    console.log(gen.next().value);\n    console.log(gen.next().value);",
      "explanation": "`null` is falsy. `!null` returns `true`. `!true` returns `false`.\n\n`\"\"` is falsy. `!\"\"` returns `true`. `!true` returns `false`.\n\n`1` is truthy. `!1` returns `false`. `!false` returns `true`.",
      "options": [
        { "text": "`[0, 1, 2, 3, 1, 2]`", "correct": false },
        { "text": "`[6, 1, 2]`", "correct": true },
        { "text": "`[1, 2, 0, 1, 2, 3]`", "correct": false },
        { "text": "`[1, 2, 6]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What does the setInterval method return in the browser?\n    const firstPromise = new Promise((res, rej) => {\n      setTimeout(res, 500, 'one');\n    });\n    \n    const secondPromise = new Promise((res, rej) => {\n      setTimeout(res, 100, 'two');\n    });\n    \n    Promise.race([firstPromise, secondPromise]).then(res => console.log(res));",
      "explanation": "It returns a unique id. This id can be used to clear that interval with the `clearInterval()` function.",
      "options": [
        { "text": "`false` `true` `false`", "correct": true },
        { "text": "`false` `false` `true`", "correct": false },
        { "text": "`false` `true` `true`", "correct": false },
        { "text": "`true` `true` `false`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What does this return?\n    let person = { name: 'Lydia' };\n    const members = [person];\n    person = null;\n    \n    console.log(members);",
      "explanation": "A string is an iterable. The spread operator maps every character of an iterable to one element.",
      "options": [
        { "text": "", "correct": true },
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const person = {\n      name: 'Lydia',\n      age: 21,\n    };\n    \n    for (const item in person) {\n      console.log(item);\n    }",
      "explanation": "Regular functions cannot be stopped mid-way after invocation. However, a generator function can be \"stopped\" midway, and later continue from where it stopped. Every time a generator function encounters a `yield` keyword, the function yields the value specified after it. Note that the generator function in that case doesn’t _return_ the value, it _yields_ the value.\n\nFirst, we initialize the generator function with `i` equal to `10`. We invoke the generator function using the `next()` method. The first time we invoke the generator function, `i` is equal to `10`. It encounters the first `yield` keyword: it yields the value of `i`. The generator is now \"paused\", and `10` gets logged.\n\nThen, we invoke the function again with the `next()` method. It starts to continue where it stopped previously, still with `i` equal to `10`. Now, it encounters the next `yield` keyword, and yields `i * 2`. `i` is equal to `10`, so it returns `10 * 2`, which is `20`. This results in `10, 20`.",
      "options": [
        { "text": "`[\"L\", \"y\", \"d\", \"i\", \"a\"]`", "correct": false },
        { "text": "`[\"Lydia\"]`", "correct": false },
        { "text": "`[[], \"Lydia\"]`", "correct": true },
        { "text": "`[[\"L\", \"y\", \"d\", \"i\", \"a\"]]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What does this return?\n    console.log(3 + 4 + '5');",
      "explanation": "When we pass multiple promises to the `Promise.race` method, it resolves/rejects the _first_ promise that resolves/rejects. To the `setTimeout` method, we pass a timer: 500ms for the first promise (`firstPromise`), and 100ms for the second promise (`secondPromise`). This means that the `secondPromise` resolves first with the value of `'two'`. `res` now holds the value of `'two'`, which gets logged.",
      "options": [
        { "text": "`[0, 10], [10, 20]`", "correct": false },
        { "text": "`20, 20`", "correct": true },
        { "text": "`10, 20`", "correct": false },
        { "text": "`0, 10 and 10, 20`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const num = parseInt('7*6', 10);",
      "explanation": "First, we declare a variable `person` with the value of an object that has a `name` property.\n\n![](https://i.imgur.com/TML1MbS.png)\n\nThen, we declare a variable called `members`. We set the first element of that array equal to the value of the `person` variable. Objects interact by _reference_ when setting them equal to each other. When you assign a reference from one variable to another, you make a _copy_ of that reference. (note that they don't have the _same_ reference!)\n\n![](https://i.imgur.com/FSG5K3F.png)\n\nThen, we set the variable `person` equal to `null`.\n\n![](https://i.imgur.com/sYjcsMT.png)\n\nWe are only modifying the value of the `person` variable, and not the first element in the array, since that element has a different (copied) reference to the object. The first element in `members` still holds its reference to the original object. When we log the `members` array, the first element still holds the value of the object, which gets logged.",
      "options": [
        { "text": "`\"one\"`", "correct": false },
        { "text": "`\"two\"`", "correct": false },
        { "text": "`\"two\" \"one\"`", "correct": false },
        { "text": "`\"one\" \"two\"`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    [1, 2, 3].map(num => {\n      if (typeof num === 'number') return;\n      return num * 2;\n    });",
      "explanation": "With a `for-in` loop, we can iterate through object keys, in this case `name` and `age`. Under the hood, object keys are strings (if they're not a Symbol). On every loop, we set the value of `item` equal to the current key it’s iterating over. First, `item` is equal to `name`, and gets logged. Then, `item` is equal to `age`, which gets logged.",
      "options": [
        { "text": "`null`", "correct": false },
        { "text": "`[null]`", "correct": true },
        { "text": "`[{}]`", "correct": false },
        { "text": "`[{ name: \"Lydia\" }]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function getInfo(member, year) {\n      member.name = 'Lydia';\n      year = '1998';\n    }\n    \n    const person = { name: 'Sarah' };\n    const birthYear = '1997';\n    \n    getInfo(person, birthYear);\n    \n    console.log(person, birthYear);",
      "explanation": "Operator associativity is the order in which the compiler evaluates the expressions, either left-to-right or right-to-left. This only happens if all operators have the _same_ precedence. We only have one type of operator: `+`. For addition, the associativity is left-to-right.\n\n`3 + 4` gets evaluated first. This results in the number `7`.\n\n`7 + '5'` results in `\"75\"` because of coercion. JavaScript converts the number `7` into a string, see question 15. We can concatenate two strings using the `+`operator. `\"7\" + \"5\"` results in `\"75\"`.",
      "options": [
        { "text": "`{ name: \"Lydia\" }, { age: 21 }`", "correct": false },
        { "text": "`\"name\", \"age\"`", "correct": true },
        { "text": "`\"Lydia\", 21`", "correct": false },
        { "text": "`[\"name\", \"Lydia\"], [\"age\", 21]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the value of num?\n    function greeting() {\n      throw 'Hello world!';\n    }\n    \n    function sayHi() {\n      try {\n        const data = greeting();\n        console.log('It worked!', data);\n      } catch (e) {\n        console.log('Oh no an error:', e);\n      }\n    }\n    \n    sayHi();",
      "explanation": "Only the first numbers in the string is returned. Based on the _radix_ (the second argument in order to specify what type of number we want to parse it to: base 10, hexadecimal, octal, binary, etc.), the `parseInt` checks whether the characters in the string are valid. Once it encounters a character that isn't a valid number in the radix, it stops parsing and ignores the following characters.\n\n`*` is not a valid number. It only parses `\"7\"` into the decimal `7`. `num` now holds the value of `7`.",
      "options": [
        { "text": "`\"345\"`", "correct": false },
        { "text": "`\"75\"`", "correct": false },
        { "text": "`12`", "correct": true },
        { "text": "`\"12\"`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function Car() {\n      this.make = 'Lamborghini';\n      return { make: 'Maserati' };\n    }\n    \n    const myCar = new Car();\n    console.log(myCar.make);",
      "explanation": "When mapping over the array, the value of `num` is equal to the element it’s currently looping over. In this case, the elements are numbers, so the condition of the if statement `typeof num === \"number\"` returns `true`. The map function creates a new array and inserts the values returned from the function.\n\nHowever, we don’t return a value. When we don’t return a value from the function, the function returns `undefined`. For every element in the array, the function block gets called, so for each element we return `undefined`.",
      "options": [
        { "text": "`42`", "correct": false },
        { "text": "`\"42\"`", "correct": false },
        { "text": "`7`", "correct": true },
        { "text": "`NaN`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    (() => {\n      let x = (y = 10);\n    })();\n    \n    console.log(typeof x);\n    console.log(typeof y);",
      "explanation": "Arguments are passed by _value_, unless their value is an object, then they're passed by _reference_. `birthYear` is passed by value, since it's a string, not an object. When we pass arguments by value, a _copy_ of that value is created (see question 46).\n\nThe variable `birthYear` has a reference to the value `\"1997\"`. The argument `year` also has a reference to the value `\"1997\"`, but it's not the same value as `birthYear` has a reference to. When we update the value of `year` by setting `year` equal to `\"1998\"`, we are only updating the value of `year`. `birthYear` is still equal to `\"1997\"`.\n\nThe value of `person` is an object. The argument `member` has a (copied) reference to the _same_ object. When we modify a property of the object `member` has a reference to, the value of `person` will also be modified, since they both have a reference to the same object. `person`'s `name` property is now equal to the value `\"Lydia\"`",
      "options": [
        { "text": "`[]`", "correct": true },
        { "text": "`[null, null, null]`", "correct": false },
        { "text": "`[undefined, undefined, undefined]`", "correct": false },
        { "text": "`[ 3 x empty ]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    y = 10;\n    let x = y;",
      "explanation": "With the `throw` statement, we can create custom errors. With this statement, you can throw exceptions. An exception can be a **string**, a **number**, a **boolean** or an **object**. In this case, our exception is the string `'Hello world!'`.\n\nWith the `catch` statement, we can specify what to do if an exception is thrown in the `try` block. An exception is thrown: the string `'Hello world!'`. `e` is now equal to that string, which we log. This results in `'Oh an error: Hello world!'`.",
      "options": [
        { "text": "`{ name: \"Lydia\" }, \"1997\"`", "correct": false },
        { "text": "`{ name: \"Sarah\" }, \"1998\"`", "correct": false },
        { "text": "`{ name: \"Lydia\" }, \"1998\"`", "correct": false },
        { "text": "`{ name: \"Sarah\" }, \"1997\"`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    class Dog {\n      constructor(name) {\n        this.name = name;\n      }\n    }\n    \n    Dog.prototype.bark = function() {\n      console.log(`Woof I am ${this.name}`);\n    };\n    \n    const pet = new Dog('Mara');\n    \n    pet.bark();\n    \n    delete Dog.prototype.bark;\n    \n    pet.bark();",
      "explanation": "When you return a property, the value of the property is equal to the _returned_ value, not the value set in the constructor function. We return the string `\"Maserati\"`, so `myCar.make` is equal to `\"Maserati\"`.",
      "options": [
        { "text": "`It worked! Hello world!`", "correct": false },
        { "text": "`Oh no an error: undefined`", "correct": true },
        {
          "text": "`SyntaxError: can only throw Error objects`",
          "correct": false
        },
        { "text": "`Oh no an error: Hello world!`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const set = new Set([1, 1, 2, 3, 4]);\n    \n    console.log(set);",
      "explanation": "`let x = (y = 10);` is actually shorthand for:\n\n    y = 10;\n    let x = y;\n    \n\nWhen we set `y` equal to `10`, we actually add a property `y` to the global object (`window` in browser, `global` in Node). In a browser, `window.y` is now equal to `10`.\n\nThen, we declare a variable `x` with the value of `y`, which is `10`. Variables declared with the `let` keyword are _block scoped_, they are only defined within the block they're declared in; the immediately invoked function expression (IIFE) in this case. When we use the `typeof` operator, the operand `x` is not defined: we are trying to access `x` outside of the block it's declared in. This means that `x` is not defined. Values who haven't been assigned a value or declared are of type `\"undefined\"`. `console.log(typeof x)` returns `\"undefined\"`.\n\nHowever, we created a global variable `y` when setting `y` equal to `10`. This value is accessible anywhere in our code. `y` is defined, and holds a value of type `\"number\"`. `console.log(typeof y)` returns `\"number\"`.",
      "options": [
        { "text": "`\"Lamborghini\"`", "correct": true },
        { "text": "`\"Maserati\"`", "correct": false },
        { "text": "`ReferenceError`", "correct": false },
        { "text": "`TypeError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    // counter.js\n    let counter = 10;\n    export default counter;",
      "explanation": "We can delete properties from objects using the `delete` keyword, also on the prototype. By deleting a property on the prototype, it is not available anymore in the prototype chain. In this case, the `bark` function is not available anymore on the prototype after `delete Dog.prototype.bark`, yet we still try to access it.\n\nWhen we try to invoke something that is not a function, a `TypeError` is thrown. In this case `TypeError: pet.bark is not a function`, since `pet.bark` is `undefined`.",
      "options": [
        { "text": "`\"undefined\", \"number\"`", "correct": true },
        { "text": "`\"number\", \"number\"`", "correct": false },
        { "text": "`\"object\", \"number\"`", "correct": false },
        { "text": "`\"number\", \"undefined\"`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    // index.js\n    import myCounter from './counter';\n    \n    myCounter += 1;\n    \n    console.log(myCounter);",
      "explanation": "The `Set` object is a collection of _unique_ values: a value can only occur once in a set.\n\nWe passed the iterable `[1, 1, 2, 3, 4]` with a duplicate value `1`. Since we cannot have two of the same values in a set, one of them is removed. This results in `{1, 2, 3, 4}`.",
      "options": [
        { "text": "`\"Woof I am Mara\"`, `TypeError`", "correct": false },
        {
          "text": "`\"Woof I am Mara\"`, `\"Woof I am Mara\"`",
          "correct": false
        },
        { "text": "`\"Woof I am Mara\"`, `undefined`", "correct": false },
        { "text": "`TypeError`, `TypeError`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const name = 'Lydia';\n    age = 21;\n    \n    console.log(delete name);\n    console.log(delete age);",
      "explanation": "An imported module is _read-only_: you cannot modify the imported module. Only the module that exports them can change its value.\n\nWhen we try to increment the value of `myCounter`, it throws an error: `myCounter` is read-only and cannot be modified.",
      "options": [
        { "text": "`[1, 1, 2, 3, 4]`", "correct": false },
        { "text": "`[1, 2, 3, 4]`", "correct": false },
        { "text": "`{1, 1, 2, 3, 4}`", "correct": true },
        { "text": "`{1, 2, 3, 4}`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const numbers = [1, 2, 3, 4, 5];\n    const [y] = numbers;\n    \n    console.log(y);",
      "explanation": "The `delete` operator returns a boolean value: `true` on a successful deletion, else it'll return `false`. However, variables declared with the `var`, `const` or `let` keyword cannot be deleted using the `delete` operator.\n\nThe `name` variable was declared with a `const` keyword, so its deletion is not successful: `false` is returned. When we set `age` equal to `21`, we actually added a property called `age` to the global object. You can successfully delete properties from objects this way, also the global object, so `delete age` returns `true`.",
      "options": [
        { "text": "`10`", "correct": true },
        { "text": "`11`", "correct": false },
        { "text": "`Error`", "correct": false },
        { "text": "`NaN`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    [a, b] = [1, 2];",
      "explanation": "We can unpack values from arrays or properties from objects through destructuring. For example:\n\n    [a, b] = [1, 2];\n    \n\n![](https://i.imgur.com/ADFpVop.png)\n\nThe value of `a` is now `1`, and the value of `b` is now `2`. What we actually did in the question, is:\n\n    [y] = [1, 2, 3, 4, 5];\n    \n\n![](https://i.imgur.com/NzGkMNk.png)\n\nThis means that the value of `y` is equal to the first value in the array, which is the number `1`. When we log `y`, `1` is returned.",
      "options": [
        { "text": "`false`, `true`", "correct": false },
        { "text": "`\"Lydia\"`, `21`", "correct": false },
        { "text": "`true`, `true`", "correct": true },
        { "text": "`undefined`, `undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    [y] = [1, 2, 3, 4, 5];",
      "explanation": "It's possible to combine objects using the spread operator `...`. It lets you create copies of the key/value pairs of one object, and add them to another object. In this case, we create copies of the `user` object, and add them to the `admin` object. The `admin` object now contains the copied key/value pairs, which results in `{ admin: true, name: \"Lydia\", age: 21 }`.",
      "options": [
        { "text": "`[[1, 2, 3, 4, 5]]`", "correct": false },
        { "text": "`[1, 2, 3, 4, 5]`", "correct": true },
        { "text": "`1`", "correct": false },
        { "text": "`[1]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const user = { name: 'Lydia', age: 21 };\n    const admin = { admin: true, ...user };\n    \n    console.log(admin);",
      "explanation": "With the `defineProperty` method, we can add new properties to an object, or modify existing ones. When we add a property to an object using the `defineProperty` method, they are by default _not enumerable_. The `Object.keys` method returns all _enumerable_ property names from an object, in this case only `\"name\"`.\n\nProperties added using the `defineProperty` method are immutable by default. You can override this behavior using the `writable`, `configurable` and `enumerable` properties. This way, the `defineProperty` method gives you a lot more control over the properties you're adding to an object.",
      "options": [
        {
          "text": "`{ admin: true, user: { name: \"Lydia\", age: 21 } }`",
          "correct": false
        },
        {
          "text": "`{ admin: true, name: \"Lydia\", age: 21 }`",
          "correct": true
        },
        {
          "text": "`{ admin: true, user: [\"Lydia\", 21] }`",
          "correct": false
        },
        { "text": "`{ admin: true }`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const person = { name: 'Lydia' };\n    \n    Object.defineProperty(person, 'age', { value: 21 });\n    \n    console.log(person);\n    console.log(Object.keys(person));",
      "explanation": "The second argument of `JSON.stringify` is the _replacer_. The replacer can either be a function or an array, and lets you control what and how the values should be stringified.\n\nIf the replacer is an _array_, only the property names included in the array will be added to the JSON string. In this case, only the properties with the names `\"level\"` and `\"health\"` are included, `\"username\"` is excluded. `data` is now equal to `\"{\"level\":19, \"health\":90}\"`.\n\nIf the replacer is a _function_, this function gets called on every property in the object you're stringifying. The value returned from this function will be the value of the property when it's added to the JSON string. If the value is `undefined`, this property is excluded from the JSON string.",
      "options": [
        {
          "text": "`{ name: \"Lydia\", age: 21 }`, `[\"name\", \"age\"]`",
          "correct": true
        },
        {
          "text": "`{ name: \"Lydia\", age: 21 }`, `[\"name\"]`",
          "correct": false
        },
        {
          "text": "`{ name: \"Lydia\"}`, `[\"name\", \"age\"]`",
          "correct": false
        },
        { "text": "`{ name: \"Lydia\"}`, `[\"age\"]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const settings = {\n      username: 'lydiahallie',\n      level: 19,\n      health: 90,\n    };\n    \n    const data = JSON.stringify(settings, ['level', 'health']);\n    console.log(data);",
      "explanation": "The unary operator `++` _first returns_ the value of the operand, _then increments_ the value of the operand. The value of `num1` is `10`, since the `increaseNumber` function first returns the value of `num`, which is `10`, and only increments the value of `num` afterwards.\n\n`num2` is `10`, since we passed `num1` to the `increasePassedNumber`. `number` is equal to `10`(the value of `num1`. Again, the unary operator `++` _first returns_ the value of the operand, _then increments_ the value of the operand. The value of `number` is `10`, so `num2` is equal to `10`.",
      "options": [
        { "text": "`\"{\"level\":19, \"health\":90}\"`", "correct": true },
        { "text": "`\"{\"username\": \"lydiahallie\"}\"`", "correct": false },
        { "text": "`\"[\"level\", \"health\"]\"`", "correct": false },
        {
          "text": "`\"{\"username\": \"lydiahallie\", \"level\":19, \"health\":90}\"`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    let num = 10;\n    \n    const increaseNumber = () => num++;\n    const increasePassedNumber = number => number++;\n    \n    const num1 = increaseNumber();\n    const num2 = increasePassedNumber(num1);\n    \n    console.log(num1);\n    console.log(num2);",
      "explanation": "In ES6, we can initialize parameters with a default value. The value of the parameter will be the default value, if no other value has been passed to the function, or if the value of the parameter is `\"undefined\"`. In this case, we spread the properties of the `value` object into a new object, so `x` has the default value of `{ number: 10 }`.\n\nThe default argument is evaluated at _call time_! Every time we call the function, a _new_ object is created. We invoke the `multiply` function the first two times without passing a value: `x` has the default value of `{ number: 10 }`. We then log the multiplied value of that number, which is `20`.\n\nThe third time we invoke multiply, we do pass an argument: the object called `value`. The `*=` operator is actually shorthand for `x.number = x.number * 2`: we modify the value of `x.number`, and log the multiplied value `20`.\n\nThe fourth time, we pass the `value` object again. `x.number` was previously modified to `20`, so `x.number *= 2` logs `40`.",
      "options": [
        { "text": "`10`, `10`", "correct": false },
        { "text": "`10`, `11`", "correct": false },
        { "text": "`11`, `11`", "correct": true },
        { "text": "`11`, `12`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const value = { number: 10 };\n    \n    const multiply = (x = { ...value }) => {\n      console.log((x.number *= 2));\n    };\n    \n    multiply();\n    multiply();\n    multiply(value);\n    multiply(value);",
      "explanation": "The first argument that the `reduce` method receives is the _accumulator_, `x` in this case. The second argument is the _current value_, `y`. With the reduce method, we execute a callback function on every element in the array, which could ultimately result in one single value.\n\nIn this example, we are not returning any values, we are simply logging the values of the accumulator and the current value.\n\nThe value of the accumulator is equal to the previously returned value of the callback function. If you don't pass the optional `initialValue` argument to the `reduce` method, the accumulator is equal to the first element on the first call.\n\nOn the first call, the accumulator (`x`) is `1`, and the current value (`y`) is `2`. We don't return from the callback function, we log the accumulator and current value: `1` and `2` get logged.\n\nIf you don't return a value from a function, it returns `undefined`. On the next call, the accumulator is `undefined`, and the current value is `3`. `undefined` and `3` get logged.\n\nOn the fourth call, we again don't return from the callback function. The accumulator is again `undefined`, and the current value is `4`. `undefined` and `4` get logged.",
      "options": [
        { "text": "`20`, `40`, `80`, `160`", "correct": false },
        { "text": "`20`, `40`, `20`, `40`", "correct": false },
        { "text": "`20`, `20`, `20`, `40`", "correct": false },
        { "text": "`NaN`, `NaN`, `20`, `40`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "With which constructor can we successfully extend the Dog class?\n    [1, 2, 3, 4].reduce((x, y) => console.log(x, y));",
      "explanation": "In a derived class, you cannot access the `this` keyword before calling `super`. If you try to do that, it will throw a ReferenceError: 1 and 4 would throw a reference error.\n\nWith the `super` keyword, we call that parent class's constructor with the given arguments. The parent's constructor receives the `name` argument, so we need to pass `name` to `super`.\n\nThe `Labrador` class receives two arguments, `name` since it extends `Dog`, and `size` as an extra property on the `Labrador` class. They both need to be passed to the constructor function on `Labrador`, which is done correctly using constructor 2.",
      "options": [
        { "text": "`1` `2` and `3` `3` and `6` `4`", "correct": false },
        { "text": "`1` `2` and `2` `3` and `3` `4`", "correct": true },
        {
          "text": "`1` `undefined` and `2` `undefined` and `3` `undefined` and `4` `undefined`",
          "correct": false
        },
        {
          "text": "`1` `2` and `undefined` `3` and `undefined` `4`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    class Dog {\n      constructor(name) {\n        this.name = name;\n      }\n    };\n    \n    class Labrador extends Dog {\n      // 1\n      constructor(name, size) {\n        this.size = size;\n      }\n      // 2\n      constructor(name, size) {\n        super(name);\n        this.size = size;\n      }\n      // 3\n      constructor(size) {\n        super(name);\n        this.size = size;\n      }\n      // 4\n      constructor(name, size) {\n        this.name = name;\n        this.size = size;\n      }\n    \n    };",
      "explanation": "With the `import` keyword, all imported modules are _pre-parsed_. This means that the imported modules get run _first_, the code in the file which imports the module gets executed _after_.\n\nThis is a difference between `require()` in CommonJS and `import`! With `require()`, you can load dependencies on demand while the code is being run. If we would have used `require` instead of `import`, `running index.js`, `running sum.js`, `3` would have been logged to the console.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": true },
        { "text": "", "correct": false },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    // index.js\n    console.log('running index.js');\n    import { sum } from './sum.js';\n    console.log(sum(1, 2));\n    \n    // sum.js\n    console.log('running sum.js');\n    export const sum = (a, b) => a + b;",
      "explanation": "Every Symbol is entirely unique. The purpose of the argument passed to the Symbol is to give the Symbol a description. The value of the Symbol is not dependent on the passed argument. As we test equality, we are creating two entirely new symbols: the first `Symbol('foo')`, and the second `Symbol('foo')`. These two values are unique and not equal to each other, `Symbol('foo') === Symbol('foo')` returns `false`.",
      "options": [
        {
          "text": "`running index.js`, `running sum.js`, `3`",
          "correct": true
        },
        {
          "text": "`running sum.js`, `running index.js`, `3`",
          "correct": false
        },
        {
          "text": "`running sum.js`, `3`, `running index.js`",
          "correct": false
        },
        {
          "text": "`running index.js`, `undefined`, `running sum.js`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    console.log(Number(2) === Number(2));\n    console.log(Boolean(false) === Boolean(false));\n    console.log(Symbol('foo') === Symbol('foo'));",
      "explanation": "With the `padStart` method, we can add padding to the beginning of a string. The value passed to this method is the _total_ length of the string together with the padding. The string `\"Lydia Hallie\"` has a length of `12`. `name.padStart(13)` inserts 1 space at the start of the string, because 12 + 1 is 13.\n\nIf the argument passed to the `padStart` method is smaller than the length of the array, no padding will be added.",
      "options": [
        { "text": "`true`, `true`, `false`", "correct": false },
        { "text": "`false`, `true`, `false`", "correct": false },
        { "text": "`true`, `false`, `true`", "correct": true },
        { "text": "`true`, `true`, `true`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const name = 'Lydia Hallie';\n    console.log(name.padStart(13));\n    console.log(name.padStart(2));",
      "explanation": "With the `+` operator, you can concatenate strings. In this case, we are concatenating the string `\"🥑\"` with the string `\"💻\"`, resulting in `\"🥑💻\"`.",
      "options": [
        { "text": "`\"Lydia Hallie\"`, `\"Lydia Hallie\"`", "correct": true },
        {
          "text": "`\" Lydia Hallie\"`, `\" Lydia Hallie\"` (`\"[13x whitespace]Lydia Hallie\"`, `\"[2x whitespace]Lydia Hallie\"`)",
          "correct": false
        },
        {
          "text": "`\" Lydia Hallie\"`, `\"Lydia Hallie\"` (`\"[1x whitespace]Lydia Hallie\"`, `\"Lydia Hallie\"`)",
          "correct": false
        },
        { "text": "`\"Lydia Hallie\"`, `\"Lyd\"`,", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "How can we log the values that are commented out after the console.log statement?\n    console.log('🥑' + '💻');",
      "explanation": "A generator function \"pauses\" its execution when it sees the `yield` keyword. First, we have to let the function yield the string \"Do you love JavaScript?\", which can be done by calling `game.next().value`.\n\nEvery line is executed, until it finds the first `yield` keyword. There is a `yield` keyword on the first line within the function: the execution stops with the first yield! _This means that the variable `answer` is not defined yet!_\n\nWhen we call `game.next(\"Yes\").value`, the previous `yield` is replaced with the value of the parameters passed to the `next()` function, `\"Yes\"` in this case. The value of the variable `answer` is now equal to `\"Yes\"`. The condition of the if-statement returns `false`, and `JavaScript loves you back ❤️` gets logged.",
      "options": [
        { "text": "`\"🥑💻\"`", "correct": false },
        { "text": "`257548`", "correct": false },
        { "text": "", "correct": true },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function* startGame() {\n      const answer = yield 'Do you love JavaScript?';\n      if (answer !== 'Yes') {\n        return \"Oh wow... Guess we're gone here\";\n      }\n      return 'JavaScript loves you back ❤️';\n    }\n    \n    const game = startGame();\n    console.log(/* 1 */); // Do you love JavaScript?\n    console.log(/* 2 */); // JavaScript loves you back ❤️",
      "explanation": "`String.raw` returns a string where the escapes (`\\n`, `\\v`, `\\t` etc.) are ignored! Backslashes can be an issue since you could end up with something like:\n\n``const path = `C:\\Documents\\Projects\\table.html` ``\n\nWhich would result in:\n\n`\"C:DocumentsProjects able.html\"`\n\nWith `String.raw`, it would simply ignore the escape and print:\n\n`C:\\Documents\\Projects\\table.html`\n\nIn this case, the string is `Hello\\nworld`, which gets logged.",
      "options": [
        {
          "text": "`game.next(\"Yes\").value` and `game.next().value`",
          "correct": false
        },
        {
          "text": "`game.next.value(\"Yes\")` and `game.next.value()`",
          "correct": false
        },
        {
          "text": "`game.next().value` and `game.next(\"Yes\").value`",
          "correct": true
        },
        {
          "text": "`game.next.value()` and `game.next.value(\"Yes\")`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    console.log(String.raw`Hello\\nworld`);",
      "explanation": "An async function always returns a promise. The `await` still has to wait for the promise to resolve: a pending promise gets returned when we call `getData()` in order to set `data` equal to it.\n\nIf we wanted to get access to the resolved value `\"I made it\"`, we could have used the `.then()` method on `data`:\n\n`data.then(res => console.log(res))`\n\nThis would've logged `\"I made it!\"`",
      "options": [
        { "text": "`Hello world!`", "correct": false },
        { "text": "`Hello`  \n     `world`", "correct": false },
        { "text": "`Hello\\nworld`", "correct": true },
        { "text": "`Hello\\n`  \n     `world`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    async function getData() {\n      return await Promise.resolve('I made it!');\n    }\n    \n    const data = getData();\n    console.log(data);",
      "explanation": "The `.push()` method returns the _length_ of the new array! Previously, the array contained one element (the string `\"banana\"`) and had a length of `1`. After adding the string `\"apple\"` to the array, the array contains two elements, and has a length of `2`. This gets returned from the `addToList` function.\n\nThe `push` method modifies the original array. If you wanted to return the _array_ from the function rather than the _length of the array_, you should have returned `list` after pushing `item` to it.",
      "options": [
        { "text": "`\"I made it!\"`", "correct": false },
        { "text": "`Promise {<resolved>: \"I made it!\"}`", "correct": true },
        { "text": "`Promise {<pending>}`", "correct": false },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function addToList(item, list) {\n      return list.push(item);\n    }\n    \n    const result = addToList('apple', ['banana']);\n    console.log(result);",
      "explanation": "`Object.freeze` makes it impossible to add, remove, or modify properties of an object (unless the property's value is another object).\n\nWhen we create the variable `shape` and set it equal to the frozen object `box`, `shape` also refers to a frozen object. You can check whether an object is frozen by using `Object.isFrozen`. In this case, `Object.isFrozen(shape)` returns true, since the variable `shape` has a reference to a frozen object.\n\nSince `shape` is frozen, and since the value of `x` is not an object, we cannot modify the property `x`. `x` is still equal to `10`, and `{ x: 10, y: 20 }` gets logged.",
      "options": [
        { "text": "`['apple', 'banana']`", "correct": false },
        { "text": "`2`", "correct": true },
        { "text": "`true`", "correct": false },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const box = { x: 10, y: 20 };\n    \n    Object.freeze(box);\n    \n    const shape = box;\n    shape.x = 100;\n    \n    console.log(shape);",
      "explanation": "When we unpack the property `name` from the object on the right-hand side, we assign its value `\"Lydia\"` to a variable with the name `myName`.\n\nWith `{ name: myName }`, we tell JavaScript that we want to create a new variable called `myName` with the value of the `name` property on the right-hand side.\n\nSince we try to log `name`, a variable that is not defined, a ReferenceError gets thrown.",
      "options": [
        { "text": "`{ x: 100, y: 20 }`", "correct": false },
        { "text": "`{ x: 10, y: 20 }`", "correct": false },
        { "text": "`{ x: 100 }`", "correct": false },
        { "text": "`ReferenceError`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "Is this a pure function?\n    const { name: myName } = { name: 'Lydia' };\n    \n    console.log(name);",
      "explanation": "A pure function is a function that _always_ returns the same result, if the same arguments are passed.\n\nThe `sum` function always returns the same result. If we pass `1` and `2`, it will _always_ return `3` without side effects. If we pass `5` and `10`, it will _always_ return `15`, and so on. This is the definition of a pure function.",
      "options": [
        { "text": "`\"Lydia\"`", "correct": true },
        { "text": "`\"myName\"`", "correct": false },
        { "text": "`undefined`", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What is the output?\n    function sum(a, b) {\n      return a + b;\n    }",
      "explanation": "The `add` function is a _memoized_ function. With memoization, we can cache the results of a function in order to speed up its execution. In this case, we create a `cache` object that stores the previously returned values.\n\nIf we call the `addFunction` function again with the same argument, it first checks whether it has already gotten that value in its cache. If that's the case, the caches value will be returned, which saves on execution time. Else, if it's not cached, it will calculate the value and store it afterwards.\n\nWe call the `addFunction` function three times with the same value: on the first invocation, the value of the function when `num` is equal to `10` isn't cached yet. The condition of the if-statement `num in cache` returns `false`, and the else block gets executed: `Calculated! 20` gets logged, and the value of the result gets added to the cache object. `cache` now looks like `{ 10: 20 }`.\n\nThe second time, the `cache` object contains the value that gets returned for `10`. The condition of the if-statement `num in cache` returns `true`, and `'From cache! 20'` gets logged.\n\nThe third time, we pass `5 * 2` to the function which gets evaluated to `10`. The `cache` object contains the value that gets returned for `10`. The condition of the if-statement `num in cache` returns `true`, and `'From cache! 20'` gets logged.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What is the output?\n    const add = () => {\n      const cache = {};\n      return num => {\n        if (num in cache) {\n          return `From cache! ${cache[num]}`;\n        } else {\n          const result = num + 10;\n          cache[num] = result;\n          return `Calculated! ${result}`;\n        }\n      };\n    };\n    \n    const addFunction = add();\n    console.log(addFunction(10));\n    console.log(addFunction(10));\n    console.log(addFunction(5 * 2));",
      "explanation": "With a _for-in_ loop, we can iterate over **enumerable** properties. In an array, the enumerable properties are the \"keys\" of array elements, which are actually their indexes. You could see an array as:\n\n`{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`\n\nWhere the keys are the enumerable properties. `0` `1` `2` `3` get logged.\n\nWith a _for-of_ loop, we can iterate over **iterables**. An array is an iterable. When we iterate over the array, the variable \"item\" is equal to the element it's currently iterating over, `\"☕\"` `\"💻\"` `\"🍷\"` `\"🍫\"` get logged.",
      "options": [
        {
          "text": "`Calculated! 20` `Calculated! 20` `Calculated! 20`",
          "correct": true
        },
        {
          "text": "`Calculated! 20` `From cache! 20` `Calculated! 20`",
          "correct": false
        },
        {
          "text": "`Calculated! 20` `From cache! 20` `From cache! 20`",
          "correct": false
        },
        {
          "text": "`Calculated! 20` `From cache! 20` `Error`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What is the output?\n    const myLifeSummedUp = ['☕', '💻', '🍷', '🍫'];\n    \n    for (let item in myLifeSummedUp) {\n      console.log(item);\n    }\n    \n    for (let item of myLifeSummedUp) {\n      console.log(item);\n    }",
      "explanation": "Array elements can hold any value. Numbers, strings, objects, other arrays, null, boolean values, undefined, and other expressions such as dates, functions, and calculations.\n\nThe element will be equal to the returned value. `1 + 2` returns `3`, `1 * 2` returns `2`, and `1 / 2` returns `0.5`.",
      "options": [
        {
          "text": "`0` `1` `2` `3` and `\"☕\"` `\"💻\"` `\"🍷\"` `\"🍫\"`",
          "correct": false
        },
        {
          "text": "`\"☕\"` `\"💻\"` `\"🍷\"` `\"🍫\"` and `\"☕\"` `\"💻\"` `\"🍷\"` `\"🍫\"`",
          "correct": false
        },
        {
          "text": "`\"☕\"` `\"💻\"` `\"🍷\"` `\"🍫\"` and `0` `1` `2` `3`",
          "correct": true
        },
        {
          "text": "`0` `1` `2` `3` and `{0: \"☕\", 1: \"💻\", 2: \"🍷\", 3: \"🍫\"}`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What is the output?\n    const list = [1 + 2, 1 * 2, 1 / 2];\n    console.log(list);",
      "explanation": "By default, arguments have the value of `undefined`, unless a value has been passed to the function. In this case, we didn't pass a value for the `name` argument. `name` is equal to `undefined` which gets logged.\n\nIn ES6, we can overwrite this default `undefined` value with default parameters. For example:\n\n`function sayHi(name = \"Lydia\") { ... }`\n\nIn this case, if we didn't pass a value or if we passed `undefined`, `name` would always be equal to the string `Lydia`",
      "options": [
        { "text": "`[\"1 + 2\", \"1 * 2\", \"1 / 2\"]`", "correct": false },
        { "text": "`[\"12\", 2, 0.5]`", "correct": true },
        { "text": "`[3, 2, 0.5]`", "correct": false },
        { "text": "`[1, 1, 1]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What is the output?\n    function sayHi(name) {\n      return `Hi there, ${name}`;\n    }\n    \n    console.log(sayHi());",
      "explanation": "The value of the `this` keyword is dependent on where you use it. In a **method**, like the `getStatus` method, the `this` keyword refers to _the object that the method belongs to_. The method belongs to the `data` object, so `this` refers to the `data` object. When we log `this.status`, the `status` property on the `data` object gets logged, which is `\"🥑\"`.\n\nWith the `call` method, we can change the object to which the `this` keyword refers. In **functions**, the `this` keyword refers to the _the object that the function belongs to_. We declared the `setTimeout` function on the _global object_, so within the `setTimeout` function, the `this` keyword refers to the _global object_. On the global object, there is a variable called _status_ with the value of `\"😎\"`. When logging `this.status`, `\"😎\"` gets logged.",
      "options": [
        { "text": "`Hi there,`", "correct": false },
        { "text": "`Hi there, undefined`", "correct": true },
        { "text": "`Hi there, null`", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What is the output?\n    var status = '😎';\n    \n    setTimeout(() => {\n      const status = '😍';\n    \n      const data = {\n        status: '🥑',\n        getStatus() {\n          return this.status;\n        },\n      };\n    \n      console.log(data.getStatus());\n      console.log(data.getStatus.call(this));\n    }, 0);",
      "explanation": "We set the variable `city` equal to the value of the property called `city` on the `person` object. There is no property on this object called `city`, so the variable `city` has the value of `undefined`.\n\nNote that we are _not_ referencing the `person` object itself! We simply set the variable `city` equal to the current value of the `city` property on the `person` object.\n\nThen, we set `city` equal to the string `\"Amsterdam\"`. This doesn't change the person object: there is no reference to that object.\n\nWhen logging the `person` object, the unmodified object gets returned.",
      "options": [
        { "text": "`\"🥑\"` and `\"😍\"`", "correct": true },
        { "text": "`\"🥑\"` and `\"😎\"`", "correct": false },
        { "text": "`\"😍\"` and `\"😎\"`", "correct": false },
        { "text": "`\"😎\"` and `\"😎\"`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What is the output?\n    const person = {\n      name: 'Lydia',\n      age: 21,\n    };\n    \n    let city = person.city;\n    city = 'Amsterdam';\n    \n    console.log(person);",
      "explanation": "Variables with the `const` and `let` keyword are _block-scoped_. A block is anything between curly brackets (`{ }`). In this case, the curly brackets of the if/else statements. You cannot reference a variable outside of the block it's declared in, a ReferenceError gets thrown.",
      "options": [
        { "text": "`{ name: \"Lydia\", age: 21 }`", "correct": false },
        {
          "text": "`{ name: \"Lydia\", age: 21, city: \"Amsterdam\" }`",
          "correct": false
        },
        {
          "text": "`{ name: \"Lydia\", age: 21, city: undefined }`",
          "correct": true
        },
        { "text": "`\"Amsterdam\"`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What kind of information would get logged?\n    function checkAge(age) {\n      if (age < 18) {\n        const message = \"Sorry, you're too young.\";\n      } else {\n        const message = \"Yay! You're old enough!\";\n      }\n    \n      return message;\n    }\n    \n    console.log(checkAge(21));",
      "explanation": "The value of `res` in the second `.then` is equal to the returned value of the previous `.then`. You can keep chaining `.then`s like this, where the value is passed to the next handler.",
      "options": [
        { "text": "`\"Sorry, you're too young.\"`", "correct": false },
        { "text": "`\"Yay! You're old enough!\"`", "correct": false },
        { "text": "`ReferenceError`", "correct": true },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "Which option is a way to set hasName equal to true, provided you cannot pass true as an argument?\n    fetch('https://www.website.com/api/user/1')\n      .then(res => res.json())\n      .then(res => console.log(res));",
      "explanation": "With `!!name`, we determine whether the value of `name` is truthy or falsy. If name is truthy, which we want to test for, `!name` returns `false`. `!false` (which is what `!!name` practically is) returns `true`.\n\nBy setting `hasName` equal to `name`, you set `hasName` equal to whatever value you passed to the `getName` function, not the boolean value `true`.\n\n`new Boolean(true)` returns an object wrapper, not the boolean value itself.\n\n`name.length` returns the length of the passed argument, not whether it's `true`.",
      "options": [
        { "text": "`fetch` method.", "correct": true },
        { "text": "`fetch` method.", "correct": false },
        { "text": "`.then()`.", "correct": false },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function getName(name) {\n      const hasName = //\n    }",
      "explanation": "In order to get an character on a specific index in a string, you can use bracket notation. The first character in the string has index 0, and so on. In this case we want to get the element which index is 0, the character `\"I'`, which gets logged.\n\nNote that this method is not supported in IE7 and below. In that case, use `.charAt()`",
      "options": [
        { "text": "`!!name`", "correct": false },
        { "text": "`name`", "correct": true },
        { "text": "`new Boolean(name)`", "correct": false },
        { "text": "`name.length`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    console.log('I want pizza'[0]);",
      "explanation": "You can set a default parameter's value equal to another parameter of the function, as long as they've been defined _before_ the default parameter. We pass the value `10` to the `sum` function. If the `sum` function only receives 1 argument, it means that the value for `num2` is not passed, and the value of `num1` is equal to the passed value `10` in this case. The default value of `num2` is the value of `num1`, which is `10`. `num1 + num2` returns `20`.\n\nIf you're trying to set a default parameter's value equal to a parameter which is defined _after_ (to the right), the parameter's value hasn't been initialized yet, which will throw an error.",
      "options": [
        { "text": "`\"\"\"`", "correct": false },
        { "text": "`\"I\"`", "correct": true },
        { "text": "`SyntaxError`", "correct": false },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function sum(num1, num2 = num1) {\n      console.log(num1 + num2);\n    }\n    \n    sum(10);",
      "explanation": "With the `import * as name` syntax, we import _all exports_ from the `module.js` file into the `index.js` file as a new object called `data` is created. In the `module.js` file, there are two exports: the default export, and a named export. The default export is a function which returns the string `\"Hello World\"`, and the named export is a variable called `name` which has the value of the string `\"Lydia\"`.\n\nThe `data` object has a `default` property for the default export, other properties have the names of the named exports and their corresponding values.",
      "options": [
        { "text": "`NaN`", "correct": true },
        { "text": "`20`", "correct": false },
        { "text": "`ReferenceError`", "correct": false },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    // module.js\n    export default () => 'Hello world';\n    export const name = 'Lydia';\n    \n    // index.js\n    import * as data from './module';\n    \n    console.log(data);",
      "explanation": "Classes are syntactical sugar for function constructors. The equivalent of the `Person` class as a function constructor would be:\n\n    function Person() {\n      this.name = name;\n    }\n    \n\nCalling a function constructor with `new` results in the creation of an instance of `Person`, `typeof` keyword returns `\"object\"` for an instance. `typeof member` returns `\"object\"`.",
      "options": [
        {
          "text": "`{ default: function default(), name: \"Lydia\" }`",
          "correct": false
        },
        { "text": "`{ default: function default() }`", "correct": false },
        {
          "text": "`{ default: \"Hello world\", name: \"Lydia\" }`",
          "correct": true
        },
        { "text": "`module.js`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    class Person {\n      constructor(name) {\n        this.name = name;\n      }\n    }\n    \n    const member = new Person('John');\n    console.log(typeof member);",
      "explanation": "The `.push` method returns the _new length_ of the array, not the array itself! By setting `newList` equal to `[1, 2, 3].push(4)`, we set `newList` equal to the new length of the array: `4`.\n\nThen, we try to use the `.push` method on `newList`. Since `newList` is the numerical value `4`, we cannot use the `.push` method: a TypeError is thrown.",
      "options": [
        { "text": "`\"class\"`", "correct": false },
        { "text": "`\"function\"`", "correct": false },
        { "text": "`\"object\"`", "correct": false },
        { "text": "`\"string\"`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function Person() {\n      this.name = name;\n    }",
      "explanation": "Regular functions, such as the `giveLydiaPizza` function, have a `prototype` property, which is an object (prototype object) with a `constructor` property. Arrow functions however, such as the `giveLydiaChocolate` function, do not have this `prototype` property. `undefined` gets returned when trying to access the `prototype` property using `giveLydiaChocolate.prototype`.",
      "options": [
        { "text": "`[1, 2, 3, 4, 5]`", "correct": false },
        { "text": "`[1, 2, 3, 5]`", "correct": false },
        { "text": "`[1, 2, 3, 4]`", "correct": false },
        { "text": "`Error`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    let newList = [1, 2, 3].push(4);\n    \n    console.log(newList.push(5));",
      "explanation": "`Object.entries(person)` returns an array of nested arrays, containing the keys and objects:\n\n`[ [ 'name', 'Lydia' ], [ 'age', 21 ] ]`\n\nUsing the `for-of` loop, we can iterate over each element in the array, the subarrays in this case. We can destructure the subarrays instantly in the for-of loop, using `const [x, y]`. `x` is equal to the first element in the subarray, `y` is equal to the second element in the subarray.\n\nThe first subarray is `[ \"name\", \"Lydia\" ]`, with `x` equal to `\"name\"`, and `y` equal to `\"Lydia\"`, which get logged. The second subarray is `[ \"age\", 21 ]`, with `x` equal to `\"age\"`, and `y` equal to `21`, which get logged.",
      "options": [
        {
          "text": "`{ constructor: ...}` `{ constructor: ...}`",
          "correct": true
        },
        { "text": "`{}` `{ constructor: ...}`", "correct": false },
        { "text": "`{ constructor: ...}` `{}`", "correct": false },
        { "text": "`{ constructor: ...}` `undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function giveLydiaPizza() {\n      return 'Here is pizza!';\n    }\n    \n    const giveLydiaChocolate = () =>\n      \"Here's chocolate... now go hit the gym already.\";\n    \n    console.log(giveLydiaPizza.prototype);\n    console.log(giveLydiaChocolate.prototype);",
      "explanation": "`...args` is a rest parameter. The rest parameter's value is an array containing all remaining arguments, **and can only be the last parameter**! In this example, the rest parameter was the second parameter. This is not possible, and will throw a syntax error.\n\n    function getItems(fruitList, favoriteFruit, ...args) {\n      return [...fruitList, ...args, favoriteFruit];\n    }\n    \n    getItems(['banana', 'apple'], 'pear', 'orange');\n    \n\nThe above example works. This returns the array `[ 'banana', 'apple', 'orange', 'pear' ]`",
      "options": [
        { "text": "`name` `Lydia` and `age` `21`", "correct": false },
        {
          "text": "`[\"name\", \"Lydia\"]` and `[\"age\", 21]`",
          "correct": false
        },
        { "text": "`[\"name\", \"age\"]` and `undefined`", "correct": false },
        { "text": "`Error`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    const person = {\n      name: 'Lydia',\n      age: 21,\n    };\n    \n    for (const [x, y] of Object.entries(person)) {\n      console.log(x, y);\n    }",
      "explanation": "In JavaScript, we don't _have_ to write the semicolon (`;`) explicitly, however the JavaScript engine still adds them after statements. This is called **Automatic Semicolon Insertion**. A statement can for example be variables, or keywords like `throw`, `return`, `break`, etc.\n\nHere, we wrote a `return` statement, and another value `a + b` on a _new line_. However, since it's a new line, the engine doesn't know that it's actually the value that we wanted to return. Instead, it automatically added a semicolon after `return`. You could see this as:\n\n    return;\n    a + b;\n    \n\nThis means that `a + b` is never reached, since a function stops running after the `return` keyword. If no value gets returned, like here, the function returns `undefined`. Note that there is no automatic insertion after `if/else` statements!",
      "options": [
        {
          "text": "`[\"banana\", \"apple\", \"pear\", \"orange\"]`",
          "correct": false
        },
        {
          "text": "`[[\"banana\", \"apple\"], \"pear\", \"orange\"]`",
          "correct": true
        },
        {
          "text": "`[\"banana\", \"apple\", [\"pear\"], \"orange\"]`",
          "correct": false
        },
        { "text": "`SyntaxError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function getItems(fruitList, ...args, favoriteFruit) {\n      return [...fruitList, ...args, favoriteFruit]\n    }\n    \n    getItems([\"banana\", \"apple\"], \"pear\", \"orange\")",
      "explanation": "We can set classes equal to other classes/function constructors. In this case, we set `Person` equal to `AnotherPerson`. The name on this constructor is `Sarah`, so the name property on the new `Person` instance `member` is `\"Sarah\"`.",
      "options": [
        {
          "text": "`a is bigger`, `6` and `b is bigger`, `3`",
          "correct": false
        },
        {
          "text": "`a is bigger`, `undefined` and `b is bigger`, `undefined`",
          "correct": true
        },
        { "text": "`undefined` and `undefined`", "correct": false },
        { "text": "`SyntaxError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function getItems(fruitList, favoriteFruit, ...args) {\n      return [...fruitList, ...args, favoriteFruit];\n    }\n    \n    getItems(['banana', 'apple'], 'pear', 'orange');",
      "explanation": "A Symbol is not _enumerable_. The Object.keys method returns all _enumerable_ key properties on an object. The Symbol won't be visible, and an empty array is returned. When logging the entire object, all properties will be visible, even non-enumerable ones.\n\nThis is one of the many qualities of a symbol: besides representing an entirely unique value (which prevents accidental name collision on objects, for example when working with 2 libraries that want to add properties to the same object), you can also \"hide\" properties on objects this way (although not entirely. You can still access symbols using the `Object.getOwnPropertySymbols()` method).",
      "options": [
        { "text": "`\"Lydia\"`", "correct": false },
        { "text": "`\"Sarah\"`", "correct": false },
        { "text": "`Error: cannot redeclare Person`", "correct": false },
        { "text": "`SyntaxError`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    function nums(a, b) {\n      if (a > b) console.log('a is bigger');\n      else console.log('b is bigger');\n      return\n      a + b;\n    }\n    \n    console.log(nums(4, 2));\n    console.log(nums(1, 2));",
      "explanation": "The `getList` function receives an array as its argument. Between the parentheses of the `getList` function, we destructure this array right away. You could see this as:\n\n`[x, ...y] = [1, 2, 3, 4]`\n\nWith the rest parameter `...y`, we put all \"remaining\" arguments in an array. The remaining arguments are `2`, `3` and `4` in this case. The value of `y` is an array, containing all the rest parameters. The value of `x` is equal to `1` in this case, so when we log `[x, y]`, `[1, [2, 3, 4]]` gets logged.\n\nThe `getUser` function receives an object. With arrow functions, we don't _have_ to write curly brackets if we just return one value. However, if you want to return an _object_ from an arrow function, you have to write it between parentheses, otherwise no value gets returned! The following function would have returned an object:\n\n`const getUser = user => ({ name: user.name, age: user.age })`\n\nSince no value gets returned in this case, the function returns `undefined`.",
      "options": [
        {
          "text": "`{Symbol('a'): 'b'}` and `[\"{Symbol('a')\"]`",
          "correct": true
        },
        { "text": "`{}` and `[]`", "correct": false },
        { "text": "`{ a: \"b\" }` and `[\"a\"]`", "correct": false },
        { "text": "`{Symbol('a'): 'b'}` and `[]`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": "What's the output?\n    return;\n    a + b;",
      "explanation": "The variable `name` holds the value of a string, which is not a function, thus cannot invoke.\n\nTypeErrors get thrown when a value is not of the expected type. JavaScript expected `name` to be a function since we're trying to invoke it. It was a string however, so a TypeError gets thrown: name is not a function!\n\nSyntaxErrors get thrown when you've written something that isn't valid JavaScript, for example when you've written the word `return` as `retrun`. ReferenceErrors get thrown when JavaScript isn't able to find a reference to a value that you're trying to access.",
      "options": [
        { "text": "`[1, [2, 3, 4]]` and `undefined`", "correct": false },
        {
          "text": "`[1, [2, 3, 4]]` and `{ name: \"Lydia\", age: 21 }`",
          "correct": false
        },
        {
          "text": "`[1, 2, 3, 4]` and `{ name: \"Lydia\", age: 21 }`",
          "correct": true
        },
        {
          "text": "`Error` and `{ name: \"Lydia\", age: 21 }`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the value of output?\n    class Person {\n      constructor() {\n        this.name = 'Lydia';\n      }\n    }\n    \n    Person = class AnotherPerson {\n      constructor() {\n        this.name = 'Sarah';\n      }\n    };\n    \n    const member = new Person();\n    console.log(member.name);",
      "explanation": "`[]` is a truthy value. With the `&&` operator, the right-hand value will be returned if the left-hand value is a truthy value. In this case, the left-hand value `[]` is a truthy value, so `\"Im'` gets returned.\n\n`\"\"` is a falsy value. If the left-hand value is falsy, nothing gets returned. `n't` doesn't get returned.",
      "options": [
        { "text": "`SyntaxError`", "correct": false },
        { "text": "`ReferenceError`", "correct": true },
        { "text": "`TypeError`", "correct": false },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the value of output?\n    const info = {\n      [Symbol('a')]: 'b',\n    };\n    \n    console.log(info);\n    console.log(Object.keys(info));",
      "explanation": "With the `||` operator, we can return the first truthy operand. If all values are falsy, the last operand gets returned.\n\n`(false || {} || null)`: the empty object `{}` is a truthy value. This is the first (and only) truthy value, which gets returned. `one` is equal to `{}`.\n\n`(null || false || \"\")`: all operands are falsy values. This means that the last operand, `\"\"` gets returned. `two` is equal to `\"\"`.\n\n`([] || 0 || \"\")`: the empty array`[]` is a truthy value. This is the first truthy value, which gets returned. `three` is equal to `[]`.",
      "options": [
        {
          "text": "`possible! You should see a therapist after so much JavaScript lol`",
          "correct": false
        },
        {
          "text": "`Impossible! You should see a therapist after so much JavaScript lol`",
          "correct": false
        },
        {
          "text": "`possible! You shouldn't see a therapist after so much JavaScript lol`",
          "correct": true
        },
        {
          "text": "`Impossible! You shouldn't see a therapist after so much JavaScript lol`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the value of output?\n    const getList = ([x, ...y]) => [x, y]\n    const getUser = user => { name: user.name, age: user.age }\n    \n    const list = [1, 2, 3, 4]\n    const user = { name: \"Lydia\", age: 21 }\n    \n    console.log(getList(list))\n    console.log(getUser(user))",
      "explanation": "With a promise, we basically say _I want to execute this function, but I'll put it aside for now while it's running since this might take a while. Only when a certain value is resolved (or rejected), and when the call stack is empty, I want to use this value._\n\nWe can get this value with both `.then` and the `await` keyword in an `async` function. Although we can get a promise's value with both `.then` and `await`, they work a bit differently.\n\nIn the `firstFunction`, we (sort of) put the myPromise function aside while it was running, but continued running the other code, which is `console.log('second')` in this case. Then, the function resolved with the string `I have resolved`, which then got logged after it saw that the callstack was empty.\n\nWith the await keyword in `secondFunction`, we literally pause the execution of an async function until the value has been resolved before moving to the next line.\n\nThis means that it waited for the `myPromise` to resolve with the value `I have resolved`, and only once that happened, we moved to the next line: `second` got logged.",
      "options": [
        { "text": "`false` `null` `[]`", "correct": false },
        { "text": "`null` `\"\"` `true`", "correct": false },
        { "text": "`{}` `\"\"` `[]`", "correct": false },
        { "text": "`null` `null` `true`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the value of output?\n    const name = 'Lydia';\n    \n    console.log(name());",
      "explanation": "The `+` operator is not only used for adding numerical values, but we can also use it to concatenate strings. Whenever the JavaScript engine sees that one or more values are not a number, it coerces the number into a string.\n\nThe first one is `1`, which is a numerical value. `1 + 2` returns the number 3.\n\nHowever, the second one is a string `\"Lydia\"`. `\"Lydia\"` is a string and `2` is a number: `2` gets coerced into a string. `\"Lydia\"` and `\"2\"` get concatenated, which results in the string `\"Lydia2\"`.\n\n`{ name: \"Lydia\" }` is an object. Neither a number nor an object is a string, so it stringifies both. Whenever we stringify a regular object, it becomes `\"[object Object]\"`. `\"[object Object]\"` concatenated with `\"2\"` becomes `\"[object Object]2\"`.",
      "options": [
        {
          "text": "`I have resolved!`, `second` and `I have resolved!`, `second`",
          "correct": false
        },
        {
          "text": "`second`, `I have resolved!` and `second`, `I have resolved!`",
          "correct": false
        },
        {
          "text": "`I have resolved!`, `second` and `second`, `I have resolved!`",
          "correct": true
        },
        {
          "text": "`second`, `I have resolved!` and `I have resolved!`, `second`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's its value?\n    // 🎉✨ This is my 100th question! ✨🎉\n    \n    const output = `${[] && 'Im'}possible!\n    You should${'' && `n't`} see a therapist after so much JavaScript lol`;",
      "explanation": "We can pass any type of value we want to `Promise.resolve`, either a promise or a non-promise. The method itself returns a promise with the resolved value (`<fulfilled>`). If you pass a regular function, it'll be a resolved promise with a regular value. If you pass a promise, it'll be a resolved promise with the resolved value of that passed promise.\n\nIn this case, we just passed the numerical value `5`. It returns a resolved promise with the value `5`.",
      "options": [
        { "text": "`3`, `NaN`, `NaN`", "correct": false },
        { "text": "`3`, `7`, `NaN`", "correct": false },
        { "text": "`3`, `Lydia2`, `[object Object]2`", "correct": true },
        { "text": "`\"12\"`, `Lydia2`, `[object Object]2`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's its value?\n    const one = false || {} || null;\n    const two = null || false || '';\n    const three = [] || 0 || true;\n    \n    console.log(one, two, three);",
      "explanation": "Objects are passed by reference. When we check objects for strict equality (`===`), we're comparing their references.\n\nWe set the default value for `person2` equal to the `person` object, and passed the `person` object as the value for `person1`.\n\nThis means that both values have a reference to the same spot in memory, thus they are equal.\n\nThe code block in the `else` statement gets run, and `They are the same!` gets logged.",
      "options": [
        { "text": "`5`", "correct": false },
        { "text": "`Promise {<pending>: 5}`", "correct": true },
        { "text": "`Promise {<fulfilled>: 5}`", "correct": false },
        { "text": "`Error`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's its value?\n    const myPromise = () => Promise.resolve('I have resolved!');\n    \n    function firstFunction() {\n      myPromise().then(res => console.log(res));\n      console.log('second');\n    }\n    \n    async function secondFunction() {\n      console.log(await myPromise());\n      console.log('second');\n    }\n    \n    firstFunction();\n    secondFunction();",
      "explanation": "In JavaScript, we have two ways to access properties on an object: bracket notation, or dot notation. In this example, we use dot notation (`colorConfig.colors`) instead of bracket notation (`colorConfig[\"colors\"]`).\n\nWith dot notation, JavaScript tries to find the property on the object with that exact name. In this example, JavaScript tries to find a property called `colors` on the `colorConfig` object. There is no property called `colors`, so this returns `undefined`. Then, we try to access the value of the first element by using `[1]`. We cannot do this on a value that's `undefined`, so it throws a `TypeError`: `Cannot read property '1' of undefined`.\n\nJavaScript interprets (or unboxes) statements. When we use bracket notation, it sees the first opening bracket `[` and keeps going until it finds the closing bracket `]`. Only then, it will evaluate the statement. If we would've used `colorConfig[colors[1]]`, it would have returned the value of the `red` property on the `colorConfig` object.",
      "options": [
        { "text": "`Not the same!`", "correct": false },
        { "text": "`They are the same!`", "correct": false },
        { "text": "`ReferenceError`", "correct": false },
        { "text": "`SyntaxError`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's its value?\n    const set = new Set();\n    \n    set.add(1);\n    set.add('Lydia');\n    set.add({ name: 'Lydia' });\n    \n    for (let item of set) {\n      console.log(item + 2);\n    }",
      "explanation": "Under the hood, emojis are unicodes. The unicodes for the heart emoji is `\"U+2764 U+FE0F\"`. These are always the same for the same emojis, so we're comparing two equal strings to each other, which returns true.",
      "options": [
        { "text": "`true`", "correct": true },
        { "text": "`false`", "correct": false },
        { "text": "`undefined`", "correct": false },
        { "text": "`TypeError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". Which of these methods modifies the original array?\n    Promise.resolve(5);",
      "explanation": "With `splice` method, we modify the original array by deleting, replacing or adding elements. In this case, we removed 2 items from index 1 (we removed `'🥑'` and `'😍'`) and added the ✨ emoji instead.\n\n`map`, `filter` and `slice` return a new array, `find` returns an element, and `reduce` returns a reduced value.",
      "options": [
        { "text": "`true`", "correct": false },
        { "text": "`false`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    function compareMembers(person1, person2 = person) {\n      if (person1 !== person2) {\n        console.log('Not the same!');\n      } else {\n        console.log('They are the same!');\n      }\n    }\n    \n    const person = { name: 'Lydia' };\n    \n    compareMembers(person);",
      "explanation": "We set the value of the `favoriteFood` property on the `info` object equal to the string with the pizza emoji, `'🍕'`. A string is a primitive data type. In JavaScript, primitive data types don't interact by reference.\n\nIn JavaScript, primitive data types (everything that's not an object) interact by _value_. In this case, we set the value of the `favoriteFood` property on the `info` object equal to the value of the first element in the `food` array, the string with the pizza emoji in this case (`'🍕'`). A string is a primitive data type, and interact by value (see my [blogpost](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) if you're interested in learning more)\n\nThen, we change the value of the `favoriteFood` property on the `info` object. The `food` array hasn't changed, since the value of `favoriteFood` was merely a _copy_ of the value of the first element in the array, and doesn't have a reference to the same spot in memory as the element on `food[0]`. When we log food, it's still the original array, `['🍕', '🍫', '🥑', '🍔']`.",
      "options": [
        { "text": "`All of them`", "correct": true },
        { "text": "`map` `reduce` `slice` `splice`", "correct": false },
        { "text": "`map` `slice` `splice`", "correct": false },
        { "text": "`splice`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What does this method do?\n    const colorConfig = {\n      red: true,\n      blue: false,\n      green: true,\n      black: true,\n      yellow: false,\n    };\n    \n    const colors = ['pink', 'red', 'blue'];\n    \n    console.log(colorConfig.colors[1]);",
      "explanation": "With the `JSON.parse()` method, we can parse JSON string to a JavaScript value.\n\n    // Stringifying a number into valid JSON, then parsing the JSON string to a JavaScript value:\n    const jsonNumber = JSON.stringify(4); // '4'\n    JSON.parse(jsonNumber); // 4\n    \n    // Stringifying an array value into valid JSON, then parsing the JSON string to a JavaScript value:\n    const jsonArray = JSON.stringify([1, 2, 3]); // '[1, 2, 3]'\n    JSON.parse(jsonArray); // [1, 2, 3]\n    \n    // Stringifying an object  into valid JSON, then parsing the JSON string to a JavaScript value:\n    const jsonArray = JSON.stringify({ name: 'Lydia' }); // '{\"name\":\"Lydia\"}'\n    JSON.parse(jsonArray); // { name: 'Lydia' }",
      "options": [
        { "text": "`['🍕', '🍫', '🥑', '🍔']`", "correct": true },
        { "text": "`['🍝', '🍫', '🥑', '🍔']`", "correct": false },
        { "text": "`['🍝', '🍕', '🍫', '🥑', '🍔']`", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    console.log('❤️' === '❤️');",
      "explanation": "Each function has its own _execution context_ (or _scope_). The `getName` function first looks within its own context (scope) to see if it contains the variable `name` we're trying to access. In this case, the `getName` function contains its own `name` variable: we declare the variable `name` with the `let` keyword, and with the value of `'Sarah'`.\n\nVariables with the `let` keyword (and `const`) are hoisted, but unlike `var`, don't get _initialized_. They are not accessible before the line we declare (initialize) them. This is called the \"temporal dead zone\". When we try to access the variables before they are declared, JavaScript throws a `ReferenceError`.\n\nIf we wouldn't have declared the `name` variable within the `getName` function, the javascript engine would've looked down the _scope chain_. The outer scope has a variable called `name` with the value of `Lydia`. In that case, it would've logged `Lydia`.\n\n    let name = 'Lydia';\n    \n    function getName() {\n      console.log(name);\n    }\n    \n    getName(); // Lydia",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const emojis = ['✨', '🥑', '😍'];\n    \n    emojis.map(x => x + '✨');\n    emojis.filter(x => x !== '🥑');\n    emojis.find(x => x !== '🥑');\n    emojis.reduce((acc, cur) => acc + '✨');\n    emojis.slice(1, 2, '✨');\n    emojis.splice(1, 2, '✨');",
      "explanation": "With the `yield` keyword, we `yield` values in a generator function. With the `yield*` keyword, we can yield values from another generator function, or iterable object (for example an array).\n\nIn `generatorOne`, we yield the entire array `['a', 'b', 'c']` using the `yield` keyword. The value of `value` property on the object returned by the `next` method on `one` (`one.next().value`) is equal to the entire array `['a', 'b', 'c']`.\n\n    console.log(one.next().value); // ['a', 'b', 'c']\n    console.log(one.next().value); // undefined\n    \n\nIn `generatorTwo`, we use the `yield*` keyword. This means that the first yielded value of `two`, is equal to the first yielded value in the iterator. The iterator is the array `['a', 'b', 'c']`. The first yielded value is `a`, so the first time we call `two.next().value`, `a` is returned.\n\n    console.log(two.next().value); // 'a'\n    console.log(two.next().value); // 'b'\n    console.log(two.next().value); // 'c'\n    console.log(two.next().value); // undefined",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "`undefined`", "correct": true },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const food = ['🍕', '🍫', '🥑', '🍔'];\n    const info = { favoriteFood: food[0] };\n    \n    info.favoriteFood = '🍝';\n    \n    console.log(food);",
      "explanation": "Expressions within template literals are evaluated first. This means that the string will contain the returned value of the expression, the immediately invoked function `(x => x)('I love')` in this case. We pass the value `'I love'` as an argument to the `x => x` arrow function. `x` is equal to `'I love'`, which gets returned. This results in `I love to program`.",
      "options": [
        { "text": "`a` and `a`", "correct": true },
        { "text": "`a` and `undefined`", "correct": false },
        { "text": "`['a', 'b', 'c']` and `a`", "correct": false },
        { "text": "`a` and `['a', 'b', 'c']`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What will happen?\n    JSON.parse();",
      "explanation": "Normally when we set objects equal to `null`, those objects get _garbage collected_ as there is no reference anymore to that object. However, since the callback function within `setInterval` is an arrow function (thus bound to the `config` object), the callback function still holds a reference to the `config` object. As long as there is a reference, the object won't get garbage collected. Since this is an interval, setting `config` to `null` or `delete`\\-ing `config.alert` won't garbage-collect the interval, so the interval will still be called. It should be cleared with `clearInterval(config.alert)` to remove it from memory. Since it was not cleared, the `setInterval` callback function will still get invoked every 1000ms (1s).",
      "options": [
        { "text": "`I love to program`", "correct": false },
        { "text": "`undefined to program`", "correct": false },
        { "text": "`${(x => x)('I love') to program`", "correct": true },
        { "text": "`TypeError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". Which method(s) will return the value 'Hello world!'?\n    // Stringifying a number into valid JSON, then parsing the JSON string to a JavaScript value:\n    const jsonNumber = JSON.stringify(4); // '4'\n    JSON.parse(jsonNumber); // 4\n    \n    // Stringifying an array value into valid JSON, then parsing the JSON string to a JavaScript value:\n    const jsonArray = JSON.stringify([1, 2, 3]); // '[1, 2, 3]'\n    JSON.parse(jsonArray); // [1, 2, 3]\n    \n    // Stringifying an object  into valid JSON, then parsing the JSON string to a JavaScript value:\n    const jsonArray = JSON.stringify({ name: 'Lydia' }); // '{\"name\":\"Lydia\"}'\n    JSON.parse(jsonArray); // { name: 'Lydia' }",
      "explanation": "When adding a key/value pair using the `set` method, the key will be the value of the first argument passed to the `set` function, and the value will be the second argument passed to the `set` function. The key is the _function_ `() => 'greeting'` in this case, and the value `'Hello world'`. `myMap` is now `{ () => 'greeting' => 'Hello world!' }`.\n\n1 is wrong, since the key is not `'greeting'` but `() => 'greeting'`. 3 is wrong, since we're creating a new function by passing it as a parameter to the `get` method. Object interact by _reference_. Functions are objects, which is why two functions are never strictly equal, even if they are identical: they have a reference to a different spot in memory.",
      "options": [
        { "text": "`setInterval` callback won't be invoked", "correct": false },
        { "text": "`setInterval` callback gets invoked once", "correct": true },
        {
          "text": "`setInterval` callback will still be called every second",
          "correct": false
        },
        { "text": "`config.alert()`, config is `null`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    let name = 'Lydia';\n    \n    function getName() {\n      console.log(name);\n      let name = 'Sarah';\n    }\n    \n    getName();",
      "explanation": "Both the `changeAge` and `changeAgeAndName` functions have a default parameter, namely a _newly_ created object `{ ...person }`. This object has copies of all the key/values in the `person` object.\n\nFirst, we invoke the `changeAge` function and pass the `person` object as its argument. This function increases the value of the `age` property by 1. `person` is now `{ name: \"Lydia\", age: 22 }`.\n\nThen, we invoke the `changeAgeAndName` function, however we don't pass a parameter. Instead, the value of `x` is equal to a _new_ object: `{ ...person }`. Since it's a new object, it doesn't affect the values of the properties on the `person` object. `person` is still equal to `{ name: \"Lydia\", age: 22 }`.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": true },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". Which of the following options will return 6?\n    let name = 'Lydia';\n    \n    function getName() {\n      console.log(name);\n    }\n    \n    getName(); // Lydia",
      "explanation": "With the spread operator `...`, we can _spread_ iterables to individual elements. The `sumValues` function receives three arguments: `x`, `y` and `z`. `...[1, 2, 3]` will result in `1, 2, 3`, which we pass to the `sumValues` function.",
      "options": [
        { "text": "`{name: \"Sarah\", age: 22}`", "correct": false },
        { "text": "`{name: \"Sarah\", age: 23}`", "correct": false },
        { "text": "`{name: \"Lydia\", age: 22}`", "correct": true },
        { "text": "`{name: \"Lydia\", age: 23}`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    function* generatorOne() {\n      yield ['a', 'b', 'c'];\n    }\n    \n    function* generatorTwo() {\n      yield* ['a', 'b', 'c'];\n    }\n    \n    const one = generatorOne();\n    const two = generatorTwo();\n    \n    console.log(one.next().value);\n    console.log(two.next().value);",
      "explanation": "With the `+=` operand, we're incrementing the value of `num` by `1`. `num` had the initial value `1`, so `1 + 1` is `2`. The item on the second index in the `list` array is 🥰, `console.log(list[2])` prints 🥰.",
      "options": [
        { "text": "`sumValues([...1, 2, 3])`", "correct": false },
        { "text": "`sumValues([...[1, 2, 3]])`", "correct": true },
        { "text": "`sumValues(...[1, 2, 3])`", "correct": false },
        { "text": "`sumValues([1, 2, 3])`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    console.log(one.next().value); // ['a', 'b', 'c']\n    console.log(one.next().value); // undefined",
      "explanation": "With the optional chaining operator `?.`, we no longer have to explicitly check whether the deeper nested values are valid or not. If we're trying to access a property on an `undefined` or `null` value (_nullish_), the expression short-circuits and returns `undefined`.\n\n`person.pet?.name`: `person` has a property named `pet`: `person.pet` is not nullish. It has a property called `name`, and returns `Mara`. `person.pet?.family?.name`: `person` has a property named `pet`: `person.pet` is not nullish. `pet` does _not_ have a property called `family`, `person.pet.family` is nullish. The expression returns `undefined`. `person.getFullName?.()`: `person` has a property named `getFullName`: `person.getFullName()` is not nullish and can get invoked, which returns `Lydia Hallie`. `member.getLastName?.()`: `member` is not defined: `member.getLastName()` is nullish. The expression returns `undefined`.",
      "options": [
        { "text": "`🤠`", "correct": false },
        { "text": "`🥰`", "correct": true },
        { "text": "`SyntaxError`", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    console.log(two.next().value); // 'a'\n    console.log(two.next().value); // 'b'\n    console.log(two.next().value); // 'c'\n    console.log(two.next().value); // undefined",
      "explanation": "We passed the condition `groceries.indexOf(\"banana\")` to the if-statement. `groceries.indexOf(\"banana\")` returns `0`, which is a falsy value. Since the condition in the if-statement is falsy, the code in the `else` block runs, and `We don't have to buy bananas!` gets logged.",
      "options": [
        {
          "text": "`undefined` `undefined` `undefined` `undefined`",
          "correct": false
        },
        {
          "text": "`Mara` `undefined` `Lydia Hallie` `ReferenceError`",
          "correct": true
        },
        { "text": "`Mara` `null` `Lydia Hallie` `null`", "correct": false },
        {
          "text": "`null` `ReferenceError` `null` `ReferenceError`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    console.log(`${(x => x)('I love')} to program`);",
      "explanation": "The `language` method is a `setter`. Setters don't hold an actual value, their purpose is to _modify_ properties. When calling a `setter` method, `undefined` gets returned.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "`undefined`", "correct": false },
        { "text": "`1`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    let config = {\n      alert: setInterval(() => {\n        console.log('Alert!');\n      }, 1000),\n    };\n    \n    config = null;",
      "explanation": "`typeof name` returns `\"string\"`. The string `\"string\"` is a truthy value, so `!typeof name` returns the boolean value `false`. `false === \"object\"` and `false === \"string\"` both return`false`.\n\n(If we wanted to check whether the type was (un)equal to a certain type, we should've written `!==` instead of `!typeof`)",
      "options": [
        {
          "text": "`function language(lang) { this.languages.push(lang }`",
          "correct": false
        },
        { "text": "`0`", "correct": false },
        { "text": "`[]`", "correct": true },
        { "text": "`undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const myMap = new Map();\n    const myFunc = () => 'greeting';\n    \n    myMap.set(myFunc, 'Hello world!');\n    \n    //1\n    myMap.get('greeting');\n    //2\n    myMap.get(myFunc);\n    //3\n    myMap.get(() => 'greeting');",
      "explanation": "The `add` function returns an arrow function, which returns an arrow function, which returns an arrow function (still with me?). The first function receives an argument `x` with the value of `4`. We invoke the second function, which receives an argument `y` with the value `5`. Then we invoke the third function, which receives an argument `z` with the value `6`. When we're trying to access the value `x`, `y` and `z` within the last arrow function, the JS engine goes up the scope chain in order to find the values for `x` and `y` accordingly. This returns `4` `5` `6`.",
      "options": [
        { "text": "`false` `true`", "correct": true },
        { "text": "`true` `false`", "correct": false },
        { "text": "`false` `false`", "correct": false },
        { "text": "`true` `true`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const person = {\n      name: 'Lydia',\n      age: 21,\n    };\n    \n    const changeAge = (x = { ...person }) => (x.age += 1);\n    const changeAgeAndName = (x = { ...person }) => {\n      x.age += 1;\n      x.name = 'Sarah';\n    };\n    \n    changeAge(person);\n    changeAgeAndName();\n    \n    console.log(person);",
      "explanation": "The generator function `range` returns an async object with promises for each item in the range we pass: `Promise{1}`, `Promise{2}`, `Promise{3}`. We set the variable `gen` equal to the async object, after which we loop over it using a `for await ... of` loop. We set the variable `item` equal to the returned Promise values: first `Promise{1}`, then `Promise{2}`, then `Promise{3}`. Since we're _awaiting_ the value of `item`, the resolved promsie, the resolved _values_ of the promises get returned: `1`, `2`, then `3`.",
      "options": [
        { "text": "`4` `5` `6`", "correct": false },
        { "text": "`6` `5` `4`", "correct": false },
        { "text": "`4` `function` `function`", "correct": true },
        { "text": "`undefined` `undefined` `6`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    function sumValues(x, y, z) {\n      return x + y + z;\n    }",
      "explanation": "`myFunc` expects an object with properties `x`, `y` and `z` as its argument. Since we're only passing three separate numeric values (1, 2, 3) instead of one object with properties `x`, `y` and `z` ({x: 1, y: 2, z: 3}), `x`, `y` and `z` have their default value of `undefined`.",
      "options": [
        {
          "text": "`Promise {1}` `Promise {2}` `Promise {3}`",
          "correct": false
        },
        {
          "text": "`Promise {<pending>}` `Promise {<pending>}` `Promise {<pending>}`",
          "correct": false
        },
        { "text": "`1` `2` `3`", "correct": false },
        { "text": "`undefined` `undefined` `undefined`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    let num = 1;\n    const list = ['🥳', '🤠', '🥰', '🤪'];\n    \n    console.log(list[(num += 1)]);",
      "explanation": "With the `Intl.NumberFormat` method, we can format numeric values to any locale. We format the numeric value `130` to the `en-US` locale as a `unit` in `mile-per-hour`, which results in `130 mph`. The numeric value `300` to the `en-US` locale as a `currency` in `USD` results in `$300.00`.",
      "options": [
        { "text": "`1` `2` `3`", "correct": false },
        { "text": "`{1: 1}` `{2: 2}` `{3: 3}`", "correct": true },
        {
          "text": "`{ 1: undefined }` `undefined` `undefined`",
          "correct": false
        },
        { "text": "`undefined` `undefined` `undefined`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const person = {\n      firstName: 'Lydia',\n      lastName: 'Hallie',\n      pet: {\n        name: 'Mara',\n        breed: 'Dutch Tulip Hound',\n      },\n      getFullName() {\n        return `${this.firstName} ${this.lastName}`;\n      },\n    };\n    \n    console.log(person.pet?.name);\n    console.log(person.pet?.family?.name);\n    console.log(person.getFullName?.());\n    console.log(member.getLastName?.());",
      "explanation": "By destructuring objects, we can unpack values from the right-hand object, and assign the unpacked value to the value of the same property name on the left-hand object. In this case, we're assigning the value \"💀\" to `spookyItems[3]`. This means that we're modifying the `spookyItems` array, we're adding the \"💀\" to it. When logging `spookyItems`, `[\"👻\", \"🎃\", \"🕸\", \"💀\"]` gets logged.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": true },
        { "text": "", "correct": false },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const groceries = ['banana', 'apple', 'peanuts'];\n    \n    if (groceries.indexOf('banana')) {\n      console.log('We have to buy bananas!');\n    } else {\n      console.log(`We don't have to buy bananas!`);\n    }",
      "explanation": "With the `Number.isNaN` method, you can check if the value you pass is a _numeric value_ and equal to `NaN`. `name` is not a numeric value, so `Number.isNaN(name)` returns `false`. `age` is a numeric value, but is not equal to `NaN`, so `Number.isNaN(age)` returns `false`.\n\nWith the `isNaN` method, you can check if the value you pass is not a number. `name` is not a number, so `isNaN(name)` returns true. `age` is a number, so `isNaN(age)` returns `false`.",
      "options": [
        { "text": "`[\"👻\", \"🎃\", \"🕸\"]`", "correct": false },
        { "text": "`[\"👻\", \"🎃\", \"🕸\", \"💀\"]`", "correct": false },
        {
          "text": "`[\"👻\", \"🎃\", \"🕸\", { item: \"💀\" }]`",
          "correct": true
        },
        {
          "text": "`[\"👻\", \"🎃\", \"🕸\", \"[object Object]\"]`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const config = {\n      languages: [],\n      set language(lang) {\n        return this.languages.push(lang);\n      },\n    };\n    \n    console.log(config.language);",
      "explanation": "Variables declared with the `const` keyword are not referencable before their initialization: this is called the _temporal dead zone_. In the `getInfo` function, the variable `randomValue` is scoped in the functional scope of `getInfo`. On the line where we want to log the value of `typeof randomValue`, the variable `randomValue` isn't initialized yet: a `ReferenceError` gets thrown! The engine didn't go down the scope chain since we declared the variable `randomValue` in the `getInfo` function.",
      "options": [
        { "text": "`true` `false` `true` `false`", "correct": false },
        { "text": "`true` `false` `false` `false`", "correct": false },
        { "text": "`false` `false` `true` `false`", "correct": false },
        { "text": "`false` `true` `false` `true`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const name = 'Lydia Hallie';\n    \n    console.log(!typeof name === 'object');\n    console.log(!typeof name === 'string');",
      "explanation": "In the `try` block, we're logging the awaited value of the `myPromise` variable: `\"Woah some cool data\"`. Since no errors were thrown in the `try` block, the code in the `catch` block doesn't run. The code in the `finally` block _always_ runs, `\"Oh finally!\"` gets logged.",
      "options": [
        { "text": "`\"number\"`", "correct": false },
        { "text": "`\"string\"`", "correct": false },
        { "text": "`undefined`", "correct": true },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const add = x => y => z => {\n      console.log(x, y, z);\n      return x + y + z;\n    };\n    \n    add(4)(5)(6);",
      "explanation": "With the `flat` method, we can create a new, flattened array. The depth of the flattened array depends on the value that we pass. In this case, we passed the value `1` (which we didn't have to, that's the default value), meaning that only the arrays on the first depth will be concatenated. `['🥑']` and `['✨', '✨', ['🍕', '🍕']]` in this case. Concatenating these two arrays results in `['🥑', '✨', '✨', ['🍕', '🍕']]`.",
      "options": [
        { "text": "`Woah some cool data`", "correct": false },
        { "text": "`Oh finally!`", "correct": true },
        { "text": "`Woah some cool data` `Oh finally!`", "correct": false },
        { "text": "`Oops didn't work` `Oh finally!`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    async function* range(start, end) {\n      for (let i = start; i <= end; i++) {\n        yield Promise.resolve(i);\n      }\n    }\n    \n    (async () => {\n      const gen = range(1, 3);\n      for await (const item of gen) {\n        console.log(item);\n      }\n    })();",
      "explanation": "`counterOne` is an instance of the `Counter` class. The counter class contains a `count` property on its constructor, and an `increment` method. First, we invoked the `increment` method twice by calling `counterOne.increment()`. Currently, `counterOne.count` is `2`.\n\n![](https://i.imgur.com/KxLlTm9.png)\n\nThen, we create a new variable `counterTwo`, and set it equal to `counterOne`. Since objects interact by reference, we're just creating a new reference to the same spot in memory that `counterOne` points to. Since it has the same spot in memory, any changes made to the object that `counterTwo` has a reference to, also apply to `counterOne`. Currently, `counterTwo.count` is `2`.\n\nWe invoke the `counterTwo.increment()`, which sets the `count` to `3`. Then, we log the count on `counterOne`, which logs `3`.\n\n![](https://i.imgur.com/BNBHXmc.png)",
      "options": [
        { "text": "`['🥑', ['✨', '✨', ['🍕', '🍕']]]`", "correct": false },
        { "text": "`['🥑', '✨', '✨', ['🍕', '🍕']]`", "correct": false },
        { "text": "`['🥑', ['✨', '✨', '🍕', '🍕']]`", "correct": false },
        { "text": "`['🥑', '✨', '✨', '🍕', '🍕']`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const myFunc = ({ x, y, z }) => {\n      console.log(x, y, z);\n    };\n    \n    myFunc(1, 2, 3);",
      "explanation": "First, we invoke `funcOne`. On the first line of `funcOne`, we call the `myPromise` promise, which is an _asynchronous_ operation. While the engine is busy completing the promise, it keeps on running the function `funcOne`. The next line is the _asynchronous_ `setTimeout` function, from which the callback is sent to the Web API. (see my article on the event loop [here](https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif).)\n\nBoth the promise and the timeout are asynchronous operations, the function keeps on running while it's busy completing the promise and handling the `setTimeout` callback. This means that `Last line!` gets logged first, since this is not an asynchonous operation. This is the last line of `funcOne`, the promise resolved, and `Promise!` gets logged. However, since we're invoking `funcTwo()`, the call stack isn't empty, and the callback of the `setTimeout` function cannot get added to the callstack yet.\n\nIn `funcTwo` we're, first _awaiting_ the myPromise promise. With the `await` keyword, we pause the execution of the function until the promise has resolved (or rejected). Then, we log the awaited value of `res` (since the promise itself returns a promise). This logs `Promise!`.\n\nThe next line is the _asynchronous_ `setTimeout` function, from which the callback is sent to the Web API.\n\nWe get to the last line of `funcTwo`, which logs `Last line!` to the console. Now, since `funcTwo` popped off the call stack, the call stack is empty. The callbacks waiting in the queue (`() => console.log(\"Timeout!\")` from `funcOne`, and `() => console.log(\"Timeout!\")` from `funcTwo`) get added to the call stack one by one. The first callback logs `Timeout!`, and gets popped off the stack. Then, the second callback logs `Timeout!`, and gets popped off the stack. This logs `Last line! Promise! Promise! Last line! Timeout! Timeout!`",
      "options": [
        { "text": "`0`", "correct": false },
        { "text": "`1`", "correct": false },
        { "text": "`2`", "correct": false },
        { "text": "`3`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". How can we invoke sum in sum.js from index.js?\n    function getFine(speed, amount) {\n      const formattedSpeed = new Intl.NumberFormat('en-US', {\n        style: 'unit',\n        unit: 'mile-per-hour'\n      }).format(speed);\n    \n      const formattedAmount = new Intl.NumberFormat('en-US', {\n        style: 'currency',\n        currency: 'USD'\n      }).format(amount);\n    \n      return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`;\n    }\n    \n    console.log(getFine(130, 300))",
      "explanation": "With the asterisk `*`, we import all exported values from that file, both default and named. If we had the following file:\n\n    // info.js\n    export const name = 'Lydia';\n    export const age = 21;\n    export default 'I love JavaScript';\n    \n    // index.js\n    import * as info from './info';\n    console.log(info);\n    \n\nThe following would get logged:\n\n    {\n      default: \"I love JavaScript\",\n      name: \"Lydia\",\n      age: 21\n    }\n    \n\nFor the `sum` example, it means that the imported value `sum` looks like this:\n\n    { default: function sum(x) { return x + x } }\n    \n\nWe can invoke this function, by calling `sum.default`",
      "options": [
        {
          "text": "`Promise! Last line! Promise! Last line! Last line! Promise!`",
          "correct": false
        },
        {
          "text": "`Last line! Timeout! Promise! Last line! Timeout! Promise!`",
          "correct": false
        },
        {
          "text": "`Promise! Last line! Last line! Promise! Timeout! Timeout!`",
          "correct": true
        },
        {
          "text": "`Last line! Promise! Promise! Last line! Timeout! Timeout!`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const spookyItems = ['👻', '🎃', '🕸'];\n    ({ item: spookyItems[3] } = { item: '💀' });\n    \n    console.log(spookyItems);",
      "explanation": "With a Proxy object, we can add custom behavior to an object that we pass to it as the second argument. In this case, we pass the `handler` object which contained to properties: `set` and `get`. `set` gets invoked whenever we _set_ property values, `get` gets invoked whenever we _get_ (access) property values.\n\nThe first argument is an empty object `{}`, which is the value of `person`. To this object, the custom behavior specified in the `handler` object gets added. If we add a property to the `person` object, `set` will get invoked. If we access a property on the `person` object, `get` gets invoked.\n\nFirst, we added a new property `name` to the proxy object (`person.name = \"Lydia\"`). `set` gets invoked, and logs `\"Added a new property!\"`.\n\nThen, we access a property value on the proxy object, the `get` property on the handler object got invoked. `\"Accessed a property!\"` gets logged.",
      "options": [
        { "text": "`sum(4)`", "correct": false },
        { "text": "`sum.sum(4)`", "correct": false },
        { "text": "`sum.default(4)`", "correct": true },
        { "text": "`*`, only named exports", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". Which of the following will modify the person object?\n    const name = 'Lydia Hallie';\n    const age = 21;\n    \n    console.log(Number.isNaN(name));\n    console.log(Number.isNaN(age));\n    \n    console.log(isNaN(name));\n    console.log(isNaN(age));",
      "explanation": "With `Object.seal` we can prevent new properies from being _added_, or existing properties to be _removed_.\n\nHowever, you can still modify the value of existing properties.",
      "options": [
        { "text": "`Added a new property!`", "correct": true },
        { "text": "`Accessed a property!`", "correct": false },
        {
          "text": "`Added a new property!` `Accessed a property!`",
          "correct": false
        },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". Which of the following will modify the person object?\n    const randomValue = 21;\n    \n    function getInfo() {\n      console.log(typeof randomValue);\n      const randomValue = 'Lydia Hallie';\n    }\n    \n    getInfo();",
      "explanation": "The `Object.freeze` method _freezes_ an object. No properties can be added, modified, or removed.\n\nHowever, it only _shallowly_ freezes the object, meaning that only _direct_ properties on the object are frozen. If the property is another object, like `address` in this case, the properties on that object aren't frozen, and can be modified.",
      "options": [
        { "text": "`person.name = \"Evan Bacon\"`", "correct": false },
        { "text": "`person.age = 21`", "correct": false },
        { "text": "`delete person.name`", "correct": true },
        { "text": "`Object.assign(person, { age: 21 })`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const myPromise = Promise.resolve('Woah some cool data');\n    \n    (async () => {\n      try {\n        console.log(await myPromise);\n      } catch {\n        throw new Error(`Oops didn't work`);\n      } finally {\n        console.log('Oh finally!');\n      }\n    })();",
      "explanation": "First, we invoked `myFunc()` without passing any arguments. Since we didn't pass arguments, `num` and `value` got their default values: num is `2`, and `value` the returned value of the function `add`. To the `add` function, we pass `num` as an argument, which had the value of `2`. `add` returns `4`, which is the value of `value`.\n\nThen, we invoked `myFunc(3)` and passed the value `3` as the value for the argument `num`. We didn't pass an argument for `value`. Since we didn't pass a value for the `value` argument, it got the default value: the returned value of the `add` function. To `add`, we pass `num`, which has the value of `3`. `add` returns `6`, which is the value of `value`.",
      "options": [
        { "text": "`person.name = \"Evan Bacon\"`", "correct": true },
        { "text": "`delete person.address`", "correct": false },
        {
          "text": "`person.address.street = \"101 Main St\"`",
          "correct": false
        },
        { "text": "`person.pet = { name: \"Mara\" }`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const emojis = ['🥑', ['✨', '✨', ['🍕', '🍕']]];\n    \n    console.log(emojis.flat(1));",
      "explanation": "In ES2020, we can add private variables in classes by using the `#`. We cannot access these variables outside of the class. When we try to log `counter.#number`, a SyntaxError gets thrown: we cannot acccess it outside the `Counter` class!",
      "options": [
        { "text": "`2` `4` and `3` `6`", "correct": false },
        { "text": "`2` `NaN` and `3` `NaN`", "correct": false },
        { "text": "`2` `Error` and `3` `6`", "correct": false },
        { "text": "`2` `4` and `3` `Error`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's missing?\n    class Counter {\n      constructor() {\n        this.count = 0;\n      }\n    \n      increment() {\n        this.count++;\n      }\n    }\n    \n    const counterOne = new Counter();\n    counterOne.increment();\n    counterOne.increment();\n    \n    const counterTwo = counterOne;\n    counterTwo.increment();\n    \n    console.log(counterOne.count);",
      "explanation": "In order to iterate over the `members` in each element in the `teams` array, we need to pass `teams[i].members` to the `getMembers` generator function. The generator function returns a generator object. In order to iterate over each element in this generator object, we need to use `yield*`.\n\nIf we would've written `yield`, `return yield`, or `return`, the entire generator function would've gotten returned the first time we called the `next` method.",
      "options": [
        { "text": "`10`", "correct": false },
        { "text": "`11`", "correct": true },
        { "text": "`undefined`", "correct": false },
        { "text": "`SyntaxError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const myPromise = Promise.resolve(Promise.resolve('Promise!'));\n    \n    function funcOne() {\n      myPromise.then(res => res).then(res => console.log(res));\n      setTimeout(() => console.log('Timeout!'), 0);\n      console.log('Last line!');\n    }\n    \n    async function funcTwo() {\n      const res = await myPromise;\n      console.log(await res);\n      setTimeout(() => console.log('Timeout!'), 0);\n      console.log('Last line!');\n    }\n    \n    funcOne();\n    funcTwo();",
      "explanation": "The `addHobby` function receives two arguments, `hobby` and `hobbies` with the default value of the `hobbies` array on the `person` object.\n\nFirst, we invoke the `addHobby` function, and pass `\"running\"` as the value for `hobby` and an empty array as the value for `hobbies`. Since we pass an empty array as the value for `y`, `\"running\"` gets added to this empty array.\n\nThen, we invoke the `addHobby` function, and pass `\"dancing\"` as the value for `hobby`. We didn't pass a value for `hobbies`, so it gets the default value, the `hobbies` property on the `person` object. We push the hobby `dancing` to the `person.hobbies` array.\n\nLast, we invoke the `addHobby` function, and pass `\"baking\"` as the value for `hobby`, and the `person.hobbies` array as the value for `hobbies`. We push the hobby `baking` to the `person.hobbies` array.\n\nAfter pushing `dancing` and `baking`, the value of `person.hobbies` is `[\"coding\", \"dancing\", \"baking\"]`",
      "options": [
        { "text": "`yield getMembers(teams[i].members)`", "correct": false },
        { "text": "`yield* getMembers(teams[i].members)`", "correct": false },
        { "text": "`return getMembers(teams[i].members)`", "correct": true },
        {
          "text": "`return yield getMembers(teams[i].members)`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    // sum.js\n    export default function sum(x) {\n      return x + x;\n    }\n    \n    // index.js\n    import * as sum from './sum';",
      "explanation": "We create the variable `pet` which is an instance of the `Flamingo` class. When we instantiate this instance, the `constructor` on `Flamingo` gets called. First, `\"I'm pink. 🌸\"` gets logged, after which we call `super()`. `super()` calls the constructor of the parent class, `Bird`. The constructor in `Bird` gets called, and logs `\"I'm a bird. 🦢\"`.",
      "options": [
        { "text": "`[\"coding\"]`", "correct": false },
        { "text": "`[\"coding\", \"dancing\"]`", "correct": true },
        { "text": "`[\"coding\", \"dancing\", \"baking\"]`", "correct": false },
        {
          "text": "`[\"coding\", \"running\", \"dancing\", \"baking\"]`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". Which of the options result(s) in an error?\n    // info.js\n    export const name = 'Lydia';\n    export const age = 21;\n    export default 'I love JavaScript';\n    \n    // index.js\n    import * as info from './info';\n    console.log(info);",
      "explanation": "The `const` keyword simply means we cannot _redeclare_ the value of that variable, it's _read-only_. However, the value itself isn't immutable. The properties on the `emojis` array can be modified, for example by pushing new values, splicing them, or setting the length of the array to 0.",
      "options": [
        { "text": "`I'm pink. 🌸`", "correct": false },
        { "text": "`I'm pink. 🌸` `I'm a bird. 🦢`", "correct": false },
        { "text": "`I'm a bird. 🦢` `I'm pink. 🌸`", "correct": false },
        { "text": "", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What do we need to add to the person object to get \\[\"Lydia Hallie\", 21\\] as the output of \\[...person\\]?\n    {\n      default: \"I love JavaScript\",\n      name: \"Lydia\",\n      age: 21\n    }",
      "explanation": "Objects aren't iterable by default. An iterable is an iterable if the iterator protocol is present. We can add this manually by adding the iterator symbol `[Symbol.iterator]`, which has to return a generator object, for example by making it a generator function `*[Symbol.iterator]() {}`. This generator function has to yield the `Object.values` of the `person` object if we want it to return the array `[\"Lydia Hallie\", 21]`: `yield* Object.values(this)`.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": true },
        { "text": "", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    { default: function sum(x) { return x + x } }",
      "explanation": "The `if` condition within the `forEach` loop checks whether the value of `num` is truthy or falsy. Since the first number in the `nums` array is `0`, a falsy value, the `if` statement's code block won't be executed. `count` only gets incremented for the other 3 numbers in the `nums` array, `1`, `2` and `3`. Since `count` gets incremented by `1` 3 times, the value of `count` is `3`.",
      "options": [
        { "text": "", "correct": false },
        {
          "text": "`*[Symbol.iterator]() { for (let x in this) yield* this[x] }`",
          "correct": false
        },
        {
          "text": "`*[Symbol.iterator]() { yield* Object.values(this) }`",
          "correct": true
        },
        {
          "text": "`*[Symbol.iterator]() { for (let x in this) yield this }`",
          "correct": false
        }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const handler = {\n      set: () => console.log('Added a new property!'),\n      get: () => console.log('Accessed a property!'),\n    };\n    \n    const person = new Proxy({}, handler);\n    \n    person.name = 'Lydia';\n    person.name;",
      "explanation": "The `?` allows us to optionally access deeper nested properties within objects. We're trying to log the item on index `1` within the subarray that's on index `1` of the `fruits` array. If the subarray on index `1` in the `fruits` array doesn't exist, it'll simply return `undefined`. If the subarray on index `1` in the `fruits` array exists, but this subarray doesn't have an item on its `1` index, it'll also return `undefined`.\n\nFirst, we're trying to log the second item in the `['🍍']` subarray of `[['🍊', '🍌'], ['🍍']]`. This subarray only contains one item, which means there is no item on index `1`, and returns `undefined`.\n\nThen, we're invoking the `getFruits` function without passing a value as an argument, which means that `fruits` has a value of `undefined` by default. Since we're conditionally chaining the item on index `1` of`fruits`, it returns `undefined` since this item on index `1` does not exist.\n\nLastly, we're trying to log the second item in the `['🍊', '🍌']` subarray of `['🍍'], ['🍊', '🍌']`. The item on index `1` within this subarray is `🍌`, which gets logged.",
      "options": [
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": false },
        { "text": "", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const person = { name: 'Lydia Hallie' };\n    \n    Object.seal(person);",
      "explanation": "We set the variable `calc` equal to a new instance of the `Calc` class. Then, we instantiate a new instance of `Calc`, and invoke the `increase` method on this instance. Since the count property is within the constructor of the `Calc` class, the count property is not shared on the prototype of `Calc`. This means that the value of count has not been updated for the instance calc points to, count is still `0`.",
      "options": [
        { "text": "`null`, `undefined`, 🍌", "correct": true },
        { "text": "`[]`, `null`, 🍌", "correct": false },
        { "text": "`[]`, `[]`, 🍌", "correct": false },
        { "text": "`undefined`, `undefined`, 🍌", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const person = {\n      name: 'Lydia Hallie',\n      address: {\n        street: '100 Main St',\n      },\n    };\n    \n    Object.freeze(person);",
      "explanation": "The `updateUser` function updates the values of the `email` and `password` properties on user, if their values are passed to the function, after which the function returns the `user` object. The returned value of the `updateUser` function is the `user` object, which means that the value of updatedUser is a reference to the same `user` object that `user` points to. `updatedUser === user` equals `true`.",
      "options": [
        { "text": "`0`", "correct": false },
        { "text": "`1`", "correct": true },
        { "text": "`undefined`", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const add = x => x + x;\n    \n    function myFunc(num = 2, value = add(num)) {\n      console.log(num, value);\n    }\n    \n    myFunc();\n    myFunc(3);",
      "explanation": "First, we invoke the `slice` method on the fruit array. The slice method does not modify the original array, but returns the value that it sliced off the array: the banana emoji. Then, we invoke the `splice` method on the fruit array. The splice method does modify the original array, which means that the fruit array now consists of `['🍊', '🍎']`. At last, we invoke the `unshift` method on the `fruit` array, which modifies the original array by adding the provided value, ‘🍇’ in this case, as the first element in the array. The fruit array now consists of `['🍇', '🍊', '🍎']`.",
      "options": [
        { "text": "`false`", "correct": false },
        { "text": "`true`", "correct": false },
        { "text": "`TypeError`", "correct": true },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    class Counter {\n      #number = 10\n    \n      increment() {\n        this.#number++\n      }\n    \n      getNum() {\n        return this.#number\n      }\n    }\n    \n    const counter = new Counter()\n    counter.increment()\n    \n    console.log(counter.#number)",
      "explanation": "Object keys are converted to strings.\n\nSince the value of `dog` is an object, `animals[dog]` actually means that we’re creating a new property called `\"object Object\"` equal to the new object. `animals[\"object Object\"]` is now equal to `{ emoji: \"🐶\", name: \"Mara\"}`.\n\n`cat` is also an object, which means that `animals[cat]` actually means that we’re overwriting the value of `animals[``\"``object Object``\"``]` with the new cat properties.\n\nLogging `animals[dog]`, or actually `animals[\"object Object\"]` since converting the `dog` object to a string results `\"object Object\"`, returns the `{ emoji: \"🐈\", name: \"Sara\" }`.",
      "options": [
        { "text": "`['🍌', '🍊', '🍎']`", "correct": false },
        { "text": "`['🍊', '🍎']`", "correct": true },
        { "text": "`['🍇', '🍊', '🍎']`", "correct": false },
        { "text": "`['🍇', '🍌', '🍊', '🍎']`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const teams = [\n      { name: 'Team 1', members: ['Paul', 'Lisa'] },\n      { name: 'Team 2', members: ['Laura', 'Tim'] },\n    ];\n    \n    function* getMembers(members) {\n      for (let i = 0; i < members.length; i++) {\n        yield members[i];\n      }\n    }\n    \n    function* getTeams(teams) {\n      for (let i = 0; i < teams.length; i++) {\n        // ✨ SOMETHING IS MISSING HERE ✨\n      }\n    }\n    \n    const obj = getTeams(teams);\n    obj.next(); // { value: \"Paul\", done: false }\n    obj.next(); // { value: \"Lisa\", done: false }",
      "explanation": "The `updateEmail` function is an arrow function, and is not bound to the `user` object. This means that the `this` keyword is not referring to the `user` object, but refers to the global scope in this case. The value of `email` within the `user` object does not get updated. When logging the value of `user.email`, the original value of `my@email.com` gets returned.",
      "options": [
        { "text": "`{ emoji: \"🐶\", name: \"Mara\" }`", "correct": true },
        { "text": "`{ emoji: \"🐈\", name: \"Sara\" }`", "correct": false },
        { "text": "`undefined`", "correct": false },
        { "text": "`ReferenceError`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const person = {\n      name: 'Lydia Hallie',\n      hobbies: ['coding'],\n    };\n    \n    function addHobby(hobby, hobbies = person.hobbies) {\n      hobbies.push(hobby);\n      return hobbies;\n    }\n    \n    addHobby('running', []);\n    addHobby('dancing');\n    addHobby('baking', person.hobbies);\n    \n    console.log(person.hobbies);",
      "explanation": "The `Promise.all` method runs the passed promises in parallel. If one promise fails, the `Promise.all` method _rejects_ with the value of the rejected promise. In this case, `promise3` rejected with the value `\"Third\"`. We’re catching the rejected value in the chained `catch` method on the `runPromises` invocation to catch any errors within the `runPromises` function. Only `\"Third\"` gets logged, since `promise3` rejected with this value.",
      "options": [
        { "text": "`my@email.com`", "correct": false },
        { "text": "`new@email.com`", "correct": false },
        { "text": "`undefined`", "correct": false },
        { "text": "`ReferenceError`", "correct": true }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What should the value of method be to log { name: \"Lydia\", age: 22 }?\n    class Bird {\n      constructor() {\n        console.log(\"I'm a bird. 🦢\");\n      }\n    }\n    \n    class Flamingo extends Bird {\n      constructor() {\n        console.log(\"I'm pink. 🌸\");\n        super();\n      }\n    }\n    \n    const pet = new Flamingo();",
      "explanation": "The `fromEntries` method turns a 2d array into an object. The first element in each subarray will be the key, and the second element in each subarray will be the value. In this case, we’re mapping over the `keys` array, which returns an array which first element is the item on the key array on the current index, and the second element is the item of the values array on the current index.\n\nThis creates an array of subarrays containing the correct keys and values, which results in `{ name: \"Lydia\", age: 22 }`",
      "options": [
        { "text": "`[['First', 'Second'], ['Fourth']]`", "correct": false },
        {
          "text": "`[['First', 'Second'], ['Third', 'Fourth']]`",
          "correct": false
        },
        { "text": "`[['First', 'Second']]`", "correct": true },
        { "text": "`'Third'`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const emojis = ['🎄', '🎅🏼', '🎁', '⭐'];\n    \n    /* 1 */ emojis.push('🦌');\n    /* 2 */ emojis.splice(0, 2);\n    /* 3 */ emojis = [...emojis, '🥂'];\n    /* 4 */ emojis.length = 0;",
      "explanation": "The default value of `address` is an empty object `{}`. When we set the variable `member` equal to the object returned by the `createMember` function, we didn't pass a value for address, which means that the value of address is the default empty object `{}`. An empty object is a truthy value, which means that the condition of the `address ? address : null` conditional returns `true`. The value of address is the empty object `{}`.",
      "options": [
        { "text": "`entries`", "correct": false },
        { "text": "`values`", "correct": false },
        { "text": "`fromEntries`", "correct": true },
        { "text": "`forEach`", "correct": false }
      ]
    },
    {
      "type": "MCQ",
      "statement": ". What's the output?\n    const person = {\n      name: \"Lydia Hallie\",\n      age: 21\n    }\n    \n    [...person] // [\"Lydia Hallie\", 21]",
      "explanation": "The condition within the `if` statement checks whether the value of `!typeof randomValue` is equal to `\"string\"`. The `!` operator converts the value to a boolean value. If the value is truthy, the returned value will be `false`, if the value is falsy, the returned value will be `true`. In this case, the returned value of `typeof randomValue` is the truthy value `\"number\"`, meaning that the value of `!typeof randomValue` is the boolean value `false`.\n\n`!typeof randomValue === \"string\"` always returns false, since we're actually checking `false === \"string\"`. Since the condition returned `false`, the code block of the `else` statement gets run, and `Yay it's a string!` gets logged.",
      "options": [
        {
          "text": "`{ email: \"my@email.com\", address: null }`",
          "correct": false
        },
        { "text": "`{ email: \"my@email.com\" }`", "correct": true },
        {
          "text": "`{ email: \"my@email.com\", address: {} }`",
          "correct": false
        },
        {
          "text": "`{ email: \"my@email.com\", address: undefined }`",
          "correct": false
        }
      ]
    },
    {
      "statement": "How many expressions are there in the following statement: \\`a = b \\* 2;\\` ?",
      "explanation": "This statement has four expressions in it: 2 is a literal value expression; b is a variable expression, which means to retrieve its current value; b \\\\\\* 2 is an arithmetic expression, which means to do the multiplication; a = b \\\\\\* 2 is an assignment expression, which means to assign the result of the b \\\\\\* 2 expression to the variable a.",
      "type": "MCQ",
      "options": [
        { "text": "One", "correct": false },
        { "text": "Two", "correct": false },
        { "text": "Three", "correct": false },
        { "text": "Four", "correct": true }
      ]
    },
    {
      "statement": "What is a computer program (source code / code)?",
      "explanation": "A program, often referred to as source code or just code, is a set of special instructions to tell the computer what tasks to perform. Usually code is saved in a text file, although with JavaScript you can also type code directly into a developer console in a browser.",
      "type": "MCQ",
      "options": [
        {
          "text": "A set of special instructions to tell the computer what tasks to perform.",
          "correct": true
        },
        {
          "text": "A planned series of future events or performances.",
          "correct": false
        },
        {
          "text": "A sheet or booklet giving details of items or performers at an event or performance.",
          "correct": false
        },
        {
          "text": "A plan of action to accomplish a specified end.",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is a computer language (syntax)?",
      "explanation": "The rules for valid format and combinations of instructions is called a computer language, sometimes referred to as its syntax, much the same as English tells you how to spell words and how to create valid sentences using words and punctuation.",
      "type": "MCQ",
      "options": [
        {
          "text": "The arrangement of words and phrases to create well-formed sentences.",
          "correct": false
        },
        {
          "text": "The rules for valid format and combinations of instructions.",
          "correct": true
        },
        {
          "text": "The use of words in a structured and conventional way.",
          "correct": false
        },
        { "text": "A system of communication.", "correct": false }
      ]
    },
    {
      "statement": "What is an expression?",
      "explanation": "Statements are made up of one or more expressions. An expression is any reference to a variable or value, or a set of variable(s) and value(s) combined with operators.",
      "type": "MCQ",
      "options": [
        {
          "text": "The action of making known one's thoughts or feelings.",
          "correct": false
        },
        {
          "text": "Values that are included directly in the source code.",
          "correct": false
        },
        {
          "text": "Any reference to a variable or value OR a set of variable(s) and value(s) combined with operators.",
          "correct": true
        },
        {
          "text": "A statement that performs actions with values and variables.",
          "correct": false
        }
      ]
    },
    {
      "statement": "Interpreting the code is when... ?",
      "explanation": "Statements like a = b \\\\\\* 2 are helpful for developers when reading and writing, but are not actually in a form the computer can directly understand. So a special utility on the computer (either an interpreter or a compiler) is used to translate the code you write into commands a computer can understand. For some computer languages, this translation of commands is typically done from top to bottom, line by line, every time the program is run, which is usually called interpreting the code.",
      "type": "MCQ",
      "options": [
        {
          "text": "Changes to values are tracked as your program runs.",
          "correct": false
        },
        {
          "text": "Actions are performed with values and variables such as assignment and mathematic multiplication.",
          "correct": false
        },
        {
          "text": "The translation of commands is done ahead of time so when the program is executed, what's running is the already translated computer instructions.",
          "correct": false
        },
        {
          "text": "Translation of commands is typically done from top to bottom, line by line, every time the program is run.",
          "correct": true
        }
      ]
    },
    {
      "statement": "Compiling is when... ?",
      "explanation": "It's typically asserted that JavaScript is interpreted, because your JavaScript source code is processed each time it's run. But that's not entirely accurate. The JavaScript engine actually compiles the program on the fly and then immediately runs the compiled code.",
      "type": "MCQ",
      "options": [
        {
          "text": "The translation of commands is done ahead of time so when the program is executed, what's running is the already translated computer instructions.",
          "correct": true
        },
        {
          "text": "Changes to values are tracked as your program runs.",
          "correct": false
        },
        {
          "text": "Actions are performed with values and variables such as assignment and mathematic multiplication.",
          "correct": false
        },
        {
          "text": "Translation of commands is typically done from top to bottom, line by line, every time the program is run.",
          "correct": false
        }
      ]
    },
    {
      "statement": "Which of these next expressions has exactly one literal value, one variable, and one operator?",
      "explanation": "Characters like \\`=\\` and \\`\\*\\` are called operators. They perform actions with the values and variables such as assignment and mathematic multiplication. Variables are like simple boxes you can store any of your stuff in, and should be declared before they are used. In programs, variables hold values to be used by the program. By contrast to variables, literal values are the value itself. For example, \\`4\\` or \\`\"cat\"\\` is a literal value. In other words, it stands alone without being stored in a variable.",
      "type": "MCQ",
      "options": [
        { "text": "\\`var even = 4;\\`", "correct": true },
        {
          "text": "\\`var farm = \"cat\" + \"dog\" + \"cow\";\\`",
          "correct": false
        },
        { "text": "\\`var newCounter = oldCounter + 1;\\`", "correct": false },
        { "text": "\\`var bool = 5 > minimum;\\`", "correct": false }
      ]
    },
    {
      "statement": "Which of these next statements is NOT true about \\`alert()\\` and \\`console.log()\\`? Remember, you can open the console in your browser and experiment.",
      "explanation": "This statement is not true, because the console can display many \\`log()\\` messages simultaneously (unlike the \\`alert()\\` method, which only displays one at a time). This is what makes \\`console.log()\\` a great tool for debugging your code, and for finding out what&#39;s going on under the hood.",
      "type": "MCQ",
      "options": [
        {
          "text": "Using \\`alert()\\` will block your user from interacting with your web page until the alert is closed.",
          "correct": false
        },
        {
          "text": "The user cannot view more than one \\`alert()\\` message at a time.",
          "correct": false
        },
        {
          "text": "The user cannot view more than one \\`console.log()\\` message at a time.",
          "correct": true
        },
        {
          "text": "\\`console.log()\\` statements often have an interactive pointer to the line of code that issued the logged statement.",
          "correct": false
        }
      ]
    },
    {
      "statement": "Which is the correct way to get input from the user?",
      "explanation": "The \\`prompt()\\` method displays a dialog box that prompts the visitor for input. A prompt box is often used if you want the user to input a value before entering a page. The \\`prompt()\\` method returns the input value if the user clicks \"OK\". If the user clicks \"cancel\" the method returns \\`null\\`.",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`var name = console.log(\"What is your name? \");\\`",
          "correct": false
        },
        {
          "text": "\\`var name = alert(\"What is your name? \");\\`",
          "correct": false
        },
        {
          "text": "\\`var name = console.get(\"What is your name? \");\\`",
          "correct": false
        },
        {
          "text": "\\`var name = prompt(\"What is your name? \");\\`",
          "correct": true
        }
      ]
    },
    {
      "statement": "Fill in the blanks: In the expression \\`var num = 20; \\`, the operator \\`=\\` is used to \\_\\_\\_\\_\\_\\_ the literal value \\`20\\` to the \\_\\_\\_\\_\\_\\_\\_ \\`num\\`. The keyword \\`var\\` is used to \\_\\_\\_\\_\\_\\_\\_ the variable.",
      "explanation": "In the expression \\`var num = 20; \\`, the operator \\`=\\` is used to assign the literal value \\`20\\` to the variable \\`num\\`. The keyword \\`var\\` is used to declare the variable.",
      "type": "MCQ",
      "options": [
        { "text": "assign, variable, declare", "correct": true },
        { "text": "assign, variable, increase", "correct": false },
        { "text": "declare, variable, introduce", "correct": false },
        { "text": "introduce, variable, declare", "correct": false }
      ]
    },
    {
      "statement": "Which of these next expressions is NOT a compound assignment?",
      "explanation": "Compound Assignment examples: \\`-=\\`, \\`\\*=\\`, and \\`+=\\` are compound operators that combine a math operation with assignment, as in \\`a += 2\\` (same as \\`a = a + 2\\`). The double equal sign \\`==\\` is used to check equality.",
      "type": "MCQ",
      "options": [
        { "text": "\\`var even \\*= 2; \\`", "correct": false },
        { "text": "\\`var counter += 1; \\`", "correct": false },
        { "text": "\\`var diff -= 2; \\`", "correct": false },
        { "text": "\\`b == a; \\`", "correct": true }
      ]
    },
    {
      "statement": "Which of these next equations will output the boolean value \\`false\\`? Remember, you can open the console in your browser and experiment.",
      "explanation": "When we use the\\`==\\` loose equals operator to make the comparison like \\`\"99.00\" == 99.00\\`, JavaScript will convert the left-hand side \\`\"99.00\"\\` to its number equivalent \\`99.00\\`. The comparison then becomes \\`99.00 == 99.00\\`, which is of course \\`true\\`. This is even true when the negative sign is outside of the double quotes, like so: \\`-\"99\" == -99.00\\`; . However, comparing negative and positive values returns false even when using the loose equals \\`==\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`99 === Number(\"99\"); \\`", "correct": false },
        { "text": "\\`-\"99\" == 99; \\`", "correct": true },
        { "text": "\\`-\"99\" == -99.00; \\`", "correct": false },
        { "text": "\\`99 == \"99.00\"; \\`", "correct": false }
      ]
    },
    {
      "statement": "Which of these next statements is false?",
      "explanation": "JavaScript requires wrapping the conditional in parentheses, otherwise it returns a syntax error. You can test this by running the code \\`if true { console.log(\"this is true!\"); }\\` in your browser console. Remember to also try running the same code with parentheses around the conditional.",
      "type": "MCQ",
      "options": [
        {
          "text": "The if statement requires an expression that can be treated as either \\`true\\` or \\`false\\`.",
          "correct": false
        },
        {
          "text": "You can provide an alternative if the condition is not \\`true\\`, called an else clause.",
          "correct": false
        },
        {
          "text": "JavaScript defines a list of specific values that are considered \"falsy\" (e.g: \\`0\\`, \\`\"\"\\`). Any other value not on the \"falsy\" list is automatically \"truthy\" (e.g: \\`99.99\\`, \\`\"free\"\\`)",
          "correct": false
        },
        {
          "text": "The code: \\`if true { console.log(\"this is true!\"); }\\` is written in valid syntax and will print out the string.",
          "correct": true
        }
      ]
    },
    {
      "statement": "Which of these next statements is NOT an example of how functions improve our code?",
      "explanation": "A function does not have to include a loop in order to save us time and make our code more readable. Some functions only have one line of code, for example console.log() (as shown in the chapter's examples)",
      "type": "MCQ",
      "options": [
        {
          "text": "Functions allow us to split our code into reusable pieces which saves time and energy.",
          "correct": false
        },
        { "text": "Functions make our code more readable.", "correct": false },
        {
          "text": "Each function gets its own scope, which includes a collection of variables as well as the rules for how those variables are accessed. This allows us to be in better control of our variables and prevent bugs.",
          "correct": false
        },
        {
          "text": "All functions use loops (for, while, or do...while), which shorten our code significantly.",
          "correct": true
        }
      ]
    },
    {
      "statement": "Fill in the blank: You need \\_\\_\\_\\_\\_\\_\\_ to perform actions on values.",
      "explanation": "The =, +, /, and \\* characters are examples of operators. They perform actions with the values and variables such as assignment, summation, division and mathematic multiplication.",
      "type": "MCQ",
      "options": [
        { "text": "operators", "correct": true },
        { "text": "values", "correct": false },
        { "text": "types", "correct": false },
        { "text": "variables", "correct": false }
      ]
    },
    {
      "statement": "Fill in the blank: You need \\_\\_\\_\\_\\_\\_\\_ to store data (aka state) during the execution of your program.",
      "explanation": "Variables are like simple boxes you can store any of your stuff in. In programs, variables hold values (like the number 42) to be used by the program. Think of them as symbolic placeholders for the values themselves.",
      "type": "MCQ",
      "options": [
        { "text": "loops", "correct": false },
        { "text": "functions", "correct": false },
        { "text": "variables", "correct": true },
        { "text": "if statements", "correct": false }
      ]
    },
    {
      "statement": "You need \\_\\_\\_\\_\\_\\_\\_ like \\_\\_\\_\\_\\_\\_\\_ to make decisions.",
      "explanation": "Conditionals are just simple \"yes or no\" questions used to make decisions. Does my account have enough balance to purchase this?. The most common conditional is an if statement.",
      "type": "MCQ",
      "options": [
        { "text": "loops, do...while", "correct": false },
        { "text": "functions, scope", "correct": false },
        { "text": "conditionals, if statements", "correct": true },
        { "text": "strings, \"Hello, Worlds\"", "correct": false }
      ]
    },
    {
      "statement": "You need \\_\\_\\_\\_\\_\\_\\_ to repeat tasks until a condition stops being true.",
      "explanation": "Repeating a set of actions until a certain condition fails -- in other words, repeating only while the condition holds -- is the job of programming loops. Loops can take different forms, but they all satisfy this basic behavior.",
      "type": "MCQ",
      "options": [
        { "text": "variables", "correct": false },
        { "text": "loops", "correct": true },
        { "text": "conditionals", "correct": false },
        { "text": "operators", "correct": false }
      ]
    },
    {
      "statement": "You need \\_\\_\\_\\_\\_\\_\\_ to organize your code into logical and reusable chunks.",
      "explanation": "A function is generally a named section of code that can be \"called\" by name, and the code inside it will be run each time. Functions are often used for code that you plan to call multiple times, but they can also be useful just to organize related bits of code into named collections, even if you only plan to call them once.",
      "type": "MCQ",
      "options": [
        { "text": "conditionals", "correct": false },
        { "text": "loops", "correct": false },
        { "text": "functions", "correct": true },
        { "text": "operators", "correct": false }
      ]
    },
    {
      "statement": "Which of the following are ALL built-in types of values?",
      "explanation": "JavaScript has typed values, not typed variables. The following built-in types are available: string, number, boolean, null and undefined, object, symbol (new to ES6)",
      "type": "MCQ",
      "options": [
        { "text": "string, operator, boolean", "correct": false },
        { "text": "object, number, null", "correct": true },
        { "text": "boolean, scope, number", "correct": false },
        { "text": "undefined, string literal, object", "correct": false }
      ]
    },
    {
      "statement": "What is the operator that can be used to find out the type of a value?",
      "explanation": "JavaScript provides a typeof operator that can examine a value and tell you what type it is. The return value from the typeof operator is always one of six (seven as of ES6! - the \"symbol\" type) string values. That is, typeof \"abc\" returns \"string\", not string.",
      "type": "MCQ",
      "options": [
        { "text": "\\`var\\`", "correct": false },
        { "text": "\\`obj\\`", "correct": false },
        { "text": "\\`typeof\\`", "correct": true },
        { "text": "\\`return\\`", "correct": false }
      ]
    },
    {
      "statement": "What is the return value of: \\`typeof null\\`?",
      "explanation": "typeof null is an interesting case, because it errantly returns \"object\", when you&#39;d expect it to return \"null\" (just like \\`typeof undefined\\` returns \\`undefined\\`). You can run this command in your console and see for yourself.",
      "type": "MCQ",
      "options": [
        { "text": "\\`boolean\\`", "correct": false },
        { "text": "\\`object\\`", "correct": true },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`number\\`", "correct": false }
      ]
    },
    {
      "statement": "What is the return value of: \\`typeof \\[1,2,3\\] === typeof {val: 'a', val: 'b', val: 'c'};\\` ?",
      "explanation": "Arrays are special objects, so the typeof of both expressions are objects and the return value is \\`true\\`. Run both expressions in your console to see that the return value of \\`typeof \\[1,2,3\\]\\` and \\`typeof {1, 2, 3}\\` is object.",
      "type": "MCQ",
      "options": [
        { "text": "true", "correct": true },
        { "text": "false", "correct": false },
        { "text": "undefined", "correct": false },
        { "text": "Syntax error", "correct": false }
      ]
    },
    {
      "statement": "In which ways can properties be accessed in an object?",
      "explanation": "Properties can either be accessed with dot notation (i.e., obj.a) or bracket notation (i.e., obj\\[\"a\"\\]). Dot notation is shorter and generally easier to read, and is thus preferred when possible.",
      "type": "MCQ",
      "options": [
        { "text": "with dot notation OR bracket notation", "correct": true },
        {
          "text": "by the values corresponding to the properties",
          "correct": false
        },
        { "text": "with the object's prototype", "correct": false },
        { "text": "the same as in an array", "correct": false }
      ]
    },
    {
      "statement": "What is the main difference between an array and an object?",
      "explanation": "An array is an object that holds values (of any type) not particularly in named properties/keys, but rather in numerically indexed positions. Languages that start counting at zero, like JS does, use 0 as the index of the first element in the array.",
      "type": "MCQ",
      "options": [
        {
          "text": "the maximum length of values they can hold",
          "correct": false
        },
        {
          "text": "positions in arrays begin from 0 and in objects from 1",
          "correct": false
        },
        {
          "text": "arrays hold values with indexed positions instead of key/value pairs",
          "correct": true
        },
        {
          "text": "anything can be stored in objects but only strings and numbers in an array",
          "correct": false
        }
      ]
    },
    {
      "statement": "Which of the following is an array property?",
      "explanation": "Because arrays are special objects (as typeof implies), they can also have properties, including the automatically updated length property.",
      "type": "MCQ",
      "options": [
        { "text": "values", "correct": false },
        { "text": "count", "correct": false },
        { "text": "limit", "correct": false },
        { "text": "length", "correct": true }
      ]
    },
    {
      "statement": "What is the most appropriate use of an object?",
      "explanation": "You theoretically could use an array as a normal object with your own named properties, or you could use an object but only give it numeric properties (0, 1, etc.) similar to an array. However, this would generally be considered improper usage of the respective types. The best and most natural approach is to use arrays for numerically positioned values and use objects for named properties.",
      "type": "MCQ",
      "options": [
        { "text": "to have numeric properties (keys)", "correct": false },
        { "text": "to only store strings", "correct": false },
        {
          "text": "to hold pairs of named properties and values",
          "correct": true
        },
        { "text": "to find out the count of properties", "correct": false }
      ]
    },
    {
      "statement": "What are the types of coercion (conversion from one type to another)?",
      "explanation": "Coercion comes in two forms in JavaScript: explicit and implicit. Explicit coercion is simply that you can see obviously from the code that a conversion from one type to another will occur, whereas implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation.",
      "type": "MCQ",
      "options": [
        { "text": "natural and unnatural", "correct": false },
        { "text": "implicit and explicit", "correct": true },
        { "text": "normal and abnormal", "correct": false },
        { "text": "equal and unequal", "correct": false }
      ]
    },
    {
      "statement": "Which of these next statments is an implicit coercion (conversion from one type to another)?",
      "explanation": "Implicit coercion is when the type conversion can happen as more of a non-obvious side effect of some other operation, such as multiplication by 1 in the second answer.",
      "type": "MCQ",
      "options": [
        { "text": "\\`var b = Number( \"5\" );\\`", "correct": false },
        { "text": "\\`var b = \"5\" \\* 1;\\`", "correct": true },
        { "text": "\\`var b = \"Hello, world\" \\* 1;\\`", "correct": false },
        { "text": "\\`var b = String( 5 );\\`", "correct": false }
      ]
    },
    {
      "statement": "If \\`var a = 42\\` and \\`var b = \"42\"\\`, what will the statements \\`a === b\\` AND \\`a == b\\` return?",
      "explanation": "\\`==\\` checks for value equality with coercion allowed, and \\`===\\` checks for value equality without allowing coercion; \\`===\\` is often called \"strict equality\" for this reason. In the \\`a == b\\` comparison, JS notices that the types do not match, so it goes through an ordered series of steps to coerce one or both values to a different type until the types match, where then a simple value equality can be checked. The \\`a === b\\` produces false, because the coercion is not allowed, so the simple value comparison obviously fails.",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\` / \\`true\\`", "correct": false },
        { "text": "\\`false\\` / \\`true\\`", "correct": true },
        { "text": "\\`true\\` / \\`false\\`", "correct": false },
        { "text": "\\`false\\` / \\`false\\`", "correct": false }
      ]
    },
    {
      "statement": "What happens when you assign a variable that has not yet been declared?",
      "explanation": "If you try to set a variable that hasn't been declared, you'll either end up creating a variable in the top-level global scope (bad!) or getting an error, depending on \"strict mode\" (see \"Strict Mode\").",
      "type": "MCQ",
      "options": [
        {
          "text": "it is automatically declared and hoisted to the top of its scope",
          "correct": false
        },
        {
          "text": "it becomes available only in inner/lower scopes",
          "correct": false
        },
        {
          "text": "it is automatically created in the top-level global scope",
          "correct": true
        },
        { "text": "it makes the code easier to maintain", "correct": false }
      ]
    },
    {
      "statement": "In which of these cases would we probably be safe using == rather than === for comparison?",
      "explanation": "You should avoid using \\`==\\` and use \\`===\\` in these incidents: (1) If either value (aka side) in a comparison could be the \\`true\\` or \\`false\\` value. (2) If either value in a comparison could be of these specific values: \\`0\\`, \\`\"\"\\`, or \\`\\[\\]\\` -- empty array. In all other cases, you&#39;re safe to use \\`==\\`. Not only is it safe, but in many cases it simplifies your code in a way that improves readability.",
      "type": "MCQ",
      "options": [
        {
          "text": "If either value (aka side) in a comparison could be the \\`true\\` or \\`false\\` value.",
          "correct": false
        },
        {
          "text": "If either value in a comparison could be \\`0\\`.",
          "correct": false
        },
        {
          "text": "If either value in a comparison could be \\`undefined\\`.",
          "correct": true
        },
        {
          "text": "If either value in a comparison could be an empty string \\`\"\"\\` or an empty array \\`\\[\\]\\`.",
          "correct": false
        }
      ]
    },
    {
      "statement": "If \\`a === 5\\`, which of the following is a correct use of the ternary operator and returns \\`true\\`?",
      "explanation": "Another form of conditional in JavaScript is the \"conditional operator,\" often called the \"ternary operator. It&#39;s like a more concise form of a single \\`if\\`..\\`else\\` statement. If the test expression evaluates as \\`true\\`, the first clause \\`true\\` results, otherwise the second clause \\`false\\` results.",
      "type": "MCQ",
      "options": [
        { "text": "\\`a < 20 ? true : false\\`", "correct": true },
        { "text": "\\`a < 20 : false ? true\\`", "correct": false },
        { "text": "\\`a < 20 : true : false\\`", "correct": false },
        { "text": "\\`a < 20 ? false : true\\`", "correct": false }
      ]
    },
    {
      "statement": "Which of these next variable names is NOT a valid identifier?",
      "explanation": "An identifier must start with a-z, A-Z, $, or \\_. It can then contain any of those characters plus the numerals 0-9.",
      "type": "MCQ",
      "options": [
        { "text": "\\`var counter;\\`", "correct": false },
        { "text": "\\`var \\_sumOf5;\\`", "correct": false },
        { "text": "\\`var 5thItem;\\`", "correct": true },
        { "text": "\\`var $amount;\\`", "correct": false }
      ]
    },
    {
      "statement": "Which of these next statements is true about scopes?",
      "explanation": "When you declare a variable, it is available anywhere in that scope, as well as any lower/inner scopes. This means that if you declare a function within a function, the outer function is able to access the vairables declared inside it's child function. However, the child/inner function cannot access it's parent/outer function's scope.",
      "type": "MCQ",
      "options": [
        {
          "text": "When you declare a variable, it is only available anywhere in that scope.",
          "correct": false
        },
        {
          "text": "When you declare a variable, it is available anywhere in that scope, as well as any sibling scopes.",
          "correct": false
        },
        {
          "text": "When you declare a variable, it is available anywhere in that scope, as well as any upper/outer scopes.",
          "correct": false
        },
        {
          "text": "When you declare a variable, it is available anywhere in that scope, as well as any lower/inner scopes.",
          "correct": true
        }
      ]
    },
    {
      "statement": "What will happen if you try to access a variable's value in a scope where it's not available?",
      "explanation": "If you try to access a variable's value in a scope where it's not available, you'll get a ReferenceError thrown. The ReferenceError object represents an error when a non-existent variable is referenced. If you try to set a variable that hasn't been declared, you'll either end up creating a variable in the top-level global scope (bad!) or getting an error (depending on \"strict mode\"). You can try this out in your console, and see for yourself.",
      "type": "MCQ",
      "options": [
        { "text": "\\`SyntaxError\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": true },
        { "text": "\\`InternalError\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false }
      ]
    },
    {
      "statement": "Which of these statements is NOT true about strict mode?",
      "explanation": "To invoke strict mode for an entire script, put the exact statement \\`use strict\\`;",
      "type": "MCQ",
      "options": [
        {
          "text": "ES5 added a \"strict mode\" to the language, which is seen as keeping the code to a safer and more appropriate set of guidelines.",
          "correct": false
        },
        {
          "text": "One key difference (improvement!) with strict mode is disallowing the implicit auto-global variable declaration from omitting the \\`var\\`.",
          "correct": false
        },
        {
          "text": "To invoke strict mode for an entire script, put the exact statement \\`use strict mode\\`; (or \\`use strict mode;\\`) before any other statements.",
          "correct": true
        },
        {
          "text": "You can opt in to strict mode for an individual function, or an entire file, depending on where you put the strict mode pragma.",
          "correct": false
        }
      ]
    },
    {
      "statement": "Which of the lines below will print \\`\"Hello!\"\\` to the console when executed?",
      "explanation": "Immediately Invoked Function Expressions (IIFE) is a way to execute a function expression. It requires an outer set of parentheses \\`( .. )\\` that surrounds the function expression. It also requires a final set of parentheses at the end of the expression, which is what actually executes the function expression referenced immediately before it.",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`(function (){ console( \"Hello!\" ); })();\\`",
          "correct": false
        },
        {
          "text": "\\`function (){ console.log( \"Hello!\" ); }();\\`",
          "correct": false
        },
        {
          "text": "\\`function (){ console.log( \"Hello!\" ); }\\`",
          "correct": false
        },
        {
          "text": "\\`(function (){ console.log( \"Hello!\" ); })();\\`",
          "correct": true
        }
      ]
    },
    {
      "statement": "What is Polyfilling?",
      "explanation": "The word \"polyfill\" is an invented term used to refer to taking the definition of a newer feature and producing a piece of code that's equivalent to the behavior, but is able to run in older JS environments. For example, ES6 defines a utility called Number.isNaN(..) to provide an accurate non-buggy check for NaN values, deprecating the original isNaN(..) utility. But it's easy to polyfill that utility so that you can start using it in your code regardless of whether the end user is in an ES6 browser or not.",
      "type": "MCQ",
      "options": [
        {
          "text": "Taking the definition of a newer feature and producing code that offers equivalent behavior, but is able to run in newer JS environments.",
          "correct": false
        },
        {
          "text": "Taking the definition of a newer feature and producing code that offers equivalent behavior, but is able to run in older JS environments.",
          "correct": true
        },
        {
          "text": "A way to \"remember\" and continue to access the scope of a function (its variables) even once the function has finished running.",
          "correct": false
        },
        {
          "text": "A way to \"remember\" and continue to access the scope of a function (its variables) even before the function started running.",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is Transpiling?",
      "explanation": "Transpiling is using a tool that converts your newer code into older code equivalents. The term combines the terms for transforming + compiling. Essentially, your source code is authored in the new syntax form, but what you deploy to the browser is the transpiled code in old syntax form. You typically insert the transpiler into your build process, similar to your code linter or your minifier.",
      "type": "MCQ",
      "options": [
        {
          "text": "A way to define private implementation details (variables, functions), as well as a public API that is accessible from the outside.",
          "correct": false
        },
        {
          "text": "A way to define public implementation details (variables, functions), as well as a private API that is not accessible to the outside.",
          "correct": false
        },
        {
          "text": "Using a tool that converts your older code into newer code equivalents.",
          "correct": false
        },
        {
          "text": "Using a tool that converts your newer code into older code equivalents.",
          "correct": true
        }
      ]
    },
    {
      "statement": "Which of the following expressions is controlled by JavaScript specification?",
      "explanation": "The document variable exists as a global variable when your code is running in a browser. It's not provided by the JS engine, nor is it particularly controlled by the JavaScript specification. Similarly alert(..) and console.log(..) is provided to your JS program by the browser, not by the JS engine itself. The call you make sends the message to the browser internals and it handles drawing, displaying the message box or logging the message to console.",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`var el = document.getElementById( \"foo\" );\\`",
          "correct": false
        },
        { "text": "\\`console.log(\"Hello World!\");\\`", "correct": false },
        { "text": "\\`alert(document.URL);\\`", "correct": false },
        {
          "text": "\\`var a = Object.assign({}, { foo : \"bar\"})\\`",
          "correct": true
        }
      ]
    },
    {
      "statement": "Which is a valid JavaScript type for numerical data?",
      "explanation": "Unlike many coding languages, JavaScript has only one primitve numerical type: \\`number\\`. This is used for both integers and floating point values.",
      "type": "MCQ",
      "options": [
        { "text": "int", "correct": false },
        { "text": "short", "correct": false },
        { "text": "number", "correct": true },
        { "text": "float", "correct": false },
        { "text": "long", "correct": false }
      ]
    },
    {
      "statement": "What is the output of \\`console.log(typeof \\[\\])\\`?",
      "explanation": "In JavaScript, arrays are a type of \\`object\\`. There is no \"array\" type.",
      "type": "MCQ",
      "options": [
        { "text": "undefined", "correct": false },
        { "text": "object", "correct": true },
        { "text": "list", "correct": false },
        { "text": "array", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var a = null; console.log(!a && typeof a === \"object\"); \\`\\`\\`",
      "explanation": "It would have been nice if \\`typeof null\\` returned \"null\", but this original bug in JS has persisted for nearly two decades, and will likely never be fixed because there's too much existing web content that relies on its buggy behavior that \"fixing\" the bug would create more \"bugs\" and break a lot of web software.",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": true },
        { "text": "\\`false\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js function a(b, c) { var d = 5 return d + 1 }; console.log(a.length); \\`\\`\\`",
      "explanation": "The function object has a length property set to the number of formal parameters it is declared with.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`2\\`", "correct": true }
      ]
    },
    {
      "statement": "What is a good way to safely check if a variable has been declared?",
      "explanation": "All of the other options will throw an error if \\`a\\` has not been declared.",
      "type": "MCQ",
      "options": [
        { "text": "\\`if (a)...\\`", "correct": false },
        { "text": "\\`if(typeof a !== \"undefined\")...\\`", "correct": true },
        { "text": "\\`if(a !== undefined)...\\`", "correct": false },
        { "text": "\\`if(a.isDefined())...\\`", "correct": false }
      ]
    },
    {
      "statement": "Once an array is assigned data of a particular type, it can only hold data of that type.",
      "explanation": "In JS, arrays are simple containers that can hold any combination of types, including all primitive types, objects, other arrays, and even functions.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What is the output of \\`console.log(typeof NaN)\\`?",
      "explanation": "An oddity of JavaScript, the property \\`NaN\\` (\"not a number\") is actually of type \"number\".",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"number\"\\`", "correct": true },
        { "text": "\\`NaN\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false }
      ]
    },
    {
      "statement": "What is \\`0.1 + 0.2 === 0.3\\`?",
      "explanation": "The most (in)famous side effect of using binary floating-point numbers (which, remember, is true of all languages that use IEEE 754 -- not just JavaScript as many assume/pretend) is that representations of decimals are not exact.",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": false },
        { "text": "\\`false\\`", "correct": true }
      ]
    },
    {
      "statement": "JavaScript \\`string\\`s are immutable",
      "explanation": "You might have thought of string methods as mutating the original string. However, all of the string methods that alter its contents must create and return new strings.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What is \\`1 / 0\\` in JavaScript?",
      "explanation": "In JS, this operation is well-defined and results in the value Infinity (aka Number.POSITIVE\\_INFINITY).",
      "type": "MCQ",
      "options": [
        { "text": "\\`Infinity\\`", "correct": true },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`1\\`", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console after the following code is executed: \\`\\`\\`js var a = new String( \"abc\" ); console.log(typeof a) \\`\\`\\`",
      "explanation": "The result of the constructor form of value creation \\`(new String(\"abc\"))\\` is an object wrapper around the primitive (\\`\"abc\"\\`) value. Importantly, \\`typeof\\` shows that these objects are not their own special types, but more appropriately they are subtypes of the \\`object\\` type.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"object\"\\`", "correct": true },
        { "text": "\\`\"string\"\\`", "correct": false },
        { "text": "\\`\"function\"\\`", "correct": false },
        { "text": "\\`\"class\"\\`", "correct": false }
      ]
    },
    {
      "statement": "Which native was added in ES6?",
      "explanation": "\\`Symbol()\\` was added in ES6",
      "type": "MCQ",
      "options": [
        { "text": "\\`Symbol()\\`", "correct": true },
        { "text": "\\`RegExp()\\`", "correct": false },
        { "text": "\\`Date()\\`", "correct": false },
        { "text": "\\`Error()\\`", "correct": false }
      ]
    },
    {
      "statement": "What purpose do boxing wrappers serve?",
      "explanation": "Ever wondered why you can call \\`str.length\\` or \\`str.toUpperCase()\\`? Or maybe you just accepted it as fact and didn't think much about it. Primitive types such as \\`string\\` or \\`number\\` get automatically wrapped by boxing wrappers as needed which have methods such as \\`length\\` and \\`toUpperCase\\`.",
      "type": "MCQ",
      "options": [
        {
          "text": "They allow you to call methods on primitives that aren't objects",
          "correct": true
        },
        {
          "text": "They give JavaScript objects all of their functionality",
          "correct": false
        },
        {
          "text": "They are a mechanism for JavaScript engines to improve performance",
          "correct": false
        },
        { "text": "They allow for the use of ES6 classes", "correct": false }
      ]
    },
    {
      "statement": "What is \"boxing\" and \"unboxing\"?",
      "explanation": "Boxing is wrapping a primitive value, and unboxing is extracting the primitive value from a wrapper. Boxing/Unboxing can be done explicitly or implicitly.",
      "type": "MCQ",
      "options": [
        {
          "text": "Boxing is converting from primitive to object wrapper, and unboxing is converting from object wrapper to primitive.",
          "correct": true
        },
        {
          "text": "Boxing is converting from object wrapper to primitive, and unboxing is converting from primitive to object wrapper.",
          "correct": false
        },
        {
          "text": "Boxing is temporarily coercing one primitive type to another, unboxing is coercing it back to its original type",
          "correct": false
        },
        {
          "text": "Boxing is merging of your JavaScript files into one, and unboxing is using source maps to undo the merging",
          "correct": false
        }
      ]
    },
    {
      "statement": "\\`var a = new String( \"abc\" );\\` is more performant than \\`var a = \"abc\";\\`",
      "explanation": "You might think that it would be more performant to use the object wrapper form, so that the engine doesn't have to wrap the primitive. However, engines have been optimizing based on the assumption that almost everyone constructs using primitives, thus they are actually more performant.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "Everyone has more or less agreed that implicit coercion is a good feature in JavaScript",
      "explanation": "There are rules for linters to disallow implicit coercion because it can happen unexpectedly if the developer isn't careful. Implicit coercion is a valuable tool once you fully understand how it works.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js var a = '4'; var b = '2'; console.log(a + b); \\`\\`\\`",
      "explanation": "\\`+\\` means concatenation when any of the operands are strings",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"42\"\\`", "correct": true },
        { "text": "\\`6\\`", "correct": false },
        { "text": "\\`\"6\"\\`", "correct": false },
        { "text": "\\`42\\`", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js var a = {}; if (a) { console.log(a); } \\`\\`\\`",
      "explanation": "There is no such thing as a falsy object in JavaScript",
      "type": "MCQ",
      "options": [
        {
          "text": "Nothing is actually logged to the console",
          "correct": false
        },
        { "text": "\\`{}\\`", "correct": true }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js console.log(40 + 0 + '5') \\`\\`\\`",
      "explanation": "\\`+\\` means concatenation when any of the operands are strings",
      "type": "MCQ",
      "options": [
        { "text": "\\`45\\`", "correct": false },
        { "text": "\\`\"405\"\\`", "correct": true },
        { "text": "\\`\"45\"\\`", "correct": false },
        { "text": "\\`405\\`", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js var a = \\[5,2,6,0,9\\] a.forEach(num => { if (num) { // ...do stuff } else { console.log(num) } }) \\`\\`\\`",
      "explanation": "\\`0\\` is actually falsy which can be unexpected. If you have a list of values and you want to make sure none of them are \\`undefined\\` or \\`null\\` you can't just check if they are truthy.",
      "type": "MCQ",
      "options": [
        { "text": "Nothing is logged to the console", "correct": false },
        { "text": "\\`0\\`", "correct": true },
        { "text": "\\`5\\` \\`2\\` \\`6\\` \\`0\\` \\`9\\`", "correct": false }
      ]
    },
    {
      "statement": "What best describes the code, \\`var a = 3 \\* 6;\\`",
      "explanation": "Statements are to English sentences as expressions are to English phrases",
      "type": "MCQ",
      "options": [
        {
          "text": "It is a statement containing multiple expressions",
          "correct": true
        },
        {
          "text": "It is an expression containing multiple statements",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js var a = 42; var b = a++; console.log(a + b); \\`\\`\\`",
      "explanation": "\\`a++\\` increments \\`a\\` by 1, but the return value of \\`a++\\` is the previous value of \\`a\\`. So when we get to line 3, \\`a\\` has a value of \\`43\\` and \\`b\\` has a value of \\`42\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`85\\`", "correct": true },
        { "text": "\\`84\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`43\\`", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js var obj = { a: { b: \"c\" } } console.log(obj.a && obj.a.b) \\`\\`\\`",
      "explanation": "The \\`&&\\` operator doesn't actually return \\`true\\` if both operands are truthy. It returns the last value. Ever get an error when you try to access \\`a.length\\` when \\`a\\` is undefined? You could instead try \\`a && a.length\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"c\"\\`", "correct": true },
        { "text": "\\`true\\`", "correct": false },
        { "text": "\\`false\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false }
      ]
    },
    {
      "statement": "What is Automatic Semicolon Insertion (ASI) in JavaScript?",
      "explanation": "There are many opinions on whether semicolons should be used in JavaScript. Per the spec, ASI is an error fixing mechanism which suggests that developers should use semicolons.",
      "type": "MCQ",
      "options": [
        {
          "text": "ASI is an \"error correction\" routine that inserts semicolons to fix parser errors",
          "correct": true
        },
        {
          "text": "Mechanism that automatically inserts semicolons in the middle of a line if it notices two statements on one line.",
          "correct": false
        },
        {
          "text": "A deprecated system that used to replace commas with semicolons as needed",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js var a = b = 1; var c = 2; var d = \"\"; if (a === b || a === b && b === c) { d += 'Expression 1 is true. '; } if ((a === b || a === b) && b === c) { d += 'Expression 2 is true.'; } console.log(d); \\`\\`\\`",
      "explanation": "You might expect JavaScript expressions to work left to right with the exception that everything in parentheses gets executed first. That is not the case. You might know that, in math, the \"\\*\" operator executes before \"+\". So, 1 + 1 \\* 5 = 6, not 7. Similarly, in JavaScript, the \\`&&\\` operator executes before \\`||\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"Expression 1 is true. \"\\`", "correct": true },
        { "text": "\\`\"Expression 2 is true.\"\\`", "correct": false },
        {
          "text": "\\`\"Expression 1 is true. Expression 2 is true.\"\\`",
          "correct": false
        },
        { "text": "\\`\"\"\\`", "correct": false }
      ]
    },
    {
      "statement": "When \\`this\\` is used in a function, it refers to that function itself.",
      "explanation": "\\`this\\` can refer to many different elements depending on how the function is called.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "When \\`this\\` is used in a function, it refers to that function's scope.",
      "explanation": "\\`this\\` can refer to many different elements depending on how the function is called.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "Why is \\`this\\` helpful?",
      "explanation": "The more complex your usage pattern is, the more clearly you'll see that passing context around as an explicit parameter is often messier than passing around a \\`this\\` context.",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`this\\` mechanism provides an elegant way of implicitly \"passing along\" an object reference, leading to clean API design and easy re-use.",
          "correct": true
        },
        {
          "text": "It is generally regarded as bad practice and should not be used",
          "correct": false
        },
        {
          "text": "It allows you to do things in JavaScript that you can't do without it",
          "correct": false
        },
        {
          "text": "It helps filter out less experienced JavaScript developers",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is logged to the console in the code below: \\`\\`\\`js function foo() { var a = 2; this.bar(); } function bar() { var a = 1 console.log( this.a ); } foo(); \\`\\`\\`",
      "explanation": "In both uses of the keyword \\`this\\`, it refers to the global object. Because there is no \\`a\\` in the global object, it is undefined.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": true },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`2\\`", "correct": false }
      ]
    },
    {
      "statement": "\\`this\\` is actually a binding that is made when a function is invoked",
      "explanation": "Because \\`this\\` changes depending on HOW the function was called, its value is unknown at the time the function is defined. It is not like lexical scope which is determined at function definition.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "\\_\\_\\_\\_ a function is called matters the most when determining the value of \\`this\\`.",
      "explanation": "While knowing where the function is called is helpful, the most important part is the HOW. Was it called with \\`call\\` or \\`apply\\`? Or with the \\`new\\` keyword? Was it called via an object? Or was it called regularly?",
      "type": "MCQ",
      "options": [
        { "text": "HOW", "correct": true },
        { "text": "WHY", "correct": false },
        { "text": "WHEN", "correct": false },
        { "text": "WHAT", "correct": false }
      ]
    },
    {
      "statement": "What is a \\*\\*call-site\\*\\*?",
      "explanation": "The call-site is simply where a function is called.",
      "type": "MCQ",
      "options": [
        {
          "text": "The location in code where a function is executed",
          "correct": true
        },
        {
          "text": "The location in code where a function is declared",
          "correct": false
        },
        {
          "text": "The location of the server that serves your content",
          "correct": false
        },
        { "text": "The location of your code in memory", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js 'use strict' function foo() { var a = 'pony' console.log( this.a ); } var a = 'rocket ship'; foo(); \\`\\`\\`",
      "explanation": "When not in strict mode, default binding rules are valid which means \\`this\\` would be the global object, and the answer would be 'rocket ship'. However, since we are in strict mode, default binding rules do not apply, so \\`this\\` is undefined. Accessing a property of \\`undefined\\` results TypeError.",
      "type": "MCQ",
      "options": [
        { "text": "undefined", "correct": false },
        { "text": "TypeError", "correct": true },
        { "text": "pony", "correct": false },
        { "text": "rocket ship", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js 'use strict' function printName() { console.log( this.name ); } var person = { name: 'Ralphie', printName: printName }; person.printName(); let name = 'Joanna' \\`\\`\\`",
      "explanation": "\\`person\\` has a key \\`printName\\` with a value of \\`printName\\` which refers to the function \\`printName\\`. When \\`person.printName()\\` is executed, the function reference that is stored in \\`person.printName\\` (\\`printName\\`) is executed within the \\`person\\` context, thus the implicit binding rules say that \\`this\\` is \\`person\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`\"Joanna\"\\`", "correct": false },
        { "text": "\\`\"Ralphie\"\\`", "correct": true }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js var firstName = 'Joanna'; function printFirstName() { console.log(this.firstName); } var person = { firstName: 'Ralphie', printfirstName: printFirstName(), }; \\`\\`\\`",
      "explanation": "This one is a bit tricky. When \\`printFirstName()\\` is executed, the call-site actually does not have a context object because the call-site does not use the \\`person\\` context to reference the function. The default binding rule is therefore used to explain why the \\`this\\` falls back to the global object where there is a \\`var\\` with \\`firstName\\` of \\`\"Joanna\"\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`\"Joanna\"\\`", "correct": true },
        { "text": "\\`\"Ralphie\"\\`", "correct": false }
      ]
    },
    {
      "statement": "What is \\`typeof \\[\\]\\`?",
      "explanation": "Arrays are also a form of objects, with extra behavior. The organization of contents in arrays is slightly more structured than for general objects.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"array\"\\`", "correct": false },
        { "text": "\\`\"object\"\\`", "correct": true },
        { "text": "\\`SyntaxError\\`", "correct": false },
        { "text": "\\`NaN\\`", "correct": false }
      ]
    },
    {
      "statement": "What is \\`typeof function () {}\\`?",
      "explanation": "Functions are technically callable objects, thus they are a type of an object. \\`typeof function () {}\\` will return \"function\".",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"function\"\\`", "correct": true },
        { "text": "\\`\"object\"\\`", "correct": false },
        { "text": "\\`\"array\"\\`", "correct": false },
        { "text": "\\`\"undefined\"\\`", "correct": false }
      ]
    },
    {
      "statement": "What is \\`String\\` in JavaScript?",
      "explanation": "strings in JavaScript are immutable and have no properties/methods. When you run \\`str.length\\` or \\`str.charAt(3)\\`, \\`str\\` is coerced into the object \\`String\\` which has properties \\`length\\` and method \\`charAt\\`.",
      "type": "MCQ",
      "options": [
        { "text": "A class for constructing strings", "correct": false },
        {
          "text": "One of the 5 simple primitive types in JavaScript",
          "correct": false
        },
        {
          "text": "A callable object that has many properties/methods",
          "correct": true
        },
        { "text": "None of the above", "correct": false }
      ]
    },
    {
      "statement": "Where is the value \\`2\\` stored in \\`var obj = {a: 2}\\`?",
      "explanation": "Values in key-value pairs are not actually stored in the object. The object stores the key and a reference to the value. Exactly how/where it is stored is dependent on the engine implementation.",
      "type": "MCQ",
      "options": [
        { "text": "in \\`obj\\`", "correct": false },
        { "text": "in \\`obj.a\\`", "correct": false },
        {
          "text": "somewhere else that depends on the implementation",
          "correct": true
        },
        { "text": "in \\`window\\`", "correct": false }
      ]
    },
    {
      "statement": "In objects, property names are always strings",
      "explanation": "If you use any other value besides a string (primitive) as the property, it will first be converted to a string. This even includes numbers, which are commonly used as array indexes, so be careful not to confuse the use of numbers between objects and arrays.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "JavaScript classes work like Ruby's and Python's dynamic classes and unlike Java's and C++'s static classes.",
      "explanation": "JavaScript ES6 classes are objects, which allows us to add and remove fields and methods at runtime.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "Which of the following is true about classes in JavaScript?",
      "explanation": "By default, inheritance in JavaScript works by linking two classes (objects) together, not by copying one over to another. Class copy behavior can be emulated using the mixin pattern (both explicit and implicit), but this usually leads to ugly and brittle syntax like explicit pseudo-polymorphism (\\`OtherObj.methodName.call(this, ...)\\`), which often results in harder to understand and maintain code.",
      "type": "MCQ",
      "options": [
        {
          "text": "By default, when a child class inherits from a parent class, the child has a copy of the parent's behaviors.",
          "correct": false
        },
        {
          "text": "By default, changing the parent's behaviors does not change the child's behaviors.",
          "correct": false
        },
        {
          "text": "It's not possible to inherit behaviors in JavaScript because classes are an abstraction over objects.",
          "correct": false
        },
        {
          "text": "In a child class, we can store copies of the parent's behaviors if we explicitly program them in.",
          "correct": true
        }
      ]
    },
    {
      "statement": "JavaScript does not provide a native mechanism for \"multiple inheritance\".",
      "explanation": "Multiple-inheritance means that each parent class contributes definitions to the child class. JavaScript does not provide a native mechanism for \"multiple inheritance\". Many see this is a good thing, because the complexity savings more than make up for the \"reduced\" functionality. But this doesn't stop developers from trying to fake it in various ways.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What is the main difference between an explicit mixin and an implicit mixin?",
      "explanation": "Implicit mixin is when there isn't an explicit mixin function that copies all of the properties from the parent to the child. Rather, it is when the parent method is called with the \\`this\\` bound to the child's \\`this\\`",
      "type": "MCQ",
      "options": [
        {
          "text": "Explicit mixins are native to JavaScript while implicit mixins are not.",
          "correct": false
        },
        {
          "text": "Explicit mixin is when the properties of the parent are copied over to the child.",
          "correct": true
        },
        { "text": "Explicit mixins are recommended.", "correct": false },
        {
          "text": "Explicit mixins are not native to Javascript while implicit mixins are.",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is a similarity between explicit and implicit mixins?",
      "explanation": "Implicit mixins always require absolutely referring to the parent, and explicit mixins require absolutely referring to the parent when shadowing is desired.",
      "type": "MCQ",
      "options": [
        { "text": "They are both native to JavaScript", "correct": false },
        { "text": "They are both recommended", "correct": false },
        {
          "text": "With either, you cannot always avoid absolutely (as opposed to relatively) referring to the parent",
          "correct": true
        },
        { "text": "None of the above", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js 'use strict' var anotherObject = { a: 2 }; var myObject = Object.create( anotherObject ); var a = 3; console.log(myObject.a); \\`\\`\\`",
      "explanation": "\\`var myObject = Object.create( anotherObject );\\` links \\`myObject\\` with \\`anotherObject\\` via the prototype chain. If a key does not exist in \\`myObject\\`, it follows its prototype chain and looks for the key in \\`anotherObject\\`.",
      "type": "MCQ",
      "options": [
        { "text": "undefined", "correct": false },
        { "text": "null", "correct": false },
        { "text": "2", "correct": true },
        { "text": "3", "correct": false }
      ]
    },
    {
      "statement": "A \\`for..in\\` loop only iterates over the specified object",
      "explanation": "It also iterates over all enumerable properties in its prototype chain.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js var anotherObject = { a: 2 }; var myObject = Object.create( anotherObject ); myObject.a++; console.log(anotherObject.a, myObject.a) \\`\\`\\`",
      "explanation": "Though it may appear that \\`myObject.a++\\` should (via delegation) look-up and just increment the \\`anotherObject.a\\` property itself in place, instead the \\`++\\` operation corresponds to \\`myObject.a = myObject.a + 1\\`. The result is \\`\\[\\[Get\\]\\]\\` looking up a property via \\`\\[\\[Prototype\\]\\]\\` to get the current value \\`2\\` from \\`anotherObject.a\\`, incrementing the value by one, then \\`\\[\\[Put\\]\\]\\` assigning the \\`3\\` value to a new shadowed property \\`a\\` on \\`myObject\\`.",
      "type": "MCQ",
      "options": [
        { "text": "3 2", "correct": false },
        { "text": "3 3", "correct": false },
        { "text": "2 3", "correct": true },
        { "text": "2 2", "correct": false }
      ]
    },
    {
      "statement": "It is better to think about object oriented programming in JavaScript as Object Links than Classes",
      "explanation": "JavaScript simply does not have classes. ES6 classes are syntactic sugar on top of what are simply just objects.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var Dog = { speak: function () { console.log(\"Bark\"); }, sleep: function () { console.log('sleeping...') } }; var Cat = Object.create(Dog); Cat.speak = function () { console.log(\"Meow\") }; Cat.speak() Cat.sleep() \\`\\`\\`",
      "explanation": "\\`Cat\\` has a property \\`speak\\`, but it does not have a property \\`sleep\\`. Because \\`Cat\\` was linked to \\`Dog\\` via \\`Object.create()\\`, and \\`Dog\\` has a property \\`sleep\\`, \\`Dog\\`s \\`sleep\\` property was called.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\` \\`ReferenceError\\`", "correct": false },
        { "text": "\\`\"Meow\"\\` \\`\"sleeping...\"\\`", "correct": true },
        { "text": "\\`\"Bark\"\\` \\`\"sleeping...\"\\`", "correct": false },
        { "text": "\\`\"Meow\"\\` \\`ReferenceError\\`", "correct": false }
      ]
    },
    {
      "statement": "What is the main fundamental concept of Delegation-Oriented Design in comparison to the traditional Object-Oriented Design?",
      "explanation": "Fundamentally, the prototype chain does not have a concept of \"copying\" or \"parent creating child\". All it does is chain objects together.",
      "type": "MCQ",
      "options": [
        {
          "text": "There is no idea of parent and child, just object linkages",
          "correct": true
        },
        {
          "text": "Delegation-Oriented Design involves explicit and implicit mixins",
          "correct": false
        },
        {
          "text": "It bridges the gap with the help of ES6 classes",
          "correct": false
        },
        { "text": "Functions are delegated as objects", "correct": false }
      ]
    },
    {
      "statement": "In OLOO design, shadowing is a helpful tool used to make API design more robust",
      "explanation": "Having name collisions creates awkward/brittle syntax to disambiguate references (see Chapter 4), and we want to avoid that if we can.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "In general, with \\`\\[\\[Prototype\\]\\]\\` delegation involved, you want state to be on the delegators, not on the delegate",
      "explanation": "In OOD, it is easy to relatively access the state of the parent. In OLOO, this is not the case. There is no easy way to specifically access state relatively, so it makes sense to hold state on the delegators.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "If you make B linked to A, and then try to link A to B, you will get an error.",
      "explanation": "You cannot create a cycle where two or more objects are mutually delegated (bi-directionally) to each other.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "Which statement below best describes why OLOO is a better mental model than OOD in JavaScript",
      "explanation": "With OLOO there are just objects linked to each other, without needing all the cruft and confusion of things that look (but don't behave!) like classes, with constructors and prototypes and \\`new\\` calls. Ask yourself: if I can get the same functionality with OLOO style code as I do with \"class\" style code, but OLOO is simpler and has less things to think about, isn't OLOO better?",
      "type": "MCQ",
      "options": [
        {
          "text": "There are no real classes in JavaScript, so true OOD is not possible. The language naturally lends itself to OLOO given its focus on objects.",
          "correct": true
        },
        {
          "text": "OLOO is a cleaner design than OOD in general",
          "correct": false
        },
        { "text": "ES6 is not supported by all browsers", "correct": false },
        {
          "text": "It's not a better mental model because OOD and OLOO are the same thing",
          "correct": false
        }
      ]
    },
    {
      "statement": "What gives a program state?",
      "explanation": "A program is described as stateful if it is designed to remember preceding events or user interactions. The remembered information is called the state. Without state, a program could perform some tasks, but they would be extremely limited in functionality.",
      "type": "MCQ",
      "options": [
        { "text": "The ability for a program to execute", "correct": false },
        {
          "text": "The ability for a program to be compiled",
          "correct": false
        },
        {
          "text": "The ability to store values and pull values out of variables",
          "correct": true
        },
        {
          "text": "The process of creating an Abstract Syntax Tree",
          "correct": false
        }
      ]
    },
    {
      "statement": "In a traditional compiled-language process, what is the correct order of the three main steps a program will undergo before executing?",
      "explanation": "Tokenizing/Lexing is the process of breaking up a string of characters into meaningful chunks called tokens. Parsing is the act of taking a stream of tokens and turning it into a tree of nested elements which represent the structure of the program. Code-Generation is the process of taking the tree and turning it into executable code.",
      "type": "MCQ",
      "options": [
        {
          "text": "Tokenizing/Lexing, Parsing, Code-Generation",
          "correct": true
        },
        {
          "text": "Tokenizing/Lexing, Code-Generation, Parsing",
          "correct": false
        },
        {
          "text": "Parsing, Code-Generation, Tokenzing/Lexing",
          "correct": false
        },
        {
          "text": "Code-Generation, Tokenzing/Lexing, Parsing",
          "correct": false
        }
      ]
    },
    {
      "statement": "In a traditional compiled-language process, during which phase is a string of characters broken into meaningful chunks?",
      "explanation": "E. A string of characters is broken into meaningful chuncks during the tokenization/lexing phase. A token is a string with an assigned meaning. It is structured as a pair consisting of a token name and optional token value. Some common token names include: Identifiers, Keywords, Separators, operators, and literals.",
      "type": "MCQ",
      "options": [
        { "text": "Code-generation phase", "correct": false },
        { "text": "Parsing phase", "correct": false },
        { "text": "Execution phase", "correct": false },
        { "text": "Tokenizing/Lexing phase", "correct": true }
      ]
    },
    {
      "statement": "Which of the following is the responsibility of Scope?",
      "explanation": "The Scope is responsible for maintaing a look-up list of all declared identifiers and enforcing a strict set of rules as to how these are accessible to currently executing code.",
      "type": "MCQ",
      "options": [
        { "text": "Parsing and code-generation", "correct": false },
        {
          "text": "Collecting and maintaining a look-up list of all declared variables",
          "correct": true
        },
        {
          "text": "Start-to-Finish compilation and execution of the javaScript prgoram",
          "correct": false
        },
        {
          "text": "Taking a stream of tokens and turning it into a tree of nested elements",
          "correct": false
        }
      ]
    },
    {
      "statement": "Two distinct actions are taken for a variable assignment such as \\`var a = 2; \\`",
      "explanation": "Two distinct actions are taken for a variable assignment: First, Compiler declares a variable (if not previously declared in the current scope), and second, when executing, Engine looks up the variable in Scope and assigns to it, if found.",
      "type": "MCQ",
      "options": [
        {
          "text": "Compiler declares a variable (if not previously declared) while simultaneously Engine looks up the variable in Scope and assigns to it, if found.",
          "correct": false
        },
        {
          "text": "Compiler declares a variable regardless of whether or not it was previously declared, while simultaneously Engine looks up the variable in Scope and assigns to it.",
          "correct": false
        },
        {
          "text": "First, Compiler declares a variable (if not previously declared in the current scope), and second, when executing, Engine looks up the variable in Scope and assigns to it, if found.",
          "correct": true
        },
        {
          "text": "First, Engine declares a variable (if not previously declared in the current scope), and second, when executing, Compiler looks up the variable in Scope and assigns to it, if found.",
          "correct": false
        }
      ]
    },
    {
      "statement": "Which of the statements below are true?",
      "explanation": "The reference to \\`a\\` in \\`console.log( a );\\` is an RHS reference, because nothing is being assigned to \\`a\\` here. By contrast, in \\`a = 2;\\` the reference to \\`a\\` is an LHS reference, because we don&#39;t actually care what the current value is. We simply want to find the variable as \\`a\\` target for the \\`= 2\\` assignment operation.",
      "type": "MCQ",
      "options": [
        {
          "text": "LHS and RHS meaning \"left/right-hand side of an assignment\" always literally mean \"left/right side of the \\`=\\` assignment operator\"",
          "correct": false
        },
        {
          "text": "The reference to \\`a\\` in the statements \\`console.log( a );\\` and in \\`a = 2; \\` is a LHS statement.",
          "correct": false
        },
        {
          "text": "In \\`console.log( a );\\` the reference to \\`a\\` is an LHS reference, while in \\`a = 2; \\` the reference to \\`a\\` is an RHS statement.",
          "correct": false
        },
        {
          "text": "In \\`console.log( a );\\` the reference to \\`a\\` is an RHS reference, while in \\`a = 2; \\` the reference to \\`a\\` is an LHS statement.",
          "correct": true
        }
      ]
    },
    {
      "statement": "Which of these next statements is true for traversing nested Scope?",
      "explanation": "Engine starts at the currently executing Scope, looks for the variable there, then if not found, keeps going up one level, and so on. If the outermost global scope is reached, the search stops, whether it finds the variable or not.",
      "type": "MCQ",
      "options": [
        {
          "text": "Engine starts looking for a variable at the outermost global scope.",
          "correct": false
        },
        {
          "text": "Engine starts looking for a variable at the innermost global scope.",
          "correct": false
        },
        {
          "text": "If the variable was not found at the currently executing Scope, Engine keeps going down one level, and so on.",
          "correct": false
        },
        {
          "text": "Engine starts looking for the variable at the currently executing Scope.",
          "correct": true
        }
      ]
    },
    {
      "statement": "Why does it matter whether we call it LHS or RHS?",
      "explanation": "The names matter because these two types of look-ups behave differently in the circumstance where the variable has not yet been declared (is not found in any consulted Scope). If an RHS look-up fails to ever find a variable, this results in a \\`ReferenceError\\` being thrown by the Engine. By contrast, if the Engine is performing an LHS look-up and arrives at the top floor (global Scope) without finding it, and if the program is not running in \"Strict Mode\", then the global Scope will create a new variable of that name in the global scope.",
      "type": "MCQ",
      "options": [
        {
          "text": "Because these two types of look-ups behave differently when the variable has been declared and assigned the value \\`undefined\\`.",
          "correct": false
        },
        {
          "text": "Because these two types of look-ups behave differently when the variable has been declared on global Scope vs. the currently executing Scope.",
          "correct": false
        },
        {
          "text": "Because these two types of look-ups behave differently when the variable has not yet been declared (is not found in any consulted Scope).",
          "correct": true
        },
        {
          "text": "If an LHS look-up fails to ever find a variable, anywhere in the nested Scopes, this results in a \\`ReferenceError\\` being thrown by the Engine.",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is Parsing?",
      "explanation": "Parsing is typically thought of as taking a string of text and making sense of it. However, the string of text is actually converted into tokens first. Parsing is actually taking the tokens and making them useful by converting them into an abstract syntax tree",
      "type": "MCQ",
      "options": [
        {
          "text": "Taking a string and converting it into tokens",
          "correct": false
        },
        {
          "text": "Taking a stream of tokens and converting them into an abstract syntax tree",
          "correct": true
        },
        {
          "text": "Taking an abstract syntax tree and converting it into zeroes and ones",
          "correct": false
        },
        {
          "text": "Taking a string and converting it into assembly",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is the responsibility of a JavaScript engine?",
      "explanation": "The engine is the entirety of what reads and executes your code. Each browser has their own engine as does Node (built on Chrome's V8 JavaScript engine).",
      "type": "MCQ",
      "options": [
        {
          "text": "Handling all the dirty work of parsing and code-generation",
          "correct": false
        },
        {
          "text": "Writing JavaScript code that is missing from the file",
          "correct": false
        },
        {
          "text": "Start-to-finish compilation and execution of our JavaScript program",
          "correct": true
        },
        {
          "text": "Find all unused code and remove it before code generation",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is the difference between an LHS lookup and an RHS lookup?",
      "explanation": "LHS stands for \"left hand side\", and RHS stands for \"right hand side\". For a = b, the RHS looks for the value of b, and the LHS looks for the location of a in memory, so that it can update its value.",
      "type": "MCQ",
      "options": [
        {
          "text": "LHS lookups search for variables whereas RHS search for values",
          "correct": false
        },
        {
          "text": "LHS looks for assignment operator whereas RHS looks for the value to be assigned",
          "correct": false
        },
        {
          "text": "LHS looks for the existence of a variable whereas RHS looks for the history of that variable",
          "correct": false
        },
        {
          "text": "LHS looks for the variable container whereas RHS looks for the value of the variable",
          "correct": true
        }
      ]
    },
    {
      "statement": "How many LHS look-ups are in the code below: \\`\\`\\`js function foo(a){ var b = a; return a + b } var c = foo( 2 ); \\`\\`\\`",
      "explanation": "\\`c = ..\\`, \\`a = 2\\` (implicit param assignment) and \\`b = ..\\`",
      "type": "MCQ",
      "options": [
        { "text": "1", "correct": false },
        { "text": "2", "correct": false },
        { "text": "3", "correct": true },
        { "text": "4", "correct": false }
      ]
    },
    {
      "statement": "How many RHS look-ups are in the code below: \\`\\`\\`js function foo(a){ var b = a; return a + b } var c = foo( 2 ); \\`\\`\\`",
      "explanation": "\\`foo(2..\\`, \\`= a;\\`, \\`a + ..\\` and \\`.. + b\\`",
      "type": "MCQ",
      "options": [
        { "text": "1", "correct": false },
        { "text": "2", "correct": false },
        { "text": "3", "correct": false },
        { "text": "4", "correct": true }
      ]
    },
    {
      "statement": "If an RHS look-up fails to find a variable, what kind of error is thrown?",
      "explanation": "A ReferenceError is thrown when trying to dereference a variable that has not been declared. The only way for an RHS look-up to fail is if the variable has not been declared.",
      "type": "MCQ",
      "options": [
        { "text": "\\`SyntaxError\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": true },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`EvalError\\`", "correct": false }
      ]
    },
    {
      "statement": "When is scoping determined in JavaScript?",
      "explanation": "In JavaScript, scoping is lexical. It is based on where variables and blocks of scope are authored, by you, at write time, and thus is (mostly) set in stone by the time the lexer processes your code.",
      "type": "MCQ",
      "options": [
        { "text": "At author-time", "correct": true },
        { "text": "At run-time", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js function foo(a) { var b = a \\* 2; function bar(c) { console.log( a, b, c ); } bar(b \\* 3); } foo( 2 ); \\`\\`\\`",
      "explanation": "\\`c\\` is scoped to \\`bar\\`, \\`a\\` and \\`b\\` are scoped to \\`foo\\`. \\`bar\\` looks for \\`a\\` and \\`b\\` in its local scope, but can't find it, so checks its outer scope, \\`foo\\`, where it finds variables \\`a\\` and \\`b\\`. \\`bar\\` looks for \\`c\\` in its local scope, and finds it.",
      "type": "MCQ",
      "options": [
        { "text": "\\`2 4 12\\`", "correct": true },
        { "text": "\\`undefined undefined undefined\\`", "correct": false },
        { "text": "\\`2 4 undefined\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js function foo() { const a = 2 function bar() { console.log(a); } bar(); } const a = 1 foo(); \\`\\`\\`",
      "explanation": "\\`a\\` is scoped to \\`foo\\`. \\`bar\\` looks for \\`a\\` in its local scope, but can't find it, so checks its outer scope, \\`foo\\`, where it finds \\`a\\` with a value of 2.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`2\\`", "correct": true }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js function bar(b) { console.log(a); } function foo() { const a = 5 bar(10); } foo(); \\`\\`\\`",
      "explanation": "\\`bar\\` does not have \\`a\\` in its scope, so the engine looks in its outer scope, the global scope. It does not see an \\`a\\`, so it throws a \\`ReferenceError\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": true },
        { "text": "\\`5\\`", "correct": false },
        { "text": "\\`10\\`", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js let a; function bar(b) { console.log(a); } function foo() { const a = 7 bar(9); } foo(); \\`\\`\\`",
      "explanation": "\\`bar\\` does not have \\`a\\` in its scope, so the engine looks in its outer scope, the global scope. It sees \\`a\\`, but notices that there is no value assigned to it, thus it is \\`undefined\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": true },
        { "text": "\\`ReferenceError\\`", "correct": false },
        { "text": "\\`7\\`", "correct": false },
        { "text": "\\`9\\`", "correct": false }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed and the user clicks the button: \\`\\`\\`js const button = document.querySelector('button'); function bar() { const b = 1 console.log(b) button.addEventListener('click', bar) } \\`\\`\\`",
      "explanation": "\\`bar\\` never gets called, so \\`console.log(b)\\` is never executed.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`1\\`", "correct": false },
        { "text": "nothing is logged to the console", "correct": true }
      ]
    },
    {
      "statement": "What is logged to the console when the following code is executed: \\`\\`\\`js function bar(b) { function baz(a) { console.log(a) } const a = 7 } function foo(a) { a = 5; baz(a) } foo(4); \\`\\`\\`",
      "explanation": "We first call \\`foo\\` with a value of 4. Inside \\`foo\\`, \\`a\\`'s value is changed from 4 to 5. We then try to call \\`baz\\`. \\`baz\\` is not in \\`foo\\`'s scope, so the engine looks at the outer scope, the global scope. It does not find \\`baz\\`, so it throws a \\`ReferenceError\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": true },
        { "text": "\\`5\\`", "correct": false },
        { "text": "\\`7\\`", "correct": false }
      ]
    },
    {
      "statement": "Which two mechanisms in JavaScript can \"cheat\" lexical scope?",
      "explanation": "\\`with\\` and \\`eval\\` are the only mechanisms that allow code to be executed dynamically which means they can \"cheat\" lexical scope.",
      "type": "MCQ",
      "options": [
        { "text": "\\`eval\\` and \\`with\\`", "correct": true },
        { "text": "\\`eval\\` and \\`innerHTML\\`", "correct": false },
        { "text": "\\`this\\` and \\`with\\`", "correct": false },
        { "text": "\\`this\\` and \\`eval\\`", "correct": false }
      ]
    },
    {
      "statement": "There are two mechanisms in JavaScript that can \"cheat\" lexical scope. Why should they not be used?",
      "explanation": "If the Engine finds an \\`eval(..)\\` or \\`with\\` in the code, it essentially has to assume that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to \\`eval(..)\\` to modify the lexical scope, or the contents of the object you may pass to \\`with\\` to create a new lexical scope to be consulted.",
      "type": "MCQ",
      "options": [
        { "text": "There is no reason to not use them", "correct": false },
        {
          "text": "They prevent the engine from using some or all of its optimizations",
          "correct": true
        },
        { "text": "They are not readable", "correct": false },
        { "text": "They are not implemented in all browsers", "correct": false }
      ]
    },
    {
      "statement": "What is going on under the hood when importing modules to prevent collisions?",
      "explanation": "IIFEs are used to \"insert\" code without collisions. The IIFE gives each module its own scope which allows it to use whatever non-global variables it wants without side effects.",
      "type": "MCQ",
      "options": [
        { "text": "They are each wrapped in an IIFE", "correct": true },
        { "text": "The code is injected and inserted as is", "correct": false },
        { "text": "They use global namespaces", "correct": false },
        { "text": "ES6 classes", "correct": false }
      ]
    },
    {
      "statement": "What is the main reason you should name your functions?",
      "explanation": "If you are debugging an error, you might check the stack trace. If you encounter an anonymous function in the stack trace, you can't easily know which function it is referring to.",
      "type": "MCQ",
      "options": [
        {
          "text": "You have to name all functions, so this is a moot point",
          "correct": false
        },
        { "text": "Easier debugging", "correct": true },
        {
          "text": "You don't actually want to name your functions if possible because then you can't use IIFEs",
          "correct": false
        },
        { "text": "Browser optimization", "correct": false }
      ]
    },
    {
      "statement": "JavaScript did not have a concept of block scoping before ES6",
      "explanation": "Technically, it had block scoping in \\`catch\\` blocks as early as ES3. Standard block scoping was introduced in ES6 via \\`let\\` and \\`const\\`.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What will be logged to the console upon execution of the code below: \\`\\`\\`js {let i = 0} console.log(i) \\`\\`\\`",
      "explanation": "Because \\`let\\` is block scoped, \\`i\\` is only within scope inside the curly braces in the first line, not in the global scope.",
      "type": "MCQ",
      "options": [
        { "text": "\\`0\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": true }
      ]
    },
    {
      "statement": "What will be logged to the console upon execution of the code below: \\`\\`\\`js {var i = 0} console.log(i) \\`\\`\\`",
      "explanation": "Because \\`var\\` is not block scoped, \\`i\\` is stored in the global scope.",
      "type": "MCQ",
      "options": [
        { "text": "\\`0\\`", "correct": true },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console upon execution of the code below: \\`\\`\\`js a = 3 var a; console.log(a) \\`\\`\\`",
      "explanation": "\\`var a\\` is \"hoisted\" before the other lines of code are executed, thus by the time the engine executes the assignment and console logging, \\`var a\\` will have been declared and available.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`3\\`", "correct": true },
        { "text": "\\`a\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console upon execution of the code below: \\`\\`\\`js console.log(a) var a = 3; \\`\\`\\`",
      "explanation": "\\`var a\\` is \"hoisted\" before the other lines of code are executed. By the time the engine executes the \\`console.log\\`, \\`var a\\` will have been declared, but the definition will not have occurred.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": true },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`3\\`", "correct": false },
        { "text": "\\`a\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console upon execution of the code below: \\`\\`\\`js foo(); var foo = function() { console.log('hello') }; \\`\\`\\`",
      "explanation": "\\`var foo\\` is \"hoisted\" but the function is not. By the time the engine executes the first line, \\`var foo\\` will have been declared, so it is not a \\`ReferenceError\\`. We try to call it as a function, but its value is undefined which leaves us with a \\`TypeError\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`'hello'\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": true },
        { "text": "\\`undefined\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console upon execution of the code below: \\`\\`\\`js foo(); var foo; function foo() { console.log( 1 ); } foo = function() { console.log( 2 ); }; \\`\\`\\`",
      "explanation": "Because functions are \"hoisted\" before variables, \\`function foo\\` gets hoisted before \\`var foo\\`, and ultimately \\`var foo\\` is ignored.",
      "type": "MCQ",
      "options": [
        { "text": "\\`1\\`", "correct": true },
        { "text": "\\`2\\`", "correct": false },
        { "text": "\\`1\\` and then \\`2\\`", "correct": false },
        { "text": "\\`2\\` and then \\`1\\`", "correct": false }
      ]
    },
    {
      "statement": "Declarations themselves are hoisted, but assignments, even assignments of function expressions, are not hoisted.",
      "explanation": "The compiler does a first pass through your code to determine lexical scope. This is what is known as \"hoisting\".",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What is closure?",
      "explanation": "Another way to explain closure is to say that functions always have access to their lexical scope, no matter how or when they are called.",
      "type": "MCQ",
      "options": [
        {
          "text": "The ability of a function to access its lexical scope when that function is executing outside its lexical scope.",
          "correct": true
        },
        { "text": "When a function is used as a callback", "correct": false },
        {
          "text": "When a function is nested within another function",
          "correct": false
        },
        {
          "text": "When a function returns another function, it is said to have a closure over the second function",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is logged to the console after executing the code below: \\`\\`\\`js var a = 1 function foo() { var a = 2; function bar() { console.log( a ); } return bar; } var baz = foo(); baz(); \\`\\`\\`",
      "explanation": "\\`foo\\` returns the function \\`bar\\` which is assigned to \\`baz\\`. \\`bar\\` still has access to a in \\`foo\\` even after \\`foo\\` has been called because of closure.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false },
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`2\\`", "correct": true }
      ]
    },
    {
      "statement": "When is closure observed?",
      "explanation": "Because closure is just a function accessing lexical scope when it's executed outside of its lexical scope, that can only happen if the function is passed around as a variable",
      "type": "MCQ",
      "options": [
        {
          "text": "When functions are passed around as variables and then executed",
          "correct": true
        },
        { "text": "When \\`this\\` is used in a function", "correct": false },
        { "text": "When shadowing occurs", "correct": false },
        { "text": "When arrow functions are executed", "correct": false }
      ]
    },
    {
      "statement": "Is closure observed when the code below is executed: \\`\\`\\` function wait(message) { setTimeout( function timer(){ console.log( message ); }, 1000 ); } wait( \"Hello!\" ); \\`\\`\\`",
      "explanation": "\\`wait\\` gets executed immediately, but \\`timer\\` executes every 1000ms, and it still can access \\`message\\`.",
      "type": "MCQ",
      "options": [
        { "text": "Yes", "correct": true },
        { "text": "No", "correct": false }
      ]
    },
    {
      "statement": "What happens when this code is executed: \\`\\`\\` for (var i=1; i<=5; i++) { setTimeout( function timer(){ console.log( i ); }, i\\*1000 ); } \\`\\`\\`",
      "explanation": "\\`setTimeout\\` is executed immediately which means the \\`i\\` in \\`i\\*1000\\` is what you would expect. However, \\`timer\\` does not get executed immediately. By the time \\`timer\\` is executed, the loop is finished, and \\`i\\` has a value of 6.",
      "type": "MCQ",
      "options": [
        { "text": "6 is printed 5 times all at 6 seconds", "correct": false },
        {
          "text": "6 is printed 5 times at one second intervals",
          "correct": true
        },
        {
          "text": "1, 2, 3, 4, 5 are printed all at 6 seconds",
          "correct": false
        },
        {
          "text": "1, 2, 3, 4, 5 are printed each at one second intervals",
          "correct": false
        }
      ]
    },
    {
      "statement": "Transpiling is transforming your ES6+ code into equivalent code that works in ES5 environments.",
      "explanation": "The idea behind a technique called transpiling (transformation + compiling) is to use a special tool to transform your ES6 code into equivalent (or close!) matches that work in ES5 environments.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What are polyfills?",
      "explanation": "Transpiling with polyfills allows you to develop using the latest JavaScript APIs without worrying about breaking your app in certain browsers.",
      "type": "MCQ",
      "options": [
        {
          "text": "A pattern for defining equivalent behavior from a newer environment into an older environment, when possible.",
          "correct": true
        },
        {
          "text": "3rd party libraries you use in your code base",
          "correct": false
        },
        { "text": "Objects that contain multiple functions", "correct": false },
        {
          "text": "A new feature of ES6 that provides syntactic sugar on top of functions",
          "correct": false
        }
      ]
    },
    {
      "statement": "In general, new APIs cannot be polyfilled, but syntax often can be.",
      "explanation": "Not all new ES6 features need a transpiler. Polyfills (aka shims) are a pattern for defining equivalent behavior from a newer environment into an older environment, when possible. Syntax cannot be polyfilled, but APIs often can be.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "It is invalid in JS to create a standalone block statement like the following: \\`\\`\\`js { let a = 3; console.log( a ); } \\`\\`\\`",
      "explanation": "It's not very common or idiomatic thus far in JS to use a standalone \\`{ .. }\\` block, but it's always been valid",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js { console.log( a ); console.log( b ); var a; let b; } \\`\\`\\`",
      "explanation": "Accessing a let-declared variable earlier than its \\`let\\` .. declaration/initialization causes an error, whereas with \\`var\\` declarations the ordering doesn’t matter",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`ReferenceError\\` / \\`ReferenceError\\`",
          "correct": false
        },
        { "text": "\\`undefined\\` / \\`undefined\\`", "correct": false },
        { "text": "\\`ReferenceError\\` / \\`undefined\\`", "correct": false },
        { "text": "\\`undefined\\` / \\`ReferenceError\\`", "correct": true }
      ]
    },
    {
      "statement": "What will be logged to the console when the following is executed? \\`\\`\\`js let nums = \\[\\] for (let i = 1; i < 6; i++) { nums.push(function() {console.log(i)}); } nums.forEach(fn => fn()); \\`\\`\\`",
      "explanation": "The \\`let i\\` in the for header declares an \\`i\\` not just for the for loop itself, but it redeclares a new \\`i\\` for each iteration of the loop. That means that closures created inside the loop iteration close over those per-iteration variables the way you'd expect. If you tried that same snippet but with \\`var i\\` in the for loop header, you'd get \\`6,6,6,6,6\\` instead.",
      "type": "MCQ",
      "options": [
        { "text": "\\`1,2,3,4,5\\`", "correct": true },
        { "text": "\\`5,5,5,5,5\\`", "correct": false },
        { "text": "\\`6,6,6,6,6\\`", "correct": false },
        { "text": "\\`1,1,1,1,1\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following is executed? \\`\\`\\`js let a = \\[2,3,4\\]; let b = \\[ 1, ...a, 5 \\]; console.log(b); \\`\\`\\`",
      "explanation": "When \\`...\\` is used in front of an array, it acts to “spread” it out into its individual values.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\\[1, null, 5\\]\\`", "correct": false },
        { "text": "\\`\\[1, undefined, 5\\]\\`", "correct": false },
        { "text": "\\`\\[1, 2, 3, 4, 5\\]\\`", "correct": true },
        { "text": "\\`\\[1, \\[2, 3, 4\\], 5\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "What will the value of parameter \\`\\`\\`z\\`\\`\\` be inside the following function? \\`\\`\\`js function foo(x, y, ...z) { console.log( z ); } foo( 1, 2, 3, 4, 5 ); \\`\\`\\`",
      "explanation": "The other common usage of \\`...\\` can be seen as almost the opposite; instead of spreading a value out, the \\`...\\` gathers a set of values together into an array",
      "type": "MCQ",
      "options": [
        { "text": "\\`\\[3, 4, 5\\]\\`", "correct": true },
        { "text": "\\`3\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`\\[1, 2, 3, 4, 5\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "In the following code, \\`function foo (x=20) {...}\\`, what does \"x=20\" accomplish?",
      "explanation": "In ES6+, you can provide a default value for a function parameter. The default value is used if the argument is \\*undefined\\* (including if no argument is passed). It is not used for other falsy values (i.e. 0, NaN, an empty string, etc.).",
      "type": "MCQ",
      "options": [
        {
          "text": "It assigns \\*x\\* a default value of 20 if the argument passed to the function is \\*undefined\\*.",
          "correct": true
        },
        {
          "text": "Any value passed to the function gets changed to 20.",
          "correct": false
        },
        {
          "text": "The function will only accept arguments which are equal to 20.",
          "correct": false
        },
        {
          "text": "It assigns \\*x\\* a default value of 20 if the argument passed to the function is \"falsy\".",
          "correct": false
        }
      ]
    },
    {
      "statement": "What will be logged to the console when the following function is executed? \\`\\`\\`js function foo(x = 11, y = 31) { console.log( x + y ); } foo(null, 6); foo(undefined, 6); \\`\\`\\`",
      "explanation": "\\`null\\` coerces to \\`0\\`, so the default value is never used. \\`undefined\\` is the same as a missing argument, so the default value is used in this case.",
      "type": "MCQ",
      "options": [
        { "text": "\\`17\\` / \\`17\\`", "correct": false },
        { "text": "\\`6\\` / \\`17\\`", "correct": true },
        { "text": "\\`NaN\\` / \\`NaN\\`", "correct": false },
        { "text": "\\`6\\` / \\`6\\`", "correct": false }
      ]
    },
    {
      "statement": "Function default values can only be simple values like \\`31\\`; they cannot be an expression or a function call.",
      "explanation": "Function default values can be more than just simple values like \\`31\\`; they can be any valid expression, even a function call.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js { const a = 2; a = 3; console.log(a) } \\`\\`\\`",
      "explanation": "You are not allowed to change the value the variable holds once it's been set, at declaration time. A \\`const\\` declaration must have an explicit initialization.",
      "type": "MCQ",
      "options": [
        { "text": "\\`3\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": true },
        { "text": "\\`2\\`", "correct": false },
        { "text": "\\`SyntaxError\\`", "correct": false }
      ]
    },
    {
      "statement": "With ES6, this is valid JavaScript: \\`\\`\\`js { let a = 2, b, c; // .. } \\`\\`\\`",
      "explanation": "Block scoping is now possible with the \\`let\\` and \\`const\\` keywords.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What variables are scoped within the \\`for\\` loop: \\`\\`\\`js let a = 2; if (a > 1) { let b = a \\* 3; for (let i = a; i <= b; i++) { let j = i + 10; } let c = a + b; } \\`\\`\\`",
      "explanation": "\\`j\\` is clearly scoped to the \\`for\\` loop, but \\`i\\` is not so obvious. A new \\`i\\` is scoped to the block for each iteration.",
      "type": "MCQ",
      "options": [
        { "text": "\\`j\\`", "correct": false },
        { "text": "\\`i\\`, \\`j\\`", "correct": true },
        { "text": "\\`i\\`, \\`j\\`, \\`a\\`, \\`b\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js { const a = \\[1,2,3\\]; a.push( 4 ); console.log( a ); } \\`\\`\\`",
      "explanation": "Constants are not a restriction on the value itself, but on the variable's assignment of that value. In other words, the value is not frozen or immutable because of \\`const\\`, just the assignment of it. If the value is complex, such as an object or array, the contents of the value can still be modified:",
      "type": "MCQ",
      "options": [
        { "text": "\\`\\[1, 2, 3, 4\\]\\`", "correct": true },
        { "text": "\\`\\[1, 2, 3\\]\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false }
      ]
    },
    {
      "statement": "What does the following line of code do? \\`\\`\\`js let { baz: bam } = bar(); \\`\\`\\`",
      "explanation": "The syntactic pattern here is source: target. \\`baz: bam\\` means the \\`baz\\` property is the source value and \\`bam\\` is the target variable to assign to.",
      "type": "MCQ",
      "options": [
        {
          "text": "It destructures the object property \\`baz\\` and assigns it to the variable \\`bam\\`",
          "correct": true
        },
        {
          "text": "It destructures the object property \\`bam\\` and assigns it to the variable \\`baz\\`",
          "correct": false
        }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js let x = 10, y = 20; \\[ y, x \\] = \\[ x, y \\]; console.log( x, y ); \\`\\`\\`",
      "explanation": "With destructuring, you can even solve the traditional \"swap two variables\" task without a temporary variable",
      "type": "MCQ",
      "options": [
        { "text": "\\`20 10\\`", "correct": true },
        { "text": "\\`10 20\\`", "correct": false },
        { "text": "\\`undefined undefined\\`", "correct": false }
      ]
    },
    {
      "statement": "The following is valid object destructuring syntax: \\`\\`\\`js let x, y, z; { x, y, z } = bar(); \\`\\`\\`",
      "explanation": "For the object destructuring form specifically, when leaving off a var/let/const declarator, we have to surround the whole assignment expression in ( ), because otherwise the { .. } on the lefthand side as the first element in the statement is taken to be a block statement instead of an object. So the valid way to destructure in this case is like this: \\`( { x, y, z } = bar() );\\`",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What will be logged to the console when this code runs? \\`\\`\\`js let o = \\[1,2,3\\], a, b, c, p; p = \\[a,b,c\\] = o; console.log(p === o); \\`\\`\\`",
      "explanation": "The assignment expression with object or array destructuring has as its completion value the full righthand object/array value. In the previous snippet, \\`p\\` was assigned the \\`o\\` array reference.",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": true },
        { "text": "\\`false\\`", "correct": false }
      ]
    },
    {
      "statement": "With both object and array destructuring assignment, you must assign all the values that are present.",
      "explanation": "With both array destructuring assignment and object destructuring assignment, you do not have to assign all the values that are present.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What will be logged to the console when the following is executed? \\`\\`\\`js let arr = \\[1, 2, 3, 4\\]; let obj = {a: \"x\", b: \"y\", c: \"z\"}; let \\[,,,x,y\\] = arr; let {a, d} = obj; console.log(x, y); console.log(a, d); \\`\\`\\`",
      "explanation": "if you try to assign more values than are present in the value you're destructuring/decomposing, you get graceful fallback to \\`undefined\\`",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`undefined undefined\\` / \\`x undefined\\`",
          "correct": false
        },
        { "text": "\\`4 undefined\\` / \\`x undefined\\`", "correct": true },
        { "text": "\\`3 4\\` / \\`x y\\`", "correct": false },
        { "text": "\\`4 null\\` / \\`x z\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following is executed? \\`\\`\\`js let o = {x: {y: {z: 6}}}; let {x: {y: { z: n, p: c = 3 } } } = o; console.log(n, c); \\`\\`\\`",
      "explanation": "If the values you're destructuring have nested objects or arrays, you can destructure those nested values as well",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\` / \\`undefined\\`", "correct": false },
        { "text": "\\`6\\` / \\`3\\`", "correct": true },
        { "text": "\\`6\\` / \\`undefined\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when this function is called as follows: \\`\\`\\`js function fn({ x = 10 } = {}, { y } = { y: 10 }) { console.log( x, y ); } fn(); fn({}, {}); \\`\\`\\`",
      "explanation": "It's pretty clear that named parameter \\`x\\` is defaulting to \\`10\\` if not passed as a property of that same name in the first argument's object. But what about \\`y\\` being \\`undefined\\`? The \\`{ y: 10 }\\` value is an object as a function parameter default value, not a destructuring default value. As such, it only applies if the second argument is not passed at all, or is passed as \\`undefined\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`10 10\\` / \\`10 undefined\\`", "correct": true },
        { "text": "\\`{} {y: 10}\\` / \\`10 undefined\\`", "correct": false },
        { "text": "\\`10 undefined\\` / \\`10 undefined\\`", "correct": false },
        { "text": "\\`10 10\\` / \\`10 10\\`", "correct": false }
      ]
    },
    {
      "statement": "You should use concise methods only if you’re never going to need them to do recursion or event binding/unbinding.",
      "explanation": "Concise methods imply anonymous function expressions. An anonymous function doesn't have a lexical name you can use inside the function itself.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What will be logged to the console when this code is executed? \\`\\`\\`js var o1 = { foo() { console.log( \"o1:foo\" ); } }; var o2 = { foo() { super.foo(); console.log( \"o2:foo\" ); } }; Object.setPrototypeOf( o2, o1 ); o2.foo(); \\`\\`\\`",
      "explanation": "The \\`super\\` reference in the \\`o2.foo()\\` method is locked statically to \\`o2\\`, and specifically to the \\`\\[\\[Prototype\\]\\]\\` of \\`o2\\`. \\`super\\` here would basically be \\`Object.getPrototypeOf(o2)\\` -- resolves to \\`o1\\` of course -- which is how it finds and calls \\`o1.foo()\\`",
      "type": "MCQ",
      "options": [
        { "text": "\\`o1:foo\\` / \\`o2:foo\\`", "correct": true },
        { "text": "\\`o2:foo\\` / \\`o1:foo\\`", "correct": false },
        { "text": "\\`o2:foo\\`", "correct": false },
        { "text": "\\`o1:foo\\`", "correct": false }
      ]
    },
    {
      "statement": "Arrow functions are always anonymous function expressions; there is no arrow function declaration.",
      "explanation": "It also should be clear that they are anonymous function expressions — they have no named reference for the purposes of recursion or event binding/unbinding",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "Which of the following statements is true:",
      "explanation": "Inside arrow functions, the \\`this\\` binding is not dynamic, but is instead lexical.",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`this\\` binding inside arrow functions is dynamic",
          "correct": false
        },
        {
          "text": "\\`this\\` binding inside arrow functions is lexical",
          "correct": true
        },
        {
          "text": "You cannot use \\`this\\` inside arrow functions",
          "correct": false
        },
        {
          "text": "\\`this\\` always points to the global object inside arrow functions",
          "correct": false
        }
      ]
    },
    {
      "statement": "What will be logged to the console when the following is executed? \\`\\`\\`js for (let a of \\[1, 2, 3\\]) { console.log(a); } \\`\\`\\`",
      "explanation": "for..in loops over the keys/indexes in an array, while for..of loops over the values of the array.",
      "type": "MCQ",
      "options": [
        { "text": "\\`1\\`, \\`2\\`, \\`3\\`", "correct": true },
        { "text": "\\`0\\`, \\`1\\`, \\`2\\`", "correct": false }
      ]
    },
    {
      "statement": "Which of the following statements is not true:",
      "explanation": "You cannot and should not use \\`new\\` with \\`Symbol(..)\\`. It's not a constructor, nor are you producing an object. The correct way to create a new symbol is like this: \\`let sym = Symbol( \"some optional description\" );\\`",
      "type": "MCQ",
      "options": [
        {
          "text": "You should always use \\`new Symbol(...)\\` to create a new symbol.",
          "correct": true
        },
        {
          "text": "Unlike the other primitive types, symbols don’t have a literal form.",
          "correct": false
        },
        {
          "text": "The \\`typeof\\` operator outputs \\`\"symbol\"\\` when used in front of a symbol value and that is the primary way to identify one.",
          "correct": false
        },
        {
          "text": "The parameter passed to \\`Symbol(..)\\` is optional. If passed, it should be a string that gives a friendly description for the symbol’s purpose.",
          "correct": false
        }
      ]
    },
    {
      "statement": "The main point of a symbol is to create a string-like value that can’t collide with any other value.",
      "explanation": "You can think of this symbol value as an automatically generated, unique (within your application) string value.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var arr = \\[1,2,3\\]; var it = arr\\[Symbol.iterator\\](); console.log(it.next().value); \\`\\`\\`",
      "explanation": "Each time the method located at \\`Symbol.iterator\\` (see Chapters 2 and 7) is invoked on this \\`arr\\` value, it will produce a new fresh iterator. Most structures will do the same, including all the built-in data structures in JS.",
      "type": "MCQ",
      "options": [
        { "text": "\\`1\\`", "correct": true },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js let str = \"hi\"; let it = str\\[Symbol.iterator\\](); it.next(); it.next(); console.log(it.next()); \\`\\`\\`",
      "explanation": "The \\`it\\` iterator doesn't report \\`done: true\\` when you receive the \\`'i'\\` value. You have to call \\`next()\\` again, in essence going beyond the end of the string's values, to get the complete signal \\`done: true\\`",
      "type": "MCQ",
      "options": [
        { "text": "\\`{value: 'i', done: true}\\`", "correct": false },
        { "text": "\\`{value: undefined, done: true}\\`", "correct": true },
        { "text": "\\`{value: 'i', done: false}\\`", "correct": false },
        { "text": "\\`{value: undefined, done: false}\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var a = \\[1,2,3,4,5\\]; function foo(x,y,z,w,p) { console.log( x + y + z + w + p ); } foo( ...a ); \\`\\`\\`",
      "explanation": "The \\`...\\` spread operator fully exhausts an iterator.",
      "type": "MCQ",
      "options": [
        { "text": "\\`15\\`", "correct": true },
        { "text": "\\`NaN\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`SyntaxError\\`", "correct": false }
      ]
    },
    {
      "statement": "Which of the following is the correct way to declare a generator function?",
      "explanation": "The position of the \\* is not functionally relevant. The only difference here is stylistic preference.",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`function \\*foo() { .. }\\` or \\`function\\* foo() { .. }\\`",
          "correct": false
        },
        {
          "text": "\\`function \\* foo() { .. }\\` or \\`function\\* foo() { .. }\\`",
          "correct": false
        },
        { "text": "All of the above", "correct": true },
        { "text": "None of the above", "correct": false }
      ]
    },
    {
      "statement": "What will the last line of code do when it is executed? \\`\\`\\`js function \\*rand() { while (true) { yield Math.random(); } } const it = rand(); it.next(); \\`\\`\\`",
      "explanation": "You can put \\`yield\\` inside a loop, and it can represent a repeated pause point. \\`yield\\` is not just a pause point. It’s an expression that sends out a value when pausing the generator. The code here generates and yields a new random number whenever \\`it.next()\\` is called.",
      "type": "MCQ",
      "options": [
        { "text": "It will generate a new random number", "correct": true },
        { "text": "It will start an infinite loop", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js function \\*foo() { yield \\*\\[1, 2, 3\\]; yield \"we're done\"; } const it = foo(); it.next(); console.log(it.next().value); \\`\\`\\`",
      "explanation": "In the same way that the \\`\\*\\` makes a \\`function\\` declaration into \\`function \\*\\` generator declaration, a \\`\\*\\` makes \\`yield\\` into \\`yield \\*\\`, which is a very different mechanism, called yield delegation. \\`yield \\* ..\\` requires an iterable; it then invokes that iterable's iterator, and delegates its own host generator's control to that iterator until it's exhausted.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\\[1, 2, 3\\]\\`", "correct": false },
        { "text": "\\`2\\`", "correct": true },
        { "text": "\\`\"we're done\"\\`", "correct": false },
        { "text": "\\`1\\`", "correct": false }
      ]
    },
    {
      "statement": "Which of the following is not true of ES6 modules?",
      "explanation": "Modules are no different from other ES6 features in that they should be used, but polyfills might be needed for older browsers.",
      "type": "MCQ",
      "options": [
        {
          "text": "You cannot have multiple modules in a file",
          "correct": false
        },
        {
          "text": "Once you define statically what all the top-level exports are on your module's public API, those cannot be amended later.",
          "correct": false
        },
        {
          "text": "There is only one instance of the module, which maintains its state. Every time you import that module into another module, you get a reference to the one centralized instance.",
          "correct": false
        },
        {
          "text": "ES6 modules are still experimental and should not be used",
          "correct": true
        }
      ]
    },
    {
      "statement": "What is the difference between importing default exports and named exports?",
      "explanation": "As the name suggests, the default export is the default export for that module, whereas named exports need to be imported by name.",
      "type": "MCQ",
      "options": [
        {
          "text": "Named exports are imported as \\`import { foo } from \"foo\";\\`, and default exports are imported as \\`import foo from \"foo\";\\`",
          "correct": true
        },
        {
          "text": "Named exports are imported as \\`import foo from \"foo\";\\`, and default exports are imported as \\`import { foo } from \"foo\";\\`",
          "correct": false
        }
      ]
    },
    {
      "statement": "You cannot put either an \\`import\\` or \\`export\\` inside an \\`if\\` conditional.",
      "explanation": "They must appear outside of all blocks and functions.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "Which of the following is an invalid export?",
      "explanation": "You currently cannot do \\`export default var foo = ..\\` (or \\`let\\` or \\`const\\`), in a frustrating case of inconsistency. At the time of this writing, there's already discussion of adding that capability in soon, post-ES6, for consistency sake.",
      "type": "MCQ",
      "options": [
        { "text": "\\`export default const PI = 3.14;\\`", "correct": true },
        { "text": "\\`export const PI = 3.14;\\`", "correct": false },
        { "text": "\\`export function foo() { .. }\\`", "correct": false },
        {
          "text": "\\`export default function foo() { .. }\\`",
          "correct": false
        }
      ]
    },
    {
      "statement": "What of the following options is an incorrect way of importing the following exports: \\`\\`\\`js export default function foo() { .. } export function bar() { .. } export function baz() { .. } \\`\\`\\`",
      "explanation": "the default keyword in a module's export specifies a named export where the name is actually default",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`import {foo, bar, baz} from \"foo\";\\`",
          "correct": true
        },
        {
          "text": "\\`import foo, { bar, baz } from \"foo\";\\`",
          "correct": false
        },
        {
          "text": "\\`import { default as foo, bar as x, baz as y} from \"foo\";\\`",
          "correct": false
        },
        {
          "text": "\\`import FOOFN, { bar, baz} from \"foo\";\\`",
          "correct": false
        }
      ]
    },
    {
      "statement": "All imported bindings are immutable and/or read-only and any subsequent assignment attempts will throw a \\`TypeError\\`",
      "explanation": "You cannot reassign an imported function or variable in your code.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "\\`class Foo {...}\\` creates a constructor function named \\`Foo\\`",
      "explanation": "\\`class Foo\\` implies creating a (special) function of the name Foo, much like you did pre-ES6.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "Which of the following statements about classes is not true:",
      "explanation": "While \\`function Foo() {...}\\` is “hoisted”, \\`class Foo\\` is not.",
      "type": "MCQ",
      "options": [
        { "text": "\\`class Foo\\` is hoisted", "correct": true },
        {
          "text": "The \\`Foo(...)\\` constructor call \\*must\\* be made with the \\`new\\` keyword",
          "correct": false
        },
        {
          "text": "A \\`class\\` can be thought of as a macro, used to automatically populate a \\`prototype\\` object",
          "correct": false
        },
        {
          "text": "Unlike object literals, there are no commas separating members in a \\`class\\` body",
          "correct": false
        }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js class Foo { constructor(x) { this.x = x; } print() { console.log(\"Foo:\", this.x); } } class Bar extends Foo { constructor(x, y) { super(x); this.y = y; } print() { super.print(); console.log(\"Bar:\", this.y); } } const b = new Bar(3, 6); b.print(); \\`\\`\\`",
      "explanation": "In the constructor, \\`super\\` automatically refers to the \"parent constructor,\" which in the previous example is \\`Foo(..)\\`. In a method, it refers to the \"parent object,\" such that you can then make a property/method access off it, such as \\`super.print()\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`Foo: 3\\` / \\`Bar: 6\\`", "correct": true },
        { "text": "\\`Foo: 3\\`", "correct": false },
        { "text": "\\`Bar: 6\\`", "correct": false },
        { "text": "\\`Foo: undefined\\` / \\`Bar: 6\\`", "correct": true }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js class Foo { ... } class Bar extends Foo { ... } console.log(Foo.isPrototypeOf(Bar)); \\`\\`\\`",
      "explanation": "\\`Bar extends Foo\\` of course means to link the \\[\\[Prototype\\]\\] of \\`Bar.prototype\\` to \\`Foo.prototype\\`",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": true },
        { "text": "\\`false\\`", "correct": false }
      ]
    },
    {
      "statement": "Constructors are required for both classes and subclasses",
      "explanation": "Constructors are not required for classes or subclasses; a default constructor is substituted in both cases if omitted. Furthermore, the default subclass constructor automatically calls the parent constructor, and passes along any arguments.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "In a constructor of a subclass, you cannot access \\`this\\` until \\`super(..)\\` has been called.",
      "explanation": "The reason is nuanced and complicated, but it boils down to the fact that the parent constructor is actually the one creating/initializing your instance's \\`this\\`, which you cannot access before it is actually created.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js class Foo { static cool() { console.log( \"cool\" ); } wow() { console.log( \"wow\" ); } } class Bar extends Foo { static awesome() { super.cool(); console.log( \"awesome\" ); } neat() { super.wow(); console.log( \"neat\" ); } } var b = new Bar(); b.awesome(); \\`\\`\\`",
      "explanation": "Be careful not to get confused that static members are on the class's prototype chain.They're actually on the dual/parallel chain between the function constructors.",
      "type": "MCQ",
      "options": [
        { "text": "\\`TypeError\\`", "correct": true },
        { "text": "\\`\"cool\"\\` / \\`\"awesome\"\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`undefined\\` / \\`\"awesome\"\\`", "correct": false }
      ]
    },
    {
      "statement": "What are the two possible outcomes of a \\`Promise\\`?",
      "explanation": "If there are no errors, then the Promise will get resolved, but if an error occurs typically the Promise will get rejected.",
      "type": "MCQ",
      "options": [
        { "text": "Fulfilled and rejected", "correct": true },
        { "text": "Completed and in progress", "correct": false },
        { "text": "Returned and incomplete", "correct": false }
      ]
    },
    {
      "statement": "A promise can only be resolved (fulfilled or rejected) once",
      "explanation": "Promises can only be resolved (fulfillment or rejection) once. Any further attempts to fulfill or reject are simply ignored. Thus, once a Promise is resolved, it's an immutable value that cannot be changed.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "This is a valid way to construct a promise: \\`\\`\\`js var p = new Promise(() => { return setTimeout(() => 5, 1000) } ); \\`\\`\\`",
      "explanation": "There are a couple things wrong with this code. For one, \\`setTimeout\\` does not return the return value of the callback. \\`fn\\` in \\`new Promise(fn)\\` needs to have an argument, such as \\`resolve\\`, which you call on your desired return value.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "This is a valid way to construct and consume a promise: \\`\\`\\`js var p = new Promise((resolve) => { setTimeout(() => resolve(5), 1000); } ); p.done(val => { console.log(val); }); \\`\\`\\`",
      "explanation": "\\`done\\` is not a valid method for a Promise. The code above would be valid if it were replaced with \\`.then()\\`",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What do \\`.then(..)\\` and \\`.catch(..)\\` methods return when invoked on a promise?",
      "explanation": "Both \\`then(..)\\` and \\`catch(..)\\` automatically construct and return another promise instance, which is wired to receive the resolution from whatever the return value is from the original promise's fulfillment or rejection handler (whichever is actually called)",
      "type": "MCQ",
      "options": [
        { "text": "another promise", "correct": true },
        { "text": "an object", "correct": false },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "a function", "correct": false }
      ]
    },
    {
      "statement": "What are thenables?",
      "explanation": "Any object (or function) with a \\`then(..)\\` function on it is assumed to be a thenable. Any place where the Promise mechanisms can accept and adopt the state of a genuine promise, they can also handle a thenable.",
      "type": "MCQ",
      "options": [
        { "text": "Just another word for Promises", "correct": false },
        {
          "text": "The next version of promises introduced in ES7",
          "correct": false
        },
        {
          "text": "Promise-like objects that generally can interoperate with Promise mechanisms",
          "correct": true
        },
        { "text": "Promises that are used with generators", "correct": false }
      ]
    },
    {
      "statement": "\\`p1\\` and \\`p2\\` have essentially the same behavior: \\`\\`\\`js var p1 = Promise.resolve( 42 ); var p2 = new Promise( function pr(resolve){ resolve( 42 ); } ); \\`\\`\\`",
      "explanation": "\\`Promise.resolve\\` creates a resolved promise. To access the value \\`42\\`, you need to call \\`.then()\\`",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What will be logged to the console when the following is executed? \\`\\`\\`js const a = 42, b = Promise.resolve(43), c = 44; Promise.all(\\[a, b, c\\]).then(val => console.log(val)); \\`\\`\\`",
      "explanation": "\\`Promise.all(\\[ .. \\])\\` accepts an array of one or more values (e.g., immediate values, promises, thenables). It returns a promise back that will be fulfilled if all the values fulfill, or reject immediately once the first of any of them rejects",
      "type": "MCQ",
      "options": [
        { "text": "\\`42\\`", "correct": false },
        { "text": "\\`43\\`", "correct": false },
        { "text": "\\`\\[42, 43, 44\\]\\`", "correct": true }
      ]
    },
    {
      "statement": "What will be logged to the console when the following is executed? \\`\\`\\`js const a = 42, b = Promise.resolve(43), c = 44; Promise.race(\\[a, b, c\\]).then(val => console.log(val)); \\`\\`\\`",
      "explanation": "While \\`Promise.all(\\[ .. \\])\\` waits for all fulfillments (or the first rejection), \\`Promise.race(\\[ .. \\])\\` waits only for either the first fulfillment or rejection.",
      "type": "MCQ",
      "options": [
        { "text": "\\`42\\`", "correct": true },
        { "text": "\\`43\\`", "correct": false },
        { "text": "\\`\\[42, 43, 44\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following is executed? \\`\\`\\`js const a = Promise.resolve(43), b = 42, c = Promise.reject(\"Oops\"); Promise.race(\\[a, b, c\\]) .then(val => console.log(val)) .catch(e => console.log(e)); \\`\\`\\`",
      "explanation": "While \\`Promise.all(\\[ .. \\])\\` waits for all fulfillments (or the first rejection), \\`Promise.race(\\[ .. \\])\\` waits only for either the first fulfillment or rejection (whichever happens first). In the code snippet above, if we changed the order of the array to \\`Promise.race(\\[c, b, a\\])\\` then we'd get \\`'Oops'\\` printed instead.",
      "type": "MCQ",
      "options": [
        { "text": "\\`42\\`", "correct": false },
        { "text": "\\`43\\`", "correct": true },
        { "text": "\\`\"Oops\"\\`", "correct": false }
      ]
    },
    {
      "statement": "What do typed arrays allow you to do in JavaScript?",
      "explanation": "It'd be tempting to look at a feature named \"typed array\" and assume it means an array of a specific type of values, like an array of only strings. However, typed arrays are really more about providing structured access to binary data using array-like semantics (indexed access, etc.). The \"type\" in the name refers to a \"view\" layered on type of the bucket of bits, which is essentially a mapping of whether the bits should be viewed as an array of 8-bit signed integers, 16-bit signed integers, and so on.",
      "type": "MCQ",
      "options": [
        {
          "text": "Create arrays of a specific type of values, like an array of only strings",
          "correct": false
        },
        {
          "text": "Provide structured access to binary data using array-like semantics",
          "correct": true
        }
      ]
    },
    {
      "statement": "What is the difference between maps and objects?",
      "explanation": "Maps were added in ES6 and are just like objects except the keys can be anything, even arrays or objects!",
      "type": "MCQ",
      "options": [
        {
          "text": "Object keys have to be strings, and map keys can be any value",
          "correct": true
        },
        { "text": "Maps are immutable, and objects are not", "correct": false },
        {
          "text": "Objects are the JavaScript version of maps",
          "correct": false
        },
        { "text": "There is no difference", "correct": false }
      ]
    },
    {
      "statement": "The following code is valid ES6: \\`\\`\\`js var m = new Map(); var x = { id: 1 }, y = { id: 2 }; m\\[x\\] = y; \\`\\`\\`",
      "explanation": "Maps do not support the \\`\\[\\]\\` syntax. \\`set\\` operations must be done like \\`m.set(x, y)\\`.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "Which of the following statements about WeakMaps is not true:",
      "explanation": "WeakMaps take (only) objects as keys. Those objects are held weakly, which means if the object itself is GC'd, the entry in the WeakMap is also removed.",
      "type": "MCQ",
      "options": [
        { "text": "WeakMaps take only objects as keys", "correct": false },
        {
          "text": "WeakMaps do not expose any iterators over their keys, values, or entries",
          "correct": false
        },
        {
          "text": "If an object used as a key in a WeakMap is garbage collected, the entry is not removed",
          "correct": true
        },
        {
          "text": "WeakMaps do not have a \\`size\\` property or \\`clear()\\` method",
          "correct": false
        }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js let duplicates = \\[1, 2, 2, 3, 4, 4, 4, 5\\]; let newSet = new Set(duplicates); console.log(newSet.size); \\`\\`\\`",
      "explanation": "Sets can be constructed with iterators such as arrays, and they only store unique values. They are kind of like objects with keys but no values.",
      "type": "MCQ",
      "options": [
        { "text": "\\`8\\`", "correct": false },
        { "text": "\\`5\\`", "correct": true },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`SyntaxError\\`", "correct": false }
      ]
    },
    {
      "statement": "What is one way to copy a set: \\`\\`\\`js let values = \\[1, 1, 2, 3\\]; let setValues = new Set(values) \\`\\`\\`",
      "explanation": "The constructor is the only way to make a new set, and it will copy values from the set into a new set.",
      "type": "MCQ",
      "options": [
        { "text": "\\`let copy = setValues.copy()\\`", "correct": false },
        {
          "text": "\\`let copy = Set.assign(new Set(), setValues)\\`",
          "correct": false
        },
        {
          "text": "\\`let copy = new Set(\\[setValues\\])\\`",
          "correct": false
        },
        { "text": "\\`let copy = new Set(setValues)\\`", "correct": true }
      ]
    },
    {
      "statement": "Which of the following statements about Sets is not true:",
      "explanation": "A set doesn't need (and doesn't have) a \\`get(..)\\` because you don't retrieve a value from a set, but rather test if it is present or not, using \\`has(..)\\`",
      "type": "MCQ",
      "options": [
        {
          "text": "A set is a collection of unique values (duplicates are ignored)",
          "correct": false
        },
        {
          "text": "The \\`add()\\` method is used to add new items to a set",
          "correct": false
        },
        {
          "text": "The \\`get()\\` method is used to retrieve an item from a set",
          "correct": true
        },
        {
          "text": "The \\`has()\\` method is used to test if a value is present or not",
          "correct": false
        }
      ]
    },
    {
      "statement": "This is a valid way to create an array from a set: \\`\\`\\`js let s = new Set(\\[1, 2, 2, 3, 3, 3\\]); let a = \\[...s\\]; \\`\\`\\`",
      "explanation": "You can use the spread operator with sets",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "Which of the following are valid ways to make an iterator of map keys: \\`\\`\\`js var newMap = new Map() var x = {\"foo\": 1} var xVal = \"foo1\"; var y = {\"foo\": 2} var yVal = \"foo2\"; newMap.set(x, xVal) newMap.set(y, yVal) \\`\\`\\`",
      "explanation": "\\`newMap.keys()\\` will create an iterator of the keys. \\`newMap.forEach()\\` iterates over the values, and \\`entries()\\` creates a two dimensional array of keys and values.",
      "type": "MCQ",
      "options": [
        { "text": "\\`newMap.keys()\\`", "correct": true },
        { "text": "\\`newMap.keys\\`", "correct": false },
        { "text": "\\`newMap.entries()\\`", "correct": false },
        { "text": "\\`newMap.forEach(key => {...})\\`", "correct": false }
      ]
    },
    {
      "statement": "Which of the following statements about WeakSets is true:",
      "explanation": "Whereas a WeakMap holds its keys weakly (but its values strongly), a WeakSet holds its values weakly (there aren't really keys).",
      "type": "MCQ",
      "options": [
        { "text": "A WeakSet holds its values weakly", "correct": true },
        { "text": "A WeakSet holds its keys weakly", "correct": false },
        {
          "text": "WeakSet values can be primitives like strings or numbers",
          "correct": false
        }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js let arr = Array(5); console.log(arr.length); \\`\\`\\`",
      "explanation": "There's a well known gotcha with the \\`Array(..)\\` constructor, which is that if there's only one argument passed, and that argument is a number, instead of making an array of one element with that number value in it, it constructs an empty array with a length property equal to the number.",
      "type": "MCQ",
      "options": [
        { "text": "\\`5\\`", "correct": true },
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`4\\`", "correct": false },
        { "text": "\\`0\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js Array(1, 2, 3).length === Array.of(5, 6, 7).length \\`\\`\\`",
      "explanation": "\\`Array.of(..)\\` replaces \\`Array(..)\\` as the preferred function-form constructor for arrays",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": true },
        { "text": "\\`false\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js let arrLike = { length: 4, 0: \"foo\", 2: \"bar\" }; console.log(Array.from(arrLike)); \\`\\`\\`",
      "explanation": "\\`Array.from(..)\\` looks to see if the first argument is an iterable, and if so, it uses the iterator to produce values to \"copy\" into the returned array. If you pass an array-like object as the first argument, it simply loops over the value, accessing numerically named properties from \\`0\\` up to whatever the value of \\`length\\` is. \\`Array.from(..)\\` never produces empty slots.",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`\\[\"foo\", undefined, \"bar\", undefined\\]\\`",
          "correct": true
        },
        {
          "text": "\\`\\[undefined, undefined, undefined, undefined\\]\\`",
          "correct": false
        },
        { "text": "\\`\\[\"foo\", \"bar\"\\]\\`", "correct": false },
        { "text": "\\`\\[\"foo\",,\"bar\",,\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "\\`Array.from(..)\\` takes an optional second argument, which is a \\_\\_\\_\\_ callback.",
      "explanation": "The second argument, if provided, is a mapping callback (almost the same as the regular \\`Array#map(..)\\` expects) which is called to map/transform each value from the source to the returned target.",
      "type": "MCQ",
      "options": [
        { "text": "mapping", "correct": true },
        { "text": "filtering", "correct": false },
        { "text": "sorting", "correct": false },
        { "text": "reducing", "correct": false }
      ]
    },
    {
      "statement": "What does the following line of code do? \\`\\`\\`js let a = Array.from( { length: 2 } ); \\`\\`\\`",
      "explanation": "You can use \\`Array.from()\\` to create an array of \\`undefined\\` values",
      "type": "MCQ",
      "options": [
        {
          "text": "It creates an array with two \\`undefined\\` values",
          "correct": true
        },
        { "text": "It creates an array with two empty slots", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js let x = NaN, y = 0, z = -0; console.log(Object.is(x, x)); console.log(Object.is(y, z)); \\`\\`\\`",
      "explanation": "\\`Object.is(..)\\` is basically the same as \\`===\\`, with two exceptions: \\`Object.is(NaN, NaN)\\` is \\`true\\` and \\`Object.is(0, -0)\\` is \\`false\\`",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\` / \\`false\\`", "correct": true },
        { "text": "\\`false\\` / \\`true\\`", "correct": false },
        { "text": "\\`false\\` / \\`false\\`", "correct": false },
        { "text": "\\`true\\` / \\`true\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js console.log(Number.isInteger(4.0)); \\`\\`\\`",
      "explanation": "In JavaScript, there’s no difference between \\`4\\`, \\`4.\\`, \\`4.0\\`, or \\`4.0000\\`. All of these would be considered an “integer”",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": true },
        { "text": "\\`false\\`", "correct": false }
      ]
    },
    {
      "statement": "What is \\`Number.MAX\\_SAFE\\_INTEGER\\`?",
      "explanation": "Max safe integer is the highest integer that can safely be represented in a JavaScript number value which is \\`2^53 - 1\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`2^53 - 1\\`", "correct": true },
        { "text": "\\`2^32 - 1\\`", "correct": false },
        { "text": "\\`2^32\\`", "correct": false },
        { "text": "\\`Infinity\\`", "correct": false }
      ]
    },
    {
      "statement": "Why would you use \\`Number.isNaN()\\` instead of \\`isNaN()\\`?",
      "explanation": "\\`isNaN()\\` checks for things that are not a number. So that includes \\`NaN\\` and any other value that isn't a number.",
      "type": "MCQ",
      "options": [
        {
          "text": "If you are literally checking for the value \\`NaN\\`",
          "correct": true
        },
        {
          "text": "If you want to determine if a value is not of type number, so that does not include \\`NaN\\`",
          "correct": false
        },
        {
          "text": "If you want to determine if a value is not of type number, including \\`NaN\\`",
          "correct": false
        },
        {
          "text": "If you want to use the faster, ES6 version",
          "correct": false
        }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var obj1 = { a: 4 }; var obj2 = { b: obj1 } Object.assign(obj1, obj2) console.log(obj1) \\`\\`\\`",
      "explanation": "\\`Object.assign(obj1, obj2)\\` takes \\`obj2\\` and merges it into \\`obj1\\`. In the example above, after the merge, the attribute \\`\"b\"\\` actually references \\`obj1\\` itself recursively.",
      "type": "MCQ",
      "options": [
        { "text": "\\`{ a: 4 }\\`", "correct": false },
        { "text": "\\`{ a: 4, b: obj1 }\\`", "correct": true },
        {
          "text": "\\`{ a: 4, b: \"\\[Object object\\]\" }\\`",
          "correct": false
        },
        { "text": "\\`TypeError\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js console.log(Array(4).fill(3)) \\`\\`\\`",
      "explanation": "\\`Array(4)\\` creates an array with 4 spots, and \\`fill(3)\\` fills them with the value 3",
      "type": "MCQ",
      "options": [
        { "text": "\\`\\[4, 4, 4\\]\\`", "correct": false },
        { "text": "\\`\\[3, 3, 3, 3\\]\\`", "correct": true },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`\\[7\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var foo = \\[1, \"2\", 2, 4, \"2\"\\]; var newFoo = foo.find((val) => { return val == 2 }) console.log(newFoo + 1) \\`\\`\\`",
      "explanation": "\\`foo.find()\\` returns the first value for which the comparison is truthy, so \\`\"2\"\\` at index 1. \\`1\\` is then coerced into \\`\"1\"\\` and added to \\`\"2\"\\` which is \\`\"21\"\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"2,2,21\"\\`", "correct": false },
        { "text": "\\`\"21\"\\`", "correct": true },
        { "text": "\\`3\\`", "correct": false },
        { "text": "\\`NaN\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var abc = function def() { let a = 5; } console.log(abc.name) \\`\\`\\`",
      "explanation": "The \\`name\\` property of a function will refer to the lexical binding name if it exists. In this case, it is \\`\"def\"\\`. If the function was anonymous, the name property would be \\`\"abc\"\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"abc\"\\`", "correct": false },
        { "text": "\\`\"def\"\\`", "correct": true },
        { "text": "\\`\\[\"def\", \"name\"\\]\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var o = {}; o\\[2\\] = true; o\\[1\\] = true; o.b = \"awesome\"; o.a = \"cool\"; console.log(Object.getOwnPropertyNames( o )); \\`\\`\\`",
      "explanation": "The ordering is: 1. First, enumerate any owned properties that are integer indexes, in ascending numeric order. 2. Next, enumerate the rest of the owned string property names in creation order. 3. Finally, enumerate owned symbol properties in creation order.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\\[1,2,\"b\",\"a\"\\]\\`", "correct": true },
        { "text": "\\`\\[1,2,\"a\",\"b\"\\]\\`", "correct": false },
        { "text": "Order cannot be guaranteed", "correct": false },
        { "text": "\\`\\[2,1,\"b\",\"a\"\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var arr = \\[4, 5, 6, 7\\]; arr\\[Symbol.iterator\\] = function\\* () { var idx = 0; do { yield 3; } while ((idx += 1) < this.length); }; console.log(\\[...arr\\]) \\`\\`\\`",
      "explanation": "The generator defines how to iterate through values in \\`arr\\`. We defined it to return the value \\`3\\` for each element in the array.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\\[4, 5, 6, 7\\]\\`", "correct": false },
        { "text": "\\`\\[3, 3, 3, 3\\]\\`", "correct": true },
        { "text": "\\`\\[4, 5, 6\\]\\`", "correct": false },
        { "text": "\\`\\[3, 3, 3\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var obj1 = { a: 3 } var obj2 = { b: 3 } obj1.toString = () => \"foo\" obj2\\[Symbol.toStringTag\\] = \"foo\"; console.log(obj1.toString() === obj2.toString()) \\`\\`\\`",
      "explanation": "\\`obj1.toString()\\` is \\`\"foo\"\\` and \\`obj2.toString()\\` is \\`\"\\[object foo\\]\"\\`",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": false },
        { "text": "\\`false\\`", "correct": true },
        { "text": "\\`SyntaxError\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var arr = \\[1, 2, 3, 4, 5\\]; arr\\[Symbol.toPrimitive\\] = function () { return 5 }; console.log(arr + 10); \\`\\`\\`",
      "explanation": "\\`toPrimitive\\` is used when an object must be coerced to a primitive value. We are overriding its typical functionality for \\`arr\\` and forcing it to be \\`5\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"1,2,3,4,510\"\\`", "correct": false },
        { "text": "\\`15\\`", "correct": true },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js let obj = {a: 1, b: 2}; let handlers = { get(target,key,context) { if (Reflect.has( target, key )) { return Reflect.get(target, key, context); } else { throw \"No such property/method!\"; } } } let proxy = new Proxy(obj, handlers); console.log(proxy.c); \\`\\`\\`",
      "explanation": "A proxy is a special kind of object you create that \"wraps\" -- or sits in front of -- another normal object. You can register special handlers (aka traps) on the proxy object which are called when various operations are performed against the proxy. These handlers have the opportunity to perform extra logic in addition to forwarding the operations on to the original target/wrapped object.",
      "type": "MCQ",
      "options": [
        { "text": "No such property/method!", "correct": true },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`null\\`", "correct": false }
      ]
    },
    {
      "statement": "The following code is a valid way for testing whether arrow functions work in the runtime environment: \\`\\`\\`js try { a = () => {}; ARROW\\_FUNCS\\_ENABLED = true; } catch (err) { ARROW\\_FUNCS\\_ENABLED = false; } \\`\\`\\`",
      "explanation": "Unfortunately, this doesn't work, because our JS programs are compiled. Thus, the engine will choke on the arrow function syntax if it doesn't already support it. The alternative would be to use \\`new Function( \"(() => { })\" );\\` inside the \\`try\\` block.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "Tail Call Optimization helps us save memory when we do object oriented programming",
      "explanation": "Certain patterns of function calls in recursive programming, called tail calls, can be optimized in a way to avoid the extra allocation of stack frames. Instead of creating a new stack frame for the next function call, the engine just reuses the existing stack frame. That works because a function doesn't need to preserve any of the current state.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "Tail Call Optimization will be applied to the following code: \\`\\`\\`js \"use strict\"; function foo(x) { return x \\* 2; } function bar(x) { x = x + 1; if (x > 10) { return foo( x ); } else { return bar( x + 1 ); } } bar( 5 ); \\`\\`\\`",
      "explanation": "\\`foo(..)\\` and \\`bar(..)\\` both are in tail position, as they're the last thing to happen in their code path (other than the return). In both cases, the function calls are in proper tail position. Proper Tail Calls (PTC) of these forms can be optimized.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "Tail Call Optimization (TCO) can only be applied in strict mode",
      "explanation": "This optimization can only be applied in strict mode. Yet another reason to always be writing all your code as strict!",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What do \\`async\\` functions return?",
      "explanation": "\\`async\\` functions return a promise which can then be consumed via \\`await\\` or with \\`.then()\\`.",
      "type": "MCQ",
      "options": [
        { "text": "a promise", "correct": true },
        { "text": "a callback", "correct": false },
        { "text": "a resolved promise", "correct": false },
        { "text": "an object", "correct": false }
      ]
    },
    {
      "statement": "The \\`await\\` keyword can only be used inside an \\`async\\` function",
      "explanation": "The \\`await\\` expression causes \\`async\\` function execution to pause until a \\`Promise\\` is resolved, that is fulfilled or rejected, and to resume execution of the \\`async\\` function after fulfillment. When resumed, the value of the \\`await\\` expression is that of the fulfilled \\`Promise\\`.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var obj = { a: 1, b: 2 }; Object.observe( obj, function (changes) { console.log(changes) } ); obj.a = 3 \\`\\`\\`",
      "explanation": "Trick question! \\`Object.observe()\\` has been deprecated. ES6 Proxies are recommended as an alternative.",
      "type": "MCQ",
      "options": [
        { "text": "\\`TypeError\\`", "correct": true },
        { "text": "\\`{change: {a: 3}}\\`", "correct": false },
        { "text": "\\`\"change\"\\`", "correct": false },
        { "text": "\\`\\[{change: {a: 3}}\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed? \\`\\`\\`js let a = 2; console.log(a \\*\\* 4 === Math.pow(a, 4)); \\`\\`\\`",
      "explanation": "The \\`\\*\\*\\` operator has been proposed for JavaScript to perform exponentiation in the same way that \\`Math.pow(..)\\` does",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": true },
        { "text": "\\`false\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var o1 = { a: 1, b: 2 }, o2 = { c: 3 }, o3 = { ...o1, ...o2, d: 4 }; console.log(o3.a, o3.b, o3.c, o3.d); \\`\\`\\`",
      "explanation": "The spread operator here works similar to that with arrays.",
      "type": "MCQ",
      "options": [
        { "text": "\\`1 2 3 4\\`", "correct": true },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`4\\`", "correct": false },
        { "text": "\\`3 4\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js let o1 = {a: 1, b: 2, c: 3}; let {b, ...o2} = o1; console.log(o2); \\`\\`\\`",
      "explanation": "The \\`...\\` operator might also be used to gather an object's destructured properties back into an object",
      "type": "MCQ",
      "options": [
        { "text": "\\`{a: 1, c: 3}\\`", "correct": true },
        { "text": "\\`{b: 2, c: 3}\\`", "correct": false },
        { "text": "\\`{a: 1, b: 2, c: 3}\\`", "correct": false },
        { "text": "\\`{a: 1, b: 2}\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var arr = \\[1, 2, 3, 'hello'\\]; console.log(arr.includes('hello')); \\`\\`\\`",
      "explanation": "\\`Array.prototype.includes(x)\\` simply checks to see if an element value is equal to \\`x\\`",
      "type": "MCQ",
      "options": [
        { "text": "\\`true\\`", "correct": true },
        { "text": "\\`false\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false }
      ]
    },
    {
      "statement": "What is WebAssembly?",
      "explanation": "WebAssembly proposes a format for a binary representation of a highly compressed AST (syntax tree) of code, which can then give instructions directly to the JS engine and its underpinnings, without having to be parsed by JS, or even behave by the rules of JS.",
      "type": "MCQ",
      "options": [
        { "text": "A new programming language", "correct": false },
        { "text": "The future replacement of JavaScript", "correct": false },
        { "text": "A new binary represenation of code", "correct": true },
        { "text": "A new JavaScript framework", "correct": false }
      ]
    },
    {
      "statement": "\\`console.log()\\` is always executed synchronously",
      "explanation": "While it is up to the hosting environment how they want to implement \\`console\\`, it is often asynchronous because blocking I/O takes a lot of time.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var data = ajax( \"https://google.com\" ); console.log( data ); \\`\\`\\`",
      "explanation": "Because \\`ajax\\` is asynchronous, \\`data\\` will not yet be defined when it is logged to the console.",
      "type": "MCQ",
      "options": [
        { "text": "The html for google.com", "correct": false },
        { "text": "\\`undefined\\`", "correct": true }
      ]
    },
    {
      "statement": "Until ES6, JavaScript itself has actually never had any direct notion of asynchrony built into it.",
      "explanation": "What you typically think of asynchrony is often the Web APIs, not the JavaScript engine.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "What data structure best explains the event loop?",
      "explanation": "The event loop is FIFO, or first-in-first-out, which is similar to that of a queue.",
      "type": "MCQ",
      "options": [
        { "text": "stack", "correct": false },
        { "text": "queue", "correct": true },
        { "text": "binary tree", "correct": false },
        { "text": "graph", "correct": false }
      ]
    },
    {
      "statement": "What statement about \\`setTimeout(callbackFn, 1000)\\` below is the most accurate.",
      "explanation": "Once the timer is up, the callback will get added to the event loop. If the event loop has 20 items, then the callback will execute once those 20 items are executed.",
      "type": "MCQ",
      "options": [
        {
          "text": "\\`callbackFn\\` will be executed once 1000ms has elapsed.",
          "correct": false
        },
        {
          "text": "\\`callbackFn\\` will be executed in at least 1000ms.",
          "correct": true
        },
        {
          "text": "\\`callbackFn\\` will be executed in at most 1000ms.",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is \"callback hell\" all about?",
      "explanation": "But the brittle nature of manually hardcoded callbacks (even with hardcoded error handling) is often far less graceful. Once you end up specifying (aka pre-planning) all the various eventualities/paths, the code becomes so convoluted that it's hard to ever maintain or update it. \\*\\*That\\*\\* is what \"callback hell\" is all about! The nesting/indentation are basically a side show, a red herring.",
      "type": "MCQ",
      "options": [
        {
          "text": "When you have several nested callbacks, and your code gets extremely indented",
          "correct": false
        },
        {
          "text": "Manually hardcoding callbacks makes your code so convoluted that it's hard to ever maintain or update it.",
          "correct": true
        },
        {
          "text": "Writing many lines of code within one file",
          "correct": false
        },
        {
          "text": "Making so many ajax calls that your page takes forever to load",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is troubling about the code below: \\`\\`\\`js analytics.trackPurchase( purchaseData, function(){ chargeCreditCard(); displayThankyouPage(); } ); \\`\\`\\`",
      "explanation": "This library could run this critical callback 1 time or 0 times or many times.",
      "type": "MCQ",
      "options": [
        {
          "text": "You are trusting this analytics library to ensure that critical functions get executed",
          "correct": true
        },
        {
          "text": "You are using analytics to track a purchase",
          "correct": false
        },
        { "text": "The callback is an anonymous function", "correct": false },
        { "text": "The functions are named poorly", "correct": false }
      ]
    },
    {
      "statement": "What scenario below is not a potential problem that needs to be handled when using callbacks:",
      "explanation": "Once the callback is run, any issue in your code is not the fault of the callback.",
      "type": "MCQ",
      "options": [
        { "text": "Call the callback too late (or never)", "correct": false },
        {
          "text": "Call the callback too few or too many times",
          "correct": false
        },
        {
          "text": "Fail to pass along any necessary environment/parameters to your callback",
          "correct": false
        },
        {
          "text": "Once the callback is run, fail to execute the rest of your code",
          "correct": true
        }
      ]
    },
    {
      "statement": "What is the difference between \\`fn()\\` and \\`setTimeout(fn, 0)\\`?",
      "explanation": "\\`setTimeout\\` is handled by the web API, and once the timer is up, it pushes the callback onto the event loop.",
      "type": "MCQ",
      "options": [
        {
          "text": "The first option will be executed right away, and the second will first be added to the event loop.",
          "correct": true
        },
        { "text": "Practically, there is no difference", "correct": false },
        {
          "text": "When \\`fn\\` is called on the second option, it will be called with an \\`event\\` argument",
          "correct": false
        },
        { "text": "The second option is more performant", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var a = 1 setTimeout(() => console.log(a), 0) for (let i = 0; i < 1000; i++) { } a++ \\`\\`\\`",
      "explanation": "The callback gets pushed onto the event loop immediately, but it doesn't run until the call stack is empty which occurs after the for loop and after \\`a++\\` is executed.",
      "type": "MCQ",
      "options": [
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`2\\`", "correct": true },
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`ReferenceError\\`", "correct": false }
      ]
    },
    {
      "statement": "How do Promises uninvert the \\*inversion of control\\*?",
      "explanation": "Promises allow you to remain in control when you make a request to a third party library.",
      "type": "MCQ",
      "options": [
        {
          "text": "With Promises, we can expect it to return us a capability to know when its task finishes. Then, our code can decide what to do next.",
          "correct": true
        },
        {
          "text": "They require you to send two callback functions: one for success and one for error case.",
          "correct": false
        },
        {
          "text": "They break asynchrony and coerce the functions into synchronous functions",
          "correct": false
        },
        {
          "text": "You promise to fulfill the request by calling the callback function",
          "correct": false
        }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js let prom1 = new Promise((resolve, reject) => { setTimeout(() => resolve(1), 1000) }) let prom2 = new Promise((resolve, reject) => { setTimeout(() => resolve(2), 500) }) Promise.all(\\[prom1, prom2\\]).then(function onComplete(results) { const sum = results.reduce((acc, val) => { return acc + val }, 0); console.log(sum) }) \\`\\`\\`",
      "explanation": "\\`Promise.all()\\` creates a single promise that resolves when all of the input promises resolve. In the example above, \\`onComplete\\` won't run until \\`prom1\\` and \\`prom2\\` have resolved.",
      "type": "MCQ",
      "options": [
        { "text": "\\`undefined\\`", "correct": false },
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`2\\`", "correct": false },
        { "text": "\\`3\\`", "correct": true }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js let promArr = \\[\\]; for (let i = 0; i < 10; i++) { promArr.push( new Promise((resolve, reject) => { setTimeout(() => resolve(1), 1000); }) ); } promArr.push( new Promise((resolve, reject) => { setTimeout(() => reject('uh oh'), 1500); }) ); Promise.all(promArr) .then(function onComplete(results) { const sum = results.reduce((acc, val) => { return acc + val; }, 0); console.log(sum); }) .catch(err => console.log(err)); \\`\\`\\`",
      "explanation": "If one promise rejects in \\`Promise.all\\`, then they all fail. Even though 10 of the promises passed to \\`Promise.all\\` resolved, we don't have access to the resolved data if one fails.",
      "type": "MCQ",
      "options": [
        { "text": "\\`10\\`", "correct": false },
        { "text": "\\`\"uh oh\"\\`", "correct": true },
        { "text": "\\`10 \"uh oh\"\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js let prom1 = new Promise((resolve, reject) => { setTimeout(() => resolve(1), 1000) }) let prom2 = new Promise((resolve, reject) => { setTimeout(() => resolve(2), 500) }) Promise.race(\\[prom1, prom2\\]).then(function onComplete(results) { console.log(results) }) \\`\\`\\`",
      "explanation": "With \\`Promise.race()\\`, as soon as the first promise resolves, the resolved value is sent to \\`onComplete\\`. Because \\`prom2\\`s timer was for less time than \\`prom1\\`, \\`prom2\\` won the race.",
      "type": "MCQ",
      "options": [
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`2\\`", "correct": true },
        { "text": "\\`\\[1, 2\\]\\`", "correct": false },
        { "text": "\\`\\[2, 1\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js const prom1 = Promise.resolve(1); const prom2 = Promise.reject('uh oh 2'); const prom3 = Promise.reject('uh oh 3'); Promise.all(\\[prom1, prom2, prom3\\]) .then(results => console.log(results)) .catch(err => console.log(err)); \\`\\`\\`",
      "explanation": "The error that gets sent to \\`Promise.all.catch()\\` is the rejected value of the first promise to reject. In this case that would be \\`prom2\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`\"uh oh 2\"\\`", "correct": true },
        { "text": "\\`\"uh oh 3\"\\`", "correct": false },
        { "text": "\\`\"uh oh 2\"\\` \\`\"uh oh 3\"\\`", "correct": false },
        { "text": "\\`\\[\"uh oh 2\", \"uh oh 3\"\\]\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js var x = 1; function\\* foo() { x++; yield; x++; } var bar = foo() bar.next() console.log(x) bar.next() console.log(x) \\`\\`\\`",
      "explanation": "The first time \\`bar.next\\` is called \\`foo\\` is run until \\`yield\\`. The second time, \\`bar.next\\` is called, \\`foo\\` is run until completion.",
      "type": "MCQ",
      "options": [
        { "text": "\\`2\\` \\`3\\`", "correct": true },
        { "text": "\\`1\\` \\`2\\`", "correct": false },
        { "text": "\\`1\\` \\`1\\`", "correct": false },
        { "text": "\\`3\\` \\`3\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js function\\* foo(x) { var y = x \\* (yield \"Hello\"); return y; } var it = foo(6); var res = it.next(); res = it.next(7); console.log(res.value); \\`\\`\\`",
      "explanation": "The first \\`it.next()\\` starts \\`foo\\`, and the second one replaces \\`\"Hello\"\\` with \\`7\\`, thus \\`y\\` is \\`42\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`NaN\\`", "correct": false },
        { "text": "\\`42\\`", "correct": true },
        { "text": "\\`42 \"Hello\"\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js function\\* foo() { var x = yield; var y = yield x; return x + y; } var it1 = foo(); var it2 = foo(); var val1 = 3; var val2 = 5; it1.next(); it2.next(); val1 = it1.next(val1).value; val2 = it2.next(val2).value; let returnVal1 = it1.next(val2).value; console.log(returnVal1); \\`\\`\\`",
      "explanation": "The answer ends up being \\`x\\` of \\`it1\\` plus \\`x\\` of \\`it2\\` which is just \\`val1\\` + \\`val2\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`3\\`", "correct": false },
        { "text": "\\`5\\`", "correct": false },
        { "text": "\\`8\\`", "correct": true },
        { "text": "\\`undefined\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js function\\* foo() { let x = 1; while (true) { yield x; x += 1; } } let sumNextVar = 0; for (let nextVar of foo()) { if (nextVar > 3) { break; } sumNextVar += nextVar; } console.log(sumNextVar); \\`\\`\\`",
      "explanation": "\\`for..of\\` will keep calling \\`next()\\` until the function returns. Because we have an infinte loop in \\`foo\\`, we need to manually stop our \\`for..of\\` loop, otherwise it will not stop.",
      "type": "MCQ",
      "options": [
        { "text": "\\`6\\`", "correct": true },
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`TypeError\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false }
      ]
    },
    {
      "statement": "What will be logged to the console when the following code is executed: \\`\\`\\`js function foo(x, y) { return new Promise((resolve, reject) => { setTimeout(() => resolve(y + 1), x); }); } function\\* main() { var num = yield foo(500, 1); console.log(num); } var it = main(); var p = it.next().value; p.then(num => { it.next(num); }); \\`\\`\\`",
      "explanation": "\\`it.next().value\\` starts \\`main\\` and gets the value from \\`foo(500, 1)\\` which is a promise. We then resolve the promise, and then continue running \\`main\\`.",
      "type": "MCQ",
      "options": [
        { "text": "\\`1\\`", "correct": false },
        { "text": "\\`2\\`", "correct": true },
        { "text": "\\`ReferenceError\\`", "correct": false },
        { "text": "\\`undefined\\`", "correct": false }
      ]
    },
    {
      "statement": "Why do we care about asynchrony? Why not make everything synchronous?",
      "explanation": "Our code would be very slow if all of our requests were blocking.",
      "type": "MCQ",
      "options": [
        { "text": "That would make our code less readable", "correct": false },
        { "text": "For performance reasons", "correct": true },
        {
          "text": "It would not be possible to make everything synchronous",
          "correct": false
        },
        {
          "text": "JavaScript is moving towards removing asynchrony",
          "correct": false
        }
      ]
    },
    {
      "statement": "What is a web worker?",
      "explanation": "An environment like your browser can easily provide multiple instances of the JavaScript engine, each on its own thread, and let you run a different program in each thread. Each of those separate threaded pieces of your program is called a \"(Web) Worker.\" This type of parallelism is called \"task parallelism,\" as the emphasis is on splitting up chunks of your program to run in parallel.",
      "type": "MCQ",
      "options": [
        {
          "text": "It is a function that is required in order to make PWAs",
          "correct": false
        },
        {
          "text": "A separate instance of the JavaScript engine allowing task parallelism",
          "correct": true
        },
        {
          "text": "A continuous and open connection with a server",
          "correct": false
        },
        {
          "text": "An ES7 feature that allows functions to not have run-to-completion behavior",
          "correct": false
        }
      ]
    },
    {
      "statement": "How do workers share scope or resources with each other or the main program?",
      "explanation": "Workers do not share any scope or resources with each other or the main program -- that would bring all the nightmares of threaded programming to the forefront -- but instead have a basic event messaging mechanism connecting them called the \\`postMessage\\` API.",
      "type": "MCQ",
      "options": [
        { "text": "Via the \\`postMessage\\` API", "correct": true },
        { "text": "Via the global scope", "correct": false },
        { "text": "Via closures", "correct": false },
        { "text": "Via lexical scoping", "correct": false }
      ]
    },
    {
      "statement": "What is \\*\\*not\\*\\* a common use for a web worker?",
      "explanation": "Web workers do not have access to the DOM",
      "type": "MCQ",
      "options": [
        { "text": "Processing intensive math calculations", "correct": false },
        { "text": "Sorting large data sets", "correct": false },
        { "text": "High-traffic network communications", "correct": false },
        { "text": "DOM diffing algorithm", "correct": true }
      ]
    },
    {
      "statement": "Shared Workers allow multiple instances of an app to share the same web worker",
      "explanation": "If your site or app allows for loading multiple tabs of the same page (a common feature), you may very well want to reduce the resource usage of their system by preventing duplicate dedicated Workers and using a Shared Worker.",
      "type": "TF",
      "correct": true
    },
    {
      "statement": "All performance optimizations matter and should be seriously evaluated",
      "explanation": "There is no point in chasing after small performance optimizations if you don't know have any reason to believe that it is causing your app to be slow.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "The code below is a valid way to test performance: \\`\\`\\`js var start = (new Date()).getTime(); // do some operation var end = (new Date()).getTime(); console.log( \"Duration:\", (end - start) ); \\`\\`\\`",
      "explanation": "There are many things wrong with this, but one of the main reasons is that this is only one run, one data point and is not statistically significant.",
      "type": "TF",
      "correct": false
    },
    {
      "statement": "Which of the following will not potentially affect your performance test?",
      "explanation": "Almost everything you can imagine can potentially affect your performance tests. Especially if your question isn't just \"is x faster than y\" but if the question includes \"is it a big enough difference for me to care\". Maybe x is consistently faster than y, but maybe it is so close that no one can tell the difference.",
      "type": "MCQ",
      "options": [
        {
          "text": "The amount of battery left on a smartphone that is running the test in Chrome",
          "correct": false
        },
        { "text": "Using polyfills", "correct": false },
        { "text": "Running the test one time vs many times", "correct": false },
        { "text": "The time of day that your tests are run", "correct": true }
      ]
    },
    {
      "statement": "What is the difference between jsPerf and Benchmark.js?",
      "explanation": "jsPerf uses the Benchmark.js library to run statistically accurate and reliable tests, and makes the test on an openly available URL that you can pass around to others. Each time a test is run, the results are collected and persisted with the test, and the cumulative test results are graphed on the page for anyone to see.",
      "type": "MCQ",
      "options": [
        {
          "text": "Benchmark.js is lower level and gives a statistical analysis of the test. jsPerf uses Benchmark.js to test in a browser.",
          "correct": true
        },
        {
          "text": "They are two libraries that do more or less the same thing",
          "correct": false
        },
        {
          "text": "jsPerf is compatible with ES6+ and Benchmark.js is not",
          "correct": false
        }
      ]
    },
    {
      "statement": "The browser will always execute your code as you wrote it",
      "explanation": "Browser JavaScript engines have come up with \"engine optimizations\" which speed up the execution of your code. They might execute your code differently from the way you wrote it if their way is faster \\*\\*and\\*\\* results in the same output as your way. This is one of the reasons why it is not directly obvious how to analytically compare two pieces of code. Especially when you consider that browsers are constantly updating and improving their engines.",
      "type": "TF",
      "correct": false
    }
  ]
}
